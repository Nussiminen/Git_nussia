
%%%-----------------------------------------------------------------------------
%%% @author qmagsed, Magnus Sedlacek
%%% @copyright (C) 2011, Ericsson AB, Sweden
%%% @doc
%%%
%%% @end
%%% Created :  25 Jul 2011 by QMAGSED
%%%-----------------------------------------------------------------------------

%%%-----------------------------------------------------------------------------
%%% GenTS Header:
%%%-----------------------------------------------------------------------------
%%% $Head_Prepared EAB/FJB/DLK QRAPEBA
%%% $Head_DocNo    3/102 64-CAH 109 1284/1 Uen
%%% $Head_Approved EAB/FJB/??? ??????? 
%%% $Head_Checked  -
%%% $Head_Date     2011-06-09
%%% $Head_Rev      PC3
%%% $Head_File     nci_ft_ricm_dul_SUITE.erl
%%% $Head_Name     Verification Specification
%%% $End
%%%-----------------------------------------------------------------------------
%%% $Title         NCI FT RICM in LTE
%%% $End
%%%-----------------------------------------------------------------------------

-module(nci_ft_ricm_dul_SUITE).

-compile(export_all).

%% CT
-include_lib("common_test/include/ct.hrl").

%% JCT
-include("cpp.hrl").
-include("coli.hrl").
-include("jctftp.hrl").
-include("osegw.hrl").

%% LIB
-include("nci_common.hrl").
-include("nci_cpri_converter.hrl").

-include("nci_bci_dci.hrl").
-include("nci_cbci_au.hrl").
-include("nci_idpi.hrl").
-include("nci_rici.hrl").

-include("nci_bci_dci_actions.hrl").
-include("nci_idpi_actions.hrl").
-include("nci_rici_actions.hrl").

%% For backward compability
-ifndef('ELIB_BC_CAP_ETH_HW_IF_SUPPORT2').
-define('ELIB_BC_CAP_ETH_HW_IF_SUPPORT2', 16). 
-endif.

-define('IDL2_LINE_RATE_2_5G', 2).
-define('IDL2_LINE_RATE_5G', 3).
-define('IDL2_LINE_RATE_10G', 4).

%%oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
%% $ChapterH1 Introduction
%% 
%%
%% $End
%%oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo

%%##############################################################################
%% $ChapterH2 Revision History
%%
%% $Table(
%% Revision | Date       | Comment                                 | Responsible
%%
%% PC5        2012-10-15   Added new test cases dci_arc4, dci_arc5.  EEDAJA
%%
%% PC4        2012-09-28   Added new test cases dci_cs1, dci_cs17.   EEDAJA
%%                         Fixed dci_cs2. Updated test case headers.
%%                         All passing erlang test cases are in group
%%                         erlang, and all not ready in erlangnotok.
%%                         In init_per_test_case, telnet reconnected.
%%
%% PC3        2011-06-09   More updates according to IR:             QRAPEBA
%%                         8/177 63-40/FCP 121 4365 Uen
%%
%% PC2        2011-05-06   Updated after review. IR:                 QPETJEN
%%                         8/177 63-40/FCP 121 4365 Uen
%%
%% PC1        2011-04-15   Generated the document via the VS         QPETJEN
%%                         generator. Now all scripts (i.e. 
%%                         test cases) are included in this 
%%                         document. Ready for review. 
%%                         L11B, it12
%%
%% B          2010-11-12   Approved                                  ETXIVRI
%%
%% A          2010-08-27   Approved. IR 4/177 63-FCP 101 8490.       ETXIVRI
%% )
%% 
%% $End
%%##############################################################################
%% $ChapterH2 Test Case History
%%
%% $End
%%##############################################################################
%% $ChapterH3 New Test Cases
%%
%% $Table(
%% Document revision | Test Case Id
%%
%% PC2                 CR91054_1, CR91054_2, CR91054_3, bci_activate_srio_testport6,
%%                     dci_arc2, dci_cs12, dci_std1, dci_std2, dci_std3, dci_std4,
%%                     dci_std5, hm68079_cs_reuse_resource,
%%                     hm68079_csmax_20mhz_rcl_csmax, hm68079_max_alloc_20MHz,
%%                     ricm_las_100, ricm_las_101, ricm_las_102, ricm_las_103,
%%                     ricm_las_104, WRN96501
%% )
%%
%% $End
%%##############################################################################
%% $ChapterH3 Removed Test Cases
%% 
%% $Table(
%% Document revision | Test Case Id
%%
%% )
%%
%% $End
%%##############################################################################
%% $ChapterH2 Purpose
%% 
%% This document contains test cases for the BCI, DCI and RICM interfaces and the functionality of the RICM application SW. See $Reference(3), [4] and [5].
%%
%% $End
%%##############################################################################
%% $ChapterH2 Assumptions
%%
%% - Unless otherwise stated, it is assumed that any server process communicated with is supervised using the OSE attach functionality, and that this is handled automatically by our test clients.
%%
%% - After the test case is completed a check is performed that no unexpected signals have been received.
%%
%% - Some signal indication prefixes in signal names have been omitted: ELIB_, RICM_, ELIB_ERROR_CODE, CONST_FH_FAULT_ID and more.
%%
%% - It is assumed that the LMC has been loaded before any of the test cases are performed (if not stated otherwise).
%%
%% - All testcases that doesnt specify otherwise does a fault subscription before the test starts.
%%
%% - BBCLK and BFN are activated where nothing else is mentioned.
%%
%% - Connection establish has been performed where nothing else is mentioned.
%%
%% - Where DP is stated we mean LMC. The LMC is loaded where nothing else is mentioned.
%%
%% - For all request signals that are sent during test a confirm or reject signal is expected within 20 seconds, except for load LMC request, then the confirm or reject is expected within 120 seconds.
%%
%% - All signals contains a struct of type AddressInfoS [5]. The struct contains the two U32 elements "clientRef" and "serverRef". This struct has been omitted in the testcase descriptions. Both "clientRef" and "serverRef" are set to 1 in the request signals and are expected to be the same in all signals received.
%%
%% - All reject signals in BCI and DCI contains a struct of type RejectCauseS [5]. The struct collects the U16 element "errorCode" and the U8 array "errorDescription". This struct has been omitted in the testcase descriptions. The elements in the struct and its corresponding values are specified though.
%%
%% - RRU22 is not supported and therfore not used.
%% 
%% $End
%%##############################################################################
%% $ChapterH2 Open Issues
%%
%% WP116 will probably change the testcases for visual indication 3.9
%%
%% $End
%%##############################################################################
%% $ChapterH2 Readers Guideline
%%
%% All testcases that doesnt specify otherwise does a connection establish, a fault subscription and loads the DP before the test starts.
%%
%% $End
%%##############################################################################

%%oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
%% $ChapterH1 General Information
%%
%% $End
%%oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo

%%##############################################################################
%% $ChapterH2 Tools and Scripts
%%
%% - We have a test application cbu_command. With this test application we can enable/disable BBCLK, fake temperature faults etc.
%%
%% - Ruby 
%%
%% - jcT Erlang/Common Test based test framework for testing 
%%
%% $End
%%##############################################################################
%% $ChapterH2 Verified Requirements
%% 
%% Any (partially) verified requirements are listed in each TC. If the requirement is not fully verified by the TC, it is declared within parentheses.
%%
%% $End
%%##############################################################################
%% $ChapterH2 Hardware Equipment
%%
%% Hardware equipment necessary for the verification:
%%
%% $Table(
%% Unit name       | Model/Version
%%
%% Workstation       Sun
%%
%% DUL Step 3        CXP102066/3
%%
%% SFP               -
%%
%% CPRI Cables       -
%%
%% RRUW01            -
%% )
%%
%% $End
%%
%%##############################################################################

%%oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
%% $ChapterH1 Test Cases
%% 
%%
%% $End
%%oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo

%%##############################################################################
%% $ChapterH2 Start and Restart
%%
%%
%% $End
%%##############################################################################


%%------------------------------------------------------------------------------
%% $Id ricm_las_101
%%
%% $Header
%%  Load and Start - Cold restart
%%
%% $Description
%%  Verify that a normal start-up sequence is performed without errors after a cold restart
%%
%% $Requirements
%%  N/A
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  At least one RU
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  -
%%
%% $Action_1
%%  Perform a cold restart on the node
%%
%% $Result_1
%%  Node is restarted
%%
%% $Action_2
%%  Establish BCI connection (connection between NC - BCI)
%%
%% $Result_2
%%  BCI connection correctly established
%%
%% $Action_3
%%  Make sure that state is in starting
%%
%% $Result_3
%%  The state is in starting
%%
%% $Action_4
%%  Load DP LMC
%%
%% $Result_4
%%  DP LMC is loaded
%%
%% $Action_5
%%  Get the board capability information and make sure corrects capabilities are received
%%
%% $Result_5
%%  Information regarding the board capability are received
%%
%% $Action_6
%%  Set state to operational
%% 
%% $Result_6
%%  The state is set to operational
%%
%% $Action_7
%%  Establish RICM connection (connection between MP - DCI)
%%
%% $Result_7
%%  DCI connection correctly established
%%
%% $Action_8
%%  Start CPRI link
%%
%% $Result_8
%%  CPRI link started
%%
%% $Action_9
%%  Connect to the RU
%%
%% $Result_9
%%  ECP connection established to the RU
%%
%% $Action_10
%%  Setup one UL and one DL carrier
%%
%% $Result_10
%%  The carriers are configured
%%
%% $Postcondition
%%  Release carriers
%%  Bring down CPRI link
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-05-30, QMAGSED
%%    First version
%%
%%  2014-01-13, EBACEMI
%%    Revised TC.
%%    Implemented BUG 654
%%
%%------------------------------------------------------------------------------
ricm_las_101() ->
	[{userdata,[{wp, ""},
				{requirement, "-"},
				{slogan, "Load and Start - Cold restart"},
				{hwConfig, hwConfigA}]}].

ricm_las_101(_Config) ->
	ricm_las("ricm_las_101").

ricm_las( Name ) ->
	ct:pal(Name),

	{ok, session_up} = coli:subscribe_state(?SHELL_COMMAND),
	{ok, session_up} = osegw:subscribe_state(?OSE_GW_DEAMON_1),

    CPPTelnet = cpp_server:get_value(?CPP_NAME, coli),

	ct:pal("Action_1"),
	case Name of
		"ricm_las_101" ->
			ct:pal("Cold restart"),
			cpp_lib:restart_and_poll(CPPTelnet, "cold", 120 * 1000);

		"ricm_las_102" ->
			ct:pal("Warm restart"),
			cpp_lib:restart_and_poll(CPPTelnet, "warm", 120 * 1000);

		"ricm_las_103" ->
			ct:pal("Cold restart with HW Test"),
			cpp_lib:restart_and_poll(CPPTelnet, "coldwtest", 300 * 1000);

		"ricm_las_104" ->
			ct:pal("Reload refresh"),
			cpp_lib:restart_and_poll(CPPTelnet, "refresh", 120 * 1000)
	end,
	
	ok = coli:wait_for_session_toggle(?SHELL_COMMAND, 60 * 1000),
	ok = osegw:wait_for_session_toggle(?OSE_GW_DEAMON_1, 60 * 1000),
	
	ct:pal("Action_2"),
	ok = nci_bci_actions:conn_establish([]),
	
	ct:pal("Action_3"),
	ok = nci_bci_actions:audit([{expectedMainState, ?ELIB_BC_MAIN_STATE_STARTING}]),
	
	LoadModule = get_lmc_name(),
	SearchPath = nci_common_cfg:get_c_loadmodules_path(),
	
	ct:pal("Action_4"),
	ok = nci_bci_actions:load_lmc([{searchPath, SearchPath},
								   {loadModule, LoadModule}]),

	ct:pal("Action_5"),
	{ok, Received} = nci_bci_actions:get_capabilities_get([]),
	ct:pal("Received:~n~s", [osegw_lib:pretty_format(Received, nci_bci_dci)]),

	board_cap(Received#'ElibBcGetCapabilitiesCfmS'.boardCapabilities),

	ct:pal("Action_6"),
	ok = nci_bci_actions:enable_operation([]),
	
	ct:pal("Action_7"),
	ok = nci_dci_actions:conn_establish([]),

	Radio = nci_ricm_utils:get_first_radio(),

	ct:pal("Action_8"),
	ok = nci_dci_actions:start_cpri_link(Radio),
	ok = nci_dci_actions:cpri_link_ind(Radio ++ [{typeOfUnit, '_'},{availStatus, 1}]),

	ct:pal("Action_9"),
	nci_dci_actions:add_radio_control(Radio),
	nci_dci_actions:radio_control_ind(Radio ++ [{connStatus, 1}]),

	%% Add Carriers UL
	ct:pal("Action_10"),
	ok = nci_dci_actions:carrier_setup3(Radio ++ [{xioPort, 0},
												  {direction, ?RICM_CARRIER_DIRECTION_UL}, 
												  {carrierId, 0},
												  {posA, 0},
												  {noOfSamples, 2},
												  {isSubBand, ?ELIB_CONST_HWU_YES}]),
	%% Add Carriers DL
	XioPortDL = case nci_common_utils:get_du() of
		dul -> 1;
		dus -> 6;
		mRBS_lte -> 6;
		_ -> 1
	end,

	ok = nci_dci_actions:carrier_setup3(Radio ++ [{xioPort, XioPortDL},
												  {direction, ?RICM_CARRIER_DIRECTION_DL},
												  {carrierId, 1},
												  {posA, 0},
												  {noOfSamples, 2},
												  {isSubBand, ?ELIB_CONST_HWU_YES}]),

	%% Release Carrier DL
	ok = nci_dci_actions:carrier_release(Radio ++ [{carrierId, 1}]),
	
	%% Release Carrier UL
	ok = nci_dci_actions:carrier_release(Radio ++ [{carrierId, 0}]),

	%% Reset CPRI Link
	ok = nci_dci_actions:reset_cpri_link(Radio),
	ok = nci_dci_actions:reset_cpri_link_ind(Radio),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id ricm_las_102
%%
%% $Header
%%  Load and Start - Warm restart
%%
%% $Description
%%  Verify that a normal start-up sequence is performed without errors after a warm restart
%%
%% $Requirements
%%  N/A
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  At least one RU
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  -
%%
%% $Action_1
%%  Perform a cold restart on the node
%%
%% $Result_1
%%  Node is restarted
%%
%% $Action_2
%%  Establish BCI connection (connection between NC - BCI)
%%
%% $Result_2
%%  BCI connection correctly established
%%
%% $Action_3
%%  Make sure that state is in starting
%%
%% $Result_3
%%  The state is in starting
%%
%% $Action_4
%%  Load DP LMC
%%
%% $Result_4
%%  DP LMC is loaded
%%
%% $Action_5
%%  Get the board capability information and make sure corrects capabilities are received
%%
%% $Result_5
%%  Information regarding the board capability are received
%%
%% $Action_6
%%  Set state to operational
%% 
%% $Result_6
%%  The state is set to operational
%%
%% $Action_7
%%  Establish RICM connection (connection between MP - DCI)
%%
%% $Result_7
%%  DCI connection correctly established
%%
%% $Action_8
%%  Start CPRI link
%%
%% $Result_8
%%  CPRI link started
%%
%% $Action_9
%%  Connect to the RU
%%
%% $Result_9
%%  ECP connection established to the RU
%%
%% $Action_10
%%  Setup one UL and one DL carrier
%%
%% $Result_10
%%  The carriers are configured
%%
%% $Postcondition
%%  Release carriers
%%  Bring down CPRI link
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-05-30, QMAGSED
%%    First version
%%
%%  2014-01-13, EBACEMI
%%    Revised TC.
%%    Implemented BUG 654
%%
%%------------------------------------------------------------------------------
ricm_las_102() ->
	[{userdata,[{wp, ""},
				{requirement, "-"},
				{slogan, "Load and Start - Warm restart"},
				{hwConfig, hwConfigA}]}].

ricm_las_102(_Config) ->
	ricm_las("ricm_las_102").

%%------------------------------------------------------------------------------
%% $Id ricm_las_103
%%
%% $Header
%%  Load and Start - Cold restart with HW test
%%
%% $Description
%%  Verify that a normal start-up sequence is performed without errors after a cold restart with HW test
%%
%% $Requirements
%%  N/A
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  At least one RU
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  -
%%
%% $Action_1
%%  Perform a cold restart on the node
%%
%% $Result_1
%%  Node is restarted
%%
%% $Action_2
%%  Establish BCI connection (connection between NC - BCI)
%%
%% $Result_2
%%  BCI connection correctly established
%%
%% $Action_3
%%  Make sure that state is in starting
%%
%% $Result_3
%%  The state is in starting
%%
%% $Action_4
%%  Load DP LMC
%%
%% $Result_4
%%  DP LMC is loaded
%%
%% $Action_5
%%  Get the board capability information and make sure corrects capabilities are received
%%
%% $Result_5
%%  Information regarding the board capability are received
%%
%% $Action_6
%%  Set state to operational
%% 
%% $Result_6
%%  The state is set to operational
%%
%% $Action_7
%%  Establish RICM connection (connection between MP - DCI)
%%
%% $Result_7
%%  DCI connection correctly established
%%
%% $Action_8
%%  Start CPRI link
%%
%% $Result_8
%%  CPRI link started
%%
%% $Action_9
%%  Connect to the RU
%%
%% $Result_9
%%  ECP connection established to the RU
%%
%% $Action_10
%%  Setup one UL and one DL carrier
%%
%% $Result_10
%%  The carriers are configured
%%
%% $Postcondition
%%  Release carriers
%%  Bring down CPRI link
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-05-30, QMAGSED
%%    First version
%%
%%  2014-01-13, EBACEMI
%%    Revised TC.
%%    Implemented BUG 654
%%
%%------------------------------------------------------------------------------
ricm_las_103() ->
	[{userdata,[{wp, ""},
				{requirement, "-"},
				{slogan, "Load and Start - Cold restart with HW test"},
				{hwConfig, hwConfigA}]}].

ricm_las_103(_Config) ->
	ricm_las("ricm_las_103").

%%------------------------------------------------------------------------------
%% $Id ricm_las_104
%%
%% $Header
%%  Load and Start - Refresh restart
%%
%% $Description
%%  Verify that a normal start-up sequence is performed without errors after a refresh restart
%%
%% $Requirements
%%  N/A
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  At least one RU
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  -
%%
%% $Action_1
%%  Perform a cold restart on the node
%%
%% $Result_1
%%  Node is restarted
%%
%% $Action_2
%%  Establish BCI connection (connection between NC - BCI)
%%
%% $Result_2
%%  BCI connection correctly established
%%
%% $Action_3
%%  Make sure that state is in starting
%%
%% $Result_3
%%  The state is in starting
%%
%% $Action_4
%%  Load DP LMC
%%
%% $Result_4
%%  DP LMC is loaded
%%
%% $Action_5
%%  Get the board capability information and make sure corrects capabilities are received
%%
%% $Result_5
%%  Information regarding the board capability are received
%%
%% $Action_6
%%  Set state to operational
%% 
%% $Result_6
%%  The state is set to operational
%%
%% $Action_7
%%  Establish RICM connection (connection between MP - DCI)
%%
%% $Result_7
%%  DCI connection correctly established
%%
%% $Action_8
%%  Start CPRI link
%%
%% $Result_8
%%  CPRI link started
%%
%% $Action_9
%%  Connect to the RU
%%
%% $Result_9
%%  ECP connection established to the RU
%%
%% $Action_10
%%  Setup one UL and one DL carrier
%%
%% $Result_10
%%  The carriers are configured
%%
%% $Postcondition
%%  Release carriers
%%  Bring down CPRI link
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-05-30, QMAGSED
%%    First version
%%
%%  2014-01-13, EBACEMI
%%    Revised TC.
%%    Implemented BUG 654
%%
%%------------------------------------------------------------------------------
ricm_las_104() ->
	[{userdata,[{wp, ""},
				{requirement, "-"},
				{slogan, "Load and Start - Refresh restart"},
				{hwConfig, hwConfigA}]}].

ricm_las_104(_Config) ->
	ricm_las("ricm_las_104").

%%##############################################################################
%% $ChapterH2 Audit
%%
%% DU BC shall answer its current state upon request.
%%
%% $End
%%##############################################################################

%%------------------------------------------------------------------------------
%% $Id BCI_AT1
%%
%% $Header
%%  State Starting
%%
%% $Description
%%  Test audit when DU BC is in state starting
%%
%% $Requirements
%%  CBD_DBC_BCI_OM:2:A
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  The DU BC is in state starting
%%
%% $Action
%%  Send a AUDIT_REQ.
%%
%% $Result
%%  A AUDIT_CFM is received with parameters:
%%
%%  mainState = STATE_STARTING
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-05-30, QMAGSED
%%    First version
%%
%%------------------------------------------------------------------------------
bci_at1() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_DBC_BCI_OM:2:A"},
				{slogan, "Test audit when DU BC is in state starting"}]}].

bci_at1(_Config) ->
	ct:pal("bci_at1"),

	{ok, session_up} = coli:subscribe_state(?SHELL_COMMAND),
	{ok, session_up} = osegw:subscribe_state(?OSE_GW_DEAMON_1),

	nci_bci_states:set_state([{state, starting_lmc_loaded}]),

	%% Connect to BCI interface
	ok = nci_bci_actions:conn_establish([]),

	%% Audit
	ok = nci_bci_actions:audit([{expectedSigNo, ?ELIB_BC_AUDIT_CFM},
								{expectedMainState, ?ELIB_BC_MAIN_STATE_STARTING}]),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id BCI_AT2
%%
%% $Header
%%  State Operational
%%
%% $Description
%%  Test audit when DU BC is in state Operational
%%
%% $Requirements
%%  CBD_DBC_BCI_OM:2:A
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state Operational
%%
%% $Action
%%  Send a AUDIT_REQ.
%%
%% $Result
%%  A AUDIT_CFM is received with parameters:
%%
%%  mainState = STATE_OPERATIONAL
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-05-30, QMAGSED
%%    First version
%%
%%------------------------------------------------------------------------------
bci_at2() ->
	[{userdata, [{wp, ""}, 
				{requirement, "CBD_DBC_BCI_OM:2:A"},
				{slogan, "Test audit when DU BC is in state Operational"}]}].

bci_at2(_Config) ->
	ct:pal("bci_at2"),

	{ok, session_up} = coli:subscribe_state(?SHELL_COMMAND),
	{ok, session_up} = osegw:subscribe_state(?OSE_GW_DEAMON_1),

	nci_bci_states:set_state([{state, operational}]),

	%% Connect to BCI interface
	ok = nci_bci_actions:conn_establish([]),

	%% Audit 
	ok = nci_bci_actions:audit([{expectedSigNo, ?ELIB_BC_AUDIT_CFM},
								{expectedMainState, ?ELIB_BC_MAIN_STATE_OPERATIONAL}]),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id BCI_AT3
%%
%% $Header
%%  State Disabled
%%
%% $Description
%%  Test audit when DU BC is in state Disabled
%%
%% $Requirements
%%  CBD_DBC_BCI_OM:2:A
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state Disbaled
%%
%% $Action
%%  Send a AUDIT_REQ.
%%
%% $Result
%%  A AUDIT_CFM is received with parameters:
%%
%%  mainState = STATE_DISABLED
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-05-30, QMAGSED
%%    First version
%%
%%------------------------------------------------------------------------------
bci_at3() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_DBC_BCI_OM:2:A"},
				{slogan, "Test audit when DU BC is in state Disabled"}]}].

bci_at3(_Config) ->
	ct:pal("bci_at3"),

	{ok, session_up} = coli:subscribe_state(?SHELL_COMMAND),
	{ok, session_up} = osegw:subscribe_state(?OSE_GW_DEAMON_1),

	nci_bci_states:set_state([{state, disabled}]),

	%% Connect to BCI interface
	ok = nci_bci_actions:conn_establish([]),

	%% Audit 
	ok = nci_bci_actions:audit([{expectedSigNo, ?ELIB_BC_AUDIT_CFM},
								{expectedMainState, ?ELIB_BC_MAIN_STATE_DISABLED}]),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id BCI_AT4
%%
%% $Header
%%  DP Not Loaded
%%
%% $Description
%%  Test audit when LMC is not loaded
%%
%% $Requirements
%%  CBD_DBC_BCI_OM:2:A
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  LMC not loaded.
%%
%%  The DU BC is in state starting.
%%
%% $Action
%%  Send a AUDIT_REQ.
%%
%% $Result
%%  A AUDIT_CFM is received with parameters:
%%
%%  mainState = STATE_STARTING
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-05-30, QMAGSED
%%    First version
%%
%%------------------------------------------------------------------------------
bci_at4() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_DBC_BCI_OM:2:A"},
				{slogan, "DP Not Loaded"}]}].

bci_at4(_Config) ->
	ct:pal("bci_at4"),

	{ok, session_up} = coli:subscribe_state(?SHELL_COMMAND),
	{ok, session_up} = osegw:subscribe_state(?OSE_GW_DEAMON_1),

	nci_bci_states:set_state([{state, starting_lmc_not_loaded}]),

	%% Connect to BCI interface
	ok = nci_bci_actions:conn_establish([]),

	%% Audit
	ok = nci_bci_actions:audit([{expectedSigNo, ?ELIB_BC_AUDIT_CFM},
								{expectedMainState, ?ELIB_BC_MAIN_STATE_STARTING}]),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%##############################################################################
%% $ChapterH2 Protocol Version Negotiation
%%
%% The purpose of connection establish is to set up a signaling link between UnitControl and DU BC. The UnitControl provides the protocol revision it willl use.
%%
%% $End
%%##############################################################################

%%------------------------------------------------------------------------------
%% $Id BCI_CE1
%%
%% $Header
%%  Normal Use Case
%%
%% $Description
%%  Connection establish after a restart
%%
%% $Requirements
%%  CBD_START-RESTART_BCI_OM:6:B
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  No connection establish procedure has been performed since last restart
%%
%% $Action_1
%%  Send a CONN_ESTABLISH_REQ, with parameters: 
%%
%%  protocolRev = REV
%%
%% $Result_1
%%  A CONN_ESTABLISH_CFM is received
%%  
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  2012-11-05, EEDAJA
%%
%% Revision history:
%%  2012-05-30, QMAGSED
%%    First version
%%
%%------------------------------------------------------------------------------
bci_ce1() ->
	[{userdata,[{wp, ""},
				{requirement, "CBD_START-RESTART_BCI_OM:6:B"},
				{slogan, "Connection establish after a restart"}]}].

bci_ce1(_Config) ->
	ct:pal("bci_ce1"),

	%% Restart Board
	ok = nci_bci_actions:conn_establish([]),
	LogString = string:concat("Test case ", string:to_upper("bci_ce1")),

	nci_bci_states:restart_board( LogString ),

	%% Connect to BCI interface
	ok = nci_bci_actions:conn_establish([{expectedSigNo, ?ELIB_BC_CONN_ESTABLISH_CFM}]),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id BCI_CE2
%%
%% $Header
%%  Wrong protocol revision
%%
%% $Description
%%  To verify that version negotiation handles the case of the requested protocol version being too high and too low
%%
%% $Requirements
%%  CBD_START-RESTART_BCI_OM:6:B
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  No connection establish procedure has been performed since last restart
%%
%% $Action_1
%%  Send a CONN_ESTABLISH_REQ with parameters:
%%
%%  protocolRev = REV + 1
%%
%% $Result_1
%%  A CONN_ESTABLISH_REJ is received, with:
%%
%%  errorCode = UNSUCCESSFUL
%%
%%  errorDescription = "Invalid protocol revision" 
%%
%% $Action_2
%%  Send a CONN_ESTABLISH_REQ with parameters:
%%
%%  protocolRev = REV -1
%%
%% $Result_2
%%  A CONN_ESTABLISH_REJ is received, with:
%%
%%  errorCode = UNSUCCESSFUL
%%
%%  errorDescription = "Invalid protocol revision" 
%%  
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  2012-11-05, EEDAJA
%%
%% Revision history:
%%  2012-05-30, QMAGSED
%%    First version
%%
%%------------------------------------------------------------------------------
bci_ce2() ->
	[{userdata,[{wp, ""},
				{requirement, "CBD_START-RESTART_BCI_OM:6:B"},
				{slogan, "Wrong protocol revision"}]}].

bci_ce2(_Config) ->
	ct:pal("bci_ce2"),

	%% Restart Board
	ok = nci_bci_actions:conn_establish([]),
	LogString = string:concat("Test case ", string:to_upper("bci_ce2")),
	nci_bci_states:restart_board( LogString ),

	%% Connect to BCI interface protocol rev + 1
	ok = nci_bci_actions:conn_establish([{protocolRev, (?ELIB_BC_REV+1)},
										{expectedSigNo, ?ELIB_BC_CONN_ESTABLISH_REJ},
										{errorCode, 1},
										{errorDescription, {regexp, "Invalid protocol revision*"}}]),

	%% Connect to BCI interface protocol rev - 1
	ok = nci_bci_actions:conn_establish([{protocolRev, ?ELIB_BC_REV-1},
										{expectedSigNo, ?ELIB_BC_CONN_ESTABLISH_REJ},
										{errorCode, 1},
										{errorDescription, {regexp, "Invalid protocol revision*"}}]),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id BCI_CE3
%%
%% $Header
%%  Max No Of Clients
%%
%% $Description
%%  To verify that a maximum of 3 clients can be in state connected simultaneously
%%
%% $Requirements
%%  CBD_START-RESTART_BCI_OM:6:B
%%
%%  CBD_START-RESTART_BCI_OM:1:A
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  No connection establish procedure has been performed since last restart
%%
%% $Action
%%  Client A sends a CONN_ESTABLISH_REQ, with parameters: 
%%
%%  protocolRev = REV
%%
%% $Result
%%  Client Areceives a CONN_ESTABLISH_CFM
%%  
%% $Action
%%  Client B sends a CONN_ESTABLISH_REQ, with parameters:
%%
%%  protocolRev = REV
%%
%% $Result
%%  Client B receives a CONN_ESTABLISH_CFM
%%  
%% $Action
%%  Client C sends a CONN_ESTABLISH_REQ, with parameters:
%%
%%  protocolRev = REV
%%
%% $Result
%%  Client C receives a CONN_ESTABLISH_CFM
%%  
%% $Action
%%  Client D sends a CONN_ESTABLISH_REQ, with parameters: 
%%
%%  protocolRev = REV
%%
%% $Result
%%  Client D receives a CONN_ESTABLISH_REJ, with parameters:
%%
%%  errorCode= UNSUCCESSFUL
%%
%%  errorDescription = Too many clients already connected
%%  
%% $Postcondition
%%  -
%%
%% $End
%% Review:
%%  2012-11-05, EEDAJA
%%
%% Revision history:
%%  2012-05-30, QMAGSED
%%    First version
%%
%%------------------------------------------------------------------------------
bci_ce3() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_START-RESTART_BCI_OM:6:B, CBD_START-RESTART_BCI_OM:1:A"},
				{slogan, "To verify that a maximum of 3 clients can be in state connected simultaneously."}]}].

bci_ce3(_Config) ->
	ct:pal("bci_ce3"),

	%% Restart Board
	ok = nci_bci_actions:conn_establish([]),
	LogString = string:concat("Test case ", string:to_upper("bci_ce3")),
	nci_bci_states:restart_board( LogString ),

	%% Create 3 more GWs
	ok = osegw:create(#osegw{name = ?OSE_GW_DEAMON_2, 
							iap = osegw, 
							opt = [{ping_timeout, 6000}, 
									{codec_config, 
									{?SIG_MODS, 
									sizeof, 
									osegw_ose,big}}]}),
	ok = osegw:create(#osegw{name = ?OSE_GW_DEAMON_3, 
							iap = osegw, 
							opt = [{ping_timeout, 6000}, 
									{codec_config, 
									{?SIG_MODS, 
									sizeof, 
									osegw_ose,big}}]}),
	ok = osegw:create(#osegw{name = ?OSE_GW_DEAMON_4, 
							iap = osegw, 
							opt = [{ping_timeout, 6000}, 
									{codec_config, 
									{?SIG_MODS, 
									sizeof, 
									osegw_ose,big}}]}),

	%% Connect 3 clients to BCI interface
	ok = nci_bci_actions:conn_establish([{oseGwDeamon,?OSE_GW_DEAMON_1},
										{expectedSigNo, ?ELIB_BC_CONN_ESTABLISH_CFM}]),
	ok = nci_bci_actions:conn_establish([{oseGwDeamon,?OSE_GW_DEAMON_2},
										{expectedSigNo, ?ELIB_BC_CONN_ESTABLISH_CFM}]),
	ok = nci_bci_actions:conn_establish([{oseGwDeamon,?OSE_GW_DEAMON_3},
										{expectedSigNo, ?ELIB_BC_CONN_ESTABLISH_CFM}]),

	%% Connect 4:th client that will fail 
	ok = nci_bci_actions:conn_establish([{oseGwDeamon,?OSE_GW_DEAMON_4},
										{expectedSigNo, ?ELIB_BC_CONN_ESTABLISH_REJ},
										{errorCode, 1},
										{errorDescription, {regexp, "Too many clients already connected*"}}]),

	%% Check that NO BC/DC_FAULT_IND is generated on all GWs.
	nci_common_utils:check_outstanding_faults(?OSE_GW_DEAMON_1, 2000),
	nci_common_utils:check_outstanding_faults(?OSE_GW_DEAMON_2, 200),
	nci_common_utils:check_outstanding_faults(?OSE_GW_DEAMON_3, 200),

	%% Delete created OSE GWs
	ok = osegw:delete(?OSE_GW_DEAMON_2),
	ok = osegw:delete(?OSE_GW_DEAMON_3),
	ok = osegw:delete(?OSE_GW_DEAMON_4).

%%------------------------------------------------------------------------------
%% $Id BCI_CE4
%%
%% $Header
%%  Signals in state Not Connected
%%
%% $Description
%%  Test sending a signal in state not connected. No answer should be sent back from the DU BC
%%
%% $Requirements
%%  CBD_DBC_VII_FU:1:A
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  No connection establish procedure has been performed
%%
%% $Action
%%  Send a AUDIT_REQ
%%
%% $Result
%%  No AUDIT_CFM is received within 20 seconds
%%  
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-05-30, QMAGSED
%%    First version
%%
%%------------------------------------------------------------------------------
bci_ce4() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_DBC_VII_FU:1:A"},
				{slogan, "Signals in state Not Connected"}]}].

bci_ce4(_Config) ->
	ct:pal("bci_ce4"),

	%% Restart Board
	ok = nci_bci_actions:conn_establish([]),
	LogString = string:concat("Test case ", string:to_upper("bci_ce4")),
	nci_bci_states:restart_board( LogString ),

	%% Send Audit Req
	ok = nci_bci_actions:audit_send([]),

	case nci_common_utils:check_for_signals(?OSE_GW_DEAMON_1, 20000) of
		timeout -> ok;
		Received ->
			ct:pal("Received Signal: ~p", [Received]),
			ct:fail("Received Signal")
	end,

	%% Check that NO BC/DC_FAULT_IND is generated on all GWs.
	nci_common_utils:check_outstanding_faults(2000).	

%%------------------------------------------------------------------------------
%% $Id BCI_CE5
%%
%% $Header
%%  State Operational
%%
%% $Description
%%  To verify the version negotiation in state operational
%%
%% $Requirements
%%  CBD_DBC_VII_FU:1:A
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  DU BC is in state operational
%%
%% $Action
%%  Send a CONN_ESTABLISH_REQ, with parameters:
%%
%%  protocolRev = REV
%%
%% $Result
%%  A CONN_ESTABLISH_CFM is received  
%%
%% $Action
%%  Send a AUDIT_REQ
%%
%% $Result
%%  A AUDIT_CFM is received with parameters:
%%
%%  mainState = STATE_OPERATIONAL
%%  
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-05-30, QMAGSED
%%    First version
%%
%%------------------------------------------------------------------------------
bci_ce5() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_DBC_VII_FU:1:A"},
				{slogan, "To verify the version negotiation in state operational"}]}].

bci_ce5(_Config) ->
	ct:pal("bci_ce5"),

	{ok, session_up} = coli:subscribe_state(?SHELL_COMMAND),
	{ok, session_up} = osegw:subscribe_state(?OSE_GW_DEAMON_1),

	nci_bci_states:set_state([{state, operational}]),

	%% Connect to BCI interface
	ok = nci_bci_actions:conn_establish([]),

	%% Audit 
	ok = nci_bci_actions:audit([{expectedSigNo, ?ELIB_BC_AUDIT_CFM},
								{expectedMainState, ?ELIB_BC_MAIN_STATE_OPERATIONAL}]),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id BCI_CE6
%%
%% $Header
%%  State Disabled
%%
%% $Description
%%  To verify the version negotiation is possible when DU BC is in state disabled
%%
%% $Requirements
%%  CBD_START-RESTART_BCI_OM:3:A
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  DU BC is in state disabled
%%
%% $Action
%%  Send a CONN_ESTABLISH_REQ, with parameters: 
%%
%%  protocolRev = REV
%%
%% $Result
%%  A CONN_ESTABLISH_CFM is received  
%%
%% $Action
%%  Send a AUDIT_REQ
%%
%% $Result
%%  A AUDIT_CFM is received with parameters:
%%
%%  %mainState = MAIN_STATE_DISABLED
%%  
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-05-30, QMAGSED
%%    First version
%%
%%------------------------------------------------------------------------------
bci_ce6() ->
	[{userdata,[{wp, ""},
				{requirement, "CBD_START-RESTART_BCI_OM:3:A"},
				{slogan, "To verify the version negotiation is possible when DU BC is in state disabled"}]}].

bci_ce6(_Config) ->
	ct:pal("bci_ce6"),

	{ok, session_up} = coli:subscribe_state(?SHELL_COMMAND),
	{ok, session_up} = osegw:subscribe_state(?OSE_GW_DEAMON_1),

	nci_bci_states:set_state([{state, disabled}]),

	%% Connect to BCI interface
	ok = nci_bci_actions:conn_establish([]),

	%% Audit 
	ok = nci_bci_actions:audit([{expectedSigNo, ?ELIB_BC_AUDIT_CFM},
								{expectedMainState, ?ELIB_BC_MAIN_STATE_DISABLED}]),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%##############################################################################
%% $ChapterH2 Disable Operation
%%
%% Upon disable request the DU BC shall change its current state to disabled. Restart is the only way to leave the disable state.
%% $End
%%##############################################################################

%%------------------------------------------------------------------------------
%% $Id BCI_DO1
%%
%% $Header
%%  State Starting
%%
%% $Description
%%  Test disable operation in state starting
%%
%% $Requirements
%%  CBD_START-RESTART_BCI_OM:3:A
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state starting
%%
%% $Action
%%  Send a DISABLE_OPERATION_REQ
%%
%% $Result
%%  A DISABLE_OPERATION_CFM is received  
%%
%% $Action
%%  Send a AUDIT_REQ
%%
%% $Result
%%  A BC_AUDIT_CFM is received with parameters:
%%
%%  mainState = BC_MAIN_STATE_DISABLED
%%  
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-05-30, QMAGSED
%%    First version
%%
%%------------------------------------------------------------------------------
bci_do1() ->
	[{userdata,[{wp, ""},
				{requirement, ""},
				{slogan, ""}]}].

bci_do1(_Config) ->
	ct:pal("bci_do1"),

	{ok, session_up} = coli:subscribe_state(?SHELL_COMMAND),
	{ok, session_up} = osegw:subscribe_state(?OSE_GW_DEAMON_1),

	nci_bci_states:set_state([{state, starting_lmc_loaded}]),

	%% Connect to BCI interface
	ok = nci_bci_actions:conn_establish([]),

	%% Disable operations
	ok = nci_bci_actions:disable_operation([]),

	%% Audit 
	ok = nci_bci_actions:audit([{expectedSigNo, ?ELIB_BC_AUDIT_CFM},
								{expectedMainState, ?ELIB_BC_MAIN_STATE_DISABLED}]),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id BCI_DO2
%%
%% $Header
%%  State Operational
%%
%% $Description
%%  Test disable operation in state operational
%%
%% $Requirements
%%  CBD_START-RESTART_BCI_OM:3:A
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state operational
%%
%% $Action
%%  Send a DISABLE_OPERATION_REQ
%%
%% $Result
%%  A DISABLE_OPERATION_CFM is received  
%%
%% $Action
%%  Send a AUDIT_REQ
%%
%% $Result
%%  A BC_AUDIT_CFM is received with parameters:
%%
%%  mainState = BC_MAIN_STATE_DISABLED
%%  
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-05-30, QMAGSED
%%    First version
%%
%%------------------------------------------------------------------------------
bci_do2() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_START-RESTART_BCI_OM:3:A"},
				{slogan, "Test disable operation in state operational"}]}].

bci_do2(_Config) ->
	ct:pal("bci_do2"),

	{ok, session_up} = coli:subscribe_state(?SHELL_COMMAND),
	{ok, session_up} = osegw:subscribe_state(?OSE_GW_DEAMON_1),

	nci_bci_states:set_state([{state, operational}]),

	%% Connect to BCI interface
	ok = nci_bci_actions:conn_establish([]),

	%% Disable operations
	ok = nci_bci_actions:disable_operation([]),

	%% Audit 
	ok = nci_bci_actions:audit([{expectedSigNo, ?ELIB_BC_AUDIT_CFM},
								{expectedMainState, ?ELIB_BC_MAIN_STATE_DISABLED}]),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id BCI_DO3
%%
%% $Header
%%  State Disabled
%%
%% $Description
%%  Test disable operation in state disabled
%%
%% $Requirements
%%  CBD_START-RESTART_BCI_OM:3:A
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state disabled
%%
%% $Action
%%  Send a DISABLE_OPERATION_REQ
%%
%% $Result
%%  A DISABLE_OPERATION_CFM is received  
%%
%% $Action
%%  Send a AUDIT_REQ
%%
%% $Result
%%  A BC_AUDIT_CFM is received with parameters:
%%
%%  mainState = BC_MAIN_STATE_DISABLED
%%  
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-05-30, QMAGSED
%%    First version
%%
%%------------------------------------------------------------------------------
bci_do3() ->
	[{userdata,[{wp, "CBD_START-RESTART_BCI_OM:3:A"},
				{requirement, ""},
				{slogan, "Test disable operation in state disabled"}]}].

bci_do3(_Config) ->
	ct:pal("bci_do3"),

	{ok, session_up} = coli:subscribe_state(?SHELL_COMMAND),
	{ok, session_up} = osegw:subscribe_state(?OSE_GW_DEAMON_1),

	nci_bci_states:set_state([{state, disabled}]),

	%% Connect to BCI interface
	ok = nci_bci_actions:conn_establish([]),

	%% Disable operations
	ok = nci_bci_actions:disable_operation([]),

	%% Audit 
	ok = nci_bci_actions:audit([{expectedSigNo, ?ELIB_BC_AUDIT_CFM},
								{expectedMainState, ?ELIB_BC_MAIN_STATE_DISABLED}]),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id BCI_DO4
%%
%% $Header
%%  DP Not Loaded
%%
%% $Description
%%  Test disable operation when the LMC is not loaded
%%
%% $Requirements
%%  CBD_START-RESTART_BCI_OM:3:A
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The LMC is not loaded
%%
%% $Action
%%  Send a DISABLE_OPERATION_REQ
%%
%% $Result
%%  A DISABLE_OPERATION_CFM is received  
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-05-30, QMAGSED
%%    First version
%%
%%------------------------------------------------------------------------------
bci_do4() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_START-RESTART_BCI_OM:3:A"},
				{slogan, "Test disable operation when the LMC is not loaded"}]}].

bci_do4(_Config) ->
	ct:pal("bci_do4"),

	{ok, session_up} = coli:subscribe_state(?SHELL_COMMAND),
	{ok, session_up} = osegw:subscribe_state(?OSE_GW_DEAMON_1),

	nci_bci_states:set_state([{state, starting_lmc_not_loaded}]),

	ok = osegw:wait_for_session_up(?OSE_GW_DEAMON_1, 10*1000),

	%% Connect to BCI interface
	ok = nci_bci_actions:conn_establish([]),

	%% Disable operations
	ok = nci_bci_actions:disable_operation([]),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id BCI_DO5
%%
%% $Header
%%  State Disabled and DPNotLoaded
%%
%% $Description
%%  Test disable operation in state disable and the LMC is not loaded
%%
%% $Requirements
%%  CBD_START-RESTART_BCI_OM:3:A
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  State is disable
%%
%%  The LMC is not loaded
%%
%% $Action
%%  Send a DISABLE_OPERATION_REQ
%%
%% $Result
%%  A DISABLE_OPERATION_CFM is received  
%%
%% $Action
%%  Send a AUDIT_REQ
%%
%% $Result
%%  A AUDIT_CFM is received with parameters:
%%
%%  mainState = MAIN_STATE_DISABLED
%%  
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-05-30, QMAGSED
%%    First version
%%
%%------------------------------------------------------------------------------
bci_do5() ->
	[{userdata,[{wp, ""},
				{requirement, "CBD_START-RESTART_BCI_OM:3:A"},
				{slogan, "Test disable operation in state disable and the LMC is not loaded"}]}].

bci_do5(_Config) ->
	ct:pal("bci_do5"),

	{ok, session_up} = coli:subscribe_state(?SHELL_COMMAND),
	{ok, session_up} = osegw:subscribe_state(?OSE_GW_DEAMON_1),

	nci_bci_states:set_state([{state, starting_lmc_not_loaded}]),

	ok = osegw:wait_for_session_up(?OSE_GW_DEAMON_1, 10*1000),

	%% Connect to BCI interface
	ok = nci_bci_actions:conn_establish([]),

	%% Disable operations
	ok = nci_bci_actions:disable_operation([]),

	%% Disable operations
	ok = nci_bci_actions:disable_operation([]),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id BCI_DO6
%%
%% $Header
%%  Check FPGA not reset
%%
%% $Description
%%  Test that disable operation does not result in reset FPGA
%%
%% $Requirements
%%  CBD_START-RESTART_BCI_OM:3:A
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  State is starting
%%
%% $Action
%%  Send a BC_DISABLE_OPERATION_REQ
%%
%% $Result
%%  A DISABLE_OPERATION_CFM is received
%%   
%% $Action
%%  Send a AUDIT_REQ
%%
%% $Result
%%  A AUDIT_CFM is received with parameters:
%%
%%  mainState = MAIN_STATE_DISABLED  
%%
%% $Action
%%  Read a register in the GIC with shell command "rdfpga 0xAAA8"
%%
%% $Result
%%  The register contains "00000000"
%%  
%% $Action
%%  Write to the register in the GIC with shell command "wrfpga 0xAAA8 0xffffffff" and then read it back with shell command "rdfpga 0xAAA8"
%%
%% $Result
%%  The register contains "ffffffff" 
%%
%% $Action
%%  Write to the register in the GIC with shell command "wrfpga 0xAAA8 0x00000000" and then read it back with shell command "rdfpga 0xAAA8"
%%
%% $Result
%%  The register contains "00000000" 
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-05-30, QMAGSED
%%    First version
%%
%%------------------------------------------------------------------------------
bci_do6() ->
	[{userdata,[{wp, ""},
				{requirement, "CBD_START-RESTART_BCI_OM:3:A"},
				{slogan, "Test that disable operation does not result in reset FPGA"}]}].

bci_do6(_Config) ->
	ct:pal("bci_do6"),

	{ok, session_up} = coli:subscribe_state(?SHELL_COMMAND),
	{ok, session_up} = osegw:subscribe_state(?OSE_GW_DEAMON_1),

	%% Set starting
	nci_bci_states:set_state([{state, starting_lmc_loaded}]),

	%% Connect to BCI interface
	ok = nci_bci_actions:conn_establish([]),

	%% Disable operations
	ok = nci_bci_actions:disable_operation([]),

	%% Audit 
	ok = nci_bci_actions:audit([{expectedSigNo, ?ELIB_BC_AUDIT_CFM},
								{expectedMainState, ?ELIB_BC_MAIN_STATE_DISABLED}]),

	case nci_common_utils:get_du() of
		dul ->
			%% Read GIC & write to GIC
			nci_common_utils:coli_cmd("rdfpga 0xAAA8", "00000000"),

			nci_common_utils:coli_cmd("wrfpga 0xAAA8 0xffffffff"),
			nci_common_utils:coli_cmd("rdfpga 0xAAA8", "ffffffff"),

			nci_common_utils:coli_cmd("wrfpga 0xAAA8 0x00000000"),
			nci_common_utils:coli_cmd("rdfpga 0xAAA8", "00000000");
		_ -> ok  %mRBS and DUS41
	end,

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%##############################################################################
%% $ChapterH2 Enable Operation
%%
%% Upon enable request the DU BC shall change its current state starting to operational.
%%
%% $End
%%##############################################################################

%%------------------------------------------------------------------------------
%% $Id BCI_EO1
%%
%% $Header
%%  State Starting
%%
%% $Description
%%  Test enable operation in state starting
%%
%% $Requirements
%%  CBD_START-RESTART_BCI_OM:2:A
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state starting
%%
%% $Action
%%  Send a ENABLE_OPERATION_REQ
%%
%% $Result
%%  A ENABLE_OPERATION_CFM is received  
%%
%% $Action
%%  Send a AUDIT_REQ
%%
%% $Result
%%  A AUDIT_CFM is received with parameters:
%%
%%  mainState = MAIN_STATE_STARTING
%%  
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-05-30, QMAGSED
%%    First version
%%
%%------------------------------------------------------------------------------
bci_eo1() ->
	[{userdata,[{wp, ""}, 
	 {requirement, "CBD_START-RESTART_BCI_OM:2:A"},
	 {slogan, "Test enable operation in state starting"}]}].

bci_eo1(_Config) ->
	ct:pal("bci_eo1"),

	{ok, session_up} = coli:subscribe_state(?SHELL_COMMAND),
	{ok, session_up} = osegw:subscribe_state(?OSE_GW_DEAMON_1),

	%% Set starting
	nci_bci_states:set_state([{state, starting_lmc_loaded}]),

	%% Connect to BCI interface
	ok = nci_bci_actions:conn_establish([]),

	%% Enable operations
	ok = nci_bci_actions:enable_operation([]),

	%% Audit 
	ok = nci_bci_actions:audit([{expectedSigNo, ?ELIB_BC_AUDIT_CFM},
								{expectedMainState, ?ELIB_BC_MAIN_STATE_OPERATIONAL}]),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id BCI_EO2
%%
%% $Header
%%  State Operational
%%
%% $Description
%%  Test enable operation in state operational
%%
%% $Requirements
%%  CBD_START-RESTART_BCI_OM:2:A
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  The DU BC is in state operational
%%
%% $Action
%%  Send a ENABLE_OPERATION_REQ
%%
%% $Result
%%  A ENABLE_OPERATION_CFM is received  
%%
%% $Action
%%  Send a AUDIT_REQ
%%
%% $Result
%%  A AUDIT_CFM is received with parameters:
%%
%%  mainState = MAIN_STATE_STARTING
%%  
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-05-30, QMAGSED
%%    First version
%%
%%------------------------------------------------------------------------------
bci_eo2() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_START-RESTART_BCI_OM:2:A"},
				{slogan, "State Operational"}]}].

bci_eo2(_Config) ->
	ct:pal("bci_eo2"),

	{ok, session_up} = coli:subscribe_state(?SHELL_COMMAND),
	{ok, session_up} = osegw:subscribe_state(?OSE_GW_DEAMON_1),

	%% Set operational
	nci_bci_states:set_state([{state, operational}]),

	%% Connect to BCI interface
	ok = nci_bci_actions:conn_establish([]),

	%% Enable operations
	ok = nci_bci_actions:enable_operation([]),

	%% Audit 
	ok = nci_bci_actions:audit([{expectedSigNo, ?ELIB_BC_AUDIT_CFM},
								{expectedMainState, ?ELIB_BC_MAIN_STATE_OPERATIONAL}]),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id BCI_EO3
%%
%% $Header
%%  State Disabled
%%
%% $Description
%%  Test enable operation in state disable
%%
%% $Requirements
%%  CBD_START-RESTART_BCI_OM:2:A
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state disabled
%%
%% $Action
%%  Send a ENABLE_OPERATION_REQ
%%
%% $Result
%%  A ENABLE_OPERATION_REJ is received  with parameters:
%%
%%  errorCode = UNSUCCESSFUL
%%
%%  errorDescription = "Invalid O&M state"
%%
%% $Action
%%  Send a AUDIT_REQ
%%
%% $Result
%%  A AUDIT_CFM is received
%%
%%  mainState = MAIN_STATE_DISABLED
%%  
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-05-30, QMAGSED
%%    First version
%%
%%------------------------------------------------------------------------------
bci_eo3() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_START-RESTART_BCI_OM:2:A"},
				{slogan, "State Disabled"}]}].

bci_eo3(_Config) ->
	ct:pal("bci_eo3"),

	{ok, session_up} = coli:subscribe_state(?SHELL_COMMAND),
	{ok, session_up} = osegw:subscribe_state(?OSE_GW_DEAMON_1),

	%% Set disabled
	nci_bci_states:set_state([{state, disabled}]),

	%% Connect to BCI interface
	ok = nci_bci_actions:conn_establish([]),

	%% Enable operations
	ok = nci_bci_actions:enable_operation([{expectedSigNo, ?ELIB_BC_ENABLE_OPERATION_REJ},
											{errorCode, 1},
											{errorDescription, {regexp, "Invalid O&M state*"}}]),

	%% Audit 
	ok = nci_bci_actions:audit([{expectedSigNo, ?ELIB_BC_AUDIT_CFM},
								{expectedMainState, ?ELIB_BC_MAIN_STATE_DISABLED}]),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).  

%%------------------------------------------------------------------------------
%% $Id BCI_EO4
%%
%% $Header
%%  DP Not Loaded
%%
%% $Description
%%  Test enable operation when the LMC is not loaded
%%
%% $Requirements
%%  CBD_START-RESTART_BCI_OM:2:A
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state starting.
%%
%%  The LMC is not loaded.
%%
%% $Action
%%  Send a ENABLE_OPERATION_REQ
%%
%% $Result
%%  A ENABLE_OPERATION_REJ is received with parameters:
%%
%%  errorCode = UNSUCCESSFUL
%%
%%  errorDescription = "DP not loaded"
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-05-30, QMAGSED
%%    First version
%%
%%------------------------------------------------------------------------------
bci_eo4() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_START-RESTART_BCI_OM:2:A"},
				{slogan, "Test enable operation when the LMC is not loaded"}]}].

bci_eo4(_Config) ->
	ct:pal("bci_eo4"),

	{ok, session_up} = coli:subscribe_state(?SHELL_COMMAND),
	{ok, session_up} = osegw:subscribe_state(?OSE_GW_DEAMON_1),

	nci_bci_states:set_state([{state, starting_lmc_not_loaded}]),

	%% Connect to BCI interface
	ok = nci_bci_actions:conn_establish([]),

	%% Enable operations
	ok = nci_bci_actions:enable_operation([{expectedSigNo, ?ELIB_BC_ENABLE_OPERATION_REJ},
											{errorCode, 1},
											{errorDescription, {regexp, "DP not loaded*"}}]),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%##############################################################################
%% $ChapterH2 Get Capabilities
%%
%% Upon request from client, DU BC shall send ETHERNET-XIO connection, fan control and loading capability.
%% DUL step 3 capabilities shall consists of ETH to XIO: Values of 9 connections between GIC and the ULMAs.
%% - XIO port number. - SNID - Bandwith for the link in question. - Direction Fan control capabilities: 
%% Three values shall be provided and it is stored in the BVL on the board. - setPoint - coolingGain 
%% - timeConstant Loading capabilities: Four values shall be provided. - Loadable = according to [3] 
%% - Flash = according to [3] - FileSystemAccess = according to [3] - Blocksize = according to [3]
%%
%% $End
%%##############################################################################

%%------------------------------------------------------------------------------
%% $Id BCI_GC1
%%
%% $Header
%%  State Starting
%%
%% $Description
%%  Test get capabilities in state starting
%%
%% $Requirements
%%  CBD_DBC_BCI_FU:1:A
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state starting
%%
%% $Action
%%  Send a GET_CAPABILITIES_REQ
%%
%% $Result
%%  A GET_CAPABILITIES_CFM is received
%%
%%  With three boardCapabilityIdentity information fields:
%%
%%  CAP_LOADING_SUPPORT
%%
%%  CAP_ETH_HW_IF_SUPPORT
%%
%%  CAP_CLIMATE_CONTROL_SUPPORT
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-05-30, QMAGSED
%%    First version
%%
%%------------------------------------------------------------------------------
bci_gc1() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_DBC_BCI_FU:1:A"},
				{slogan, "State Starting"}]}].

bci_gc1(_Config) ->
	ct:pal("bci_gc1"),

	{ok, session_up} = coli:subscribe_state(?SHELL_COMMAND),
	{ok, session_up} = osegw:subscribe_state(?OSE_GW_DEAMON_1),

	nci_bci_states:set_state([{state, starting_lmc_loaded}]),

	ok = coli:wait_for_session_up(?SHELL_COMMAND, 10*1000),

	%% Connect to BCI interface
	ok = nci_bci_actions:conn_establish([]),

	timer:sleep(2*1000),

	%% Get Cap
	{ok, Received} = nci_bci_actions:get_capabilities_get([]),
	ct:pal("Received:~n~s", [osegw_lib:pretty_format(Received, nci_bci_dci)]),

	board_cap(Received#'ElibBcGetCapabilitiesCfmS'.boardCapabilities),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id BCI_GC2
%%
%% $Header
%%  State Operational
%%
%% $Description
%%  Test get capabilities in state operational.
%%
%% $Requirements
%%  CBD_DBC_BCI_FU:1:A
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  The DU BC is in state operational
%%
%% $Action
%%  Send a GET_CAPABILITIES_REQ
%%
%% $Result
%%  A GET_CAPABILITIES_CFM is received
%%
%%  With three boardCapabilityIdentity information fields:
%%
%%  CAP_LOADING_SUPPORT
%%
%%  CAP_ETH_HW_IF_SUPPORT
%%
%%  CAP_CLIMATE_CONTROL_SUPPORT
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-05-30, QMAGSED
%%    First version
%%
%%------------------------------------------------------------------------------
bci_gc2() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_DBC_BCI_FU:1:A"},
				{slogan, "Test get capabilities in state operational"}]}].

bci_gc2(_Config) ->
	ct:pal("bci_gc2"),

	{ok, session_up} = coli:subscribe_state(?SHELL_COMMAND),
	{ok, session_up} = osegw:subscribe_state(?OSE_GW_DEAMON_1),

	nci_bci_states:set_state([{state, operational}]),

	%% Connect to BCI interface
	ok = nci_bci_actions:conn_establish([]),

	%% Get Cap
	{ok, Received} = nci_bci_actions:get_capabilities_get([]),
	ct:pal("Received:~n~s", [osegw_lib:pretty_format(Received, nci_bci_dci)]),

	board_cap(Received#'ElibBcGetCapabilitiesCfmS'.boardCapabilities),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id BCI_GC3
%%
%% $Header
%%  State Disabled
%%
%% $Description
%%  Test get capabilities in state disabled
%%
%% $Requirements
%%  CBD_DBC_BCI_FU:1:A
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state disabled
%%
%% $Action
%%  Send a GET_CAPABILITIES_REQ
%%
%% $Result
%%  A GET_CAPABILITIES_CFM is received
%%
%%  With three boardCapabilityIdentity information fields:
%%
%%  CAP_LOADING_SUPPORT
%%
%%  CAP_ETH_HW_IF_SUPPORT
%%
%%  CAP_CLIMATE_CONTROL_SUPPORT
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-05-30, QMAGSED
%%    First version
%%
%%------------------------------------------------------------------------------
bci_gc3() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_DBC_BCI_FU:1:A"},
				{slogan, "State Disabled"}]}].

bci_gc3(_Config) ->
	ct:pal("bci_gc3"),

	{ok, session_up} = coli:subscribe_state(?SHELL_COMMAND),
	{ok, session_up} = osegw:subscribe_state(?OSE_GW_DEAMON_1),

	nci_bci_states:set_state([{state, disabled}]),

	%% Connect to BCI interface
	ok = nci_bci_actions:conn_establish([]),

	%% Get Cap
	{ok, Received} = nci_bci_actions:get_capabilities_get([]),
	ct:pal("Received:~n~s", [osegw_lib:pretty_format(Received, nci_bci_dci)]),

	board_cap(Received#'ElibBcGetCapabilitiesCfmS'.boardCapabilities),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%##############################################################################
%% $ChapterH2 Load LMC
%%
%%  DU BC shall load the FPGA (and sRIO) switch upon request from client. The BC client must provide wich LMC to use.
%% $End
%%##############################################################################

%%------------------------------------------------------------------------------
%% $Id BCI_LD1
%%
%% $Header
%%  BCI Load DP LMC: State Starting
%%
%% $Description
%%  To verify that LMC loading is possible in state starting, and that the 
%%  DUXI_ACC_XIO_INT process starts when the loading is complete.
%%
%% $Requirements
%%  CBD_DBC_BCI_OM:1:A
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  The DU BC is in state starting
%%  LMC is not loaded
%%
%% $Action_1
%%  On DUS41: Using the ps command, verify that the process 
%%  DUXI_ACC_XIO_INT has not started.
%%
%% $Result_1
%%  DUXI_ACC_XIO_INT has not started.
%%
%% $Action_2
%%  Send a LOAD_LMC_REQ with parameters:
%%  * loadModule = <Name of the LMC>
%%  * searchPath = <The directory it resides in on MP>
%%
%% $Result_2
%%  A LOAD_LMC_CFM is received
%%
%% $Action_3
%%  On DUS41: Using the ps command, verify that the process 
%%  DUXI_ACC_XIO_INT has started.
%%
%% $Result_3
%%  DUXI_ACC_XIO_INT has started. 
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  2012-10-31, EJONUNA
%%
%% Revision history:
%%  2012-05-30, QMAGSED
%%    First version
%%
%%  2012-10-31, EEDAJA
%%    In case of DUS, duxi is loaded
%%    Other minor changes after review
%%
%%  2013-12-10, EBACEMI
%%    Revised the test case.
%%    Updated to also verify HS11006
%%
%%  2013-12-20, EBACEMI
%%    Removed mRBS from HS11006 verification.
%%
%%------------------------------------------------------------------------------
bci_ld1() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_DBC_BCI_OM:1:A"},
				{slogan, "BCI Load DP LMC: State Starting"}]}].

bci_ld1(_Config) ->
	ct:pal("bci_ld1"),

	{ok, session_up} = coli:subscribe_state(?SHELL_COMMAND),
	{ok, session_up} = osegw:subscribe_state(?OSE_GW_DEAMON_1),

	nci_bci_states:set_state([{state, starting_lmc_not_loaded}]),

	ok = nci_bci_actions:conn_establish([]),

	LoadModule = get_lmc_name(),
	SearchPath = nci_common_cfg:get_c_loadmodules_path(),

	%% This Action verifies HS11006
	ct:pal("Action_1"),
	case nci_common_utils:get_du() of
		dus ->
			nci_common_utils:coli_cmd("ps DUXI_ACC_XIO_INT", "Invalid process");
		_ ->
			%% No ACC FPGA on DUL20 and mRBS
			ok
	end,

	ct:pal("Action_2"),
	ok = nci_bci_actions:load_lmc([{searchPath, SearchPath},
								   {loadModule, LoadModule}]),

	%% This Action verifies HS11006
	ct:pal("Action_3"),
	case nci_common_utils:get_du() of
		dus ->
			nci_common_utils:coli_cmd("ps DUXI_ACC_XIO_INT", "Total 1 process");
		_ ->
			%% No ACC FPGA on DUL20 and mRBS
			ok
	end,

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id BCI_LD2
%%
%% $Header
%%  BCI Load DP LMC: File Not Found
%%
%% $Description
%%  To check sanity in the case of the LMC file is not found
%%
%% $Requirements
%%  CBD_DBC_BCI_OM:1:A
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state starting
%%  LMC is not loaded
%%
%% $Action_1
%%  Send a LOAD_LMC_REQ with parameters:
%%  * loadModule = <A name of a nonexistent LMC>
%%  * searchPath = <A directory it could have resided in on MP>
%%
%% $Result_1
%%  A LOAD_LMC_REJ is received with parameters:
%%  * errorCode = ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL
%%  * errorDescription = "Requested LMC not found or DB busy loading"
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  2012-10-31, EJONUNA
%%
%% Revision history:
%%  2012-05-30, QMAGSED
%%    First version
%%
%%  2012-10-31, EEDAJA
%%    In case of DUS, duxi is loaded
%%    Other minor changes after review
%%
%%  2013-12-10, ebacemi
%%    Revised the test case
%%
%%------------------------------------------------------------------------------
bci_ld2() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_DBC_BCI_OM:1:A"},
				{slogan, "BCI Load DP LMC: File Not Found"}]}].

bci_ld2(_Config) ->
	ct:pal("bci_ld2"),

	{ok, session_up} = coli:subscribe_state(?SHELL_COMMAND),
	{ok, session_up} = osegw:subscribe_state(?OSE_GW_DEAMON_1),

	nci_bci_states:set_state([{state, starting_lmc_not_loaded}]),

	ok = nci_bci_actions:conn_establish([]),

	LoadModule = "will_not_work",
	SearchPath = nci_common_cfg:get_c_loadmodules_path(),

	ct:pal("Action_1"),
	ok = nci_bci_actions:load_lmc([ {searchPath, SearchPath},
									{loadModule, LoadModule},
									{expectedSigNo, ?ELIB_BC_LOAD_LMC_REJ},
									{errorCode, ?ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL},
									{errorDescription, {regexp, "Requested LMC not found or DB busy loading*"}}]),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id BCI_LD3
%%
%% $Header
%%  BCI Load DP LMC: Wrong Path
%%
%% $Description
%%  Test LMC loading when path is faulty
%%
%% $Requirements
%%  CBD_DBC_BCI_OM:1:A
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state starting
%%  LMC is not loaded
%%
%% $Action_1
%%  Send a LOAD_LMC_REQ with parameters:
%%  * loadModule = <Name of the LMC>
%%  * searchPath = <A non existent directory>
%%
%% $Result_1
%%  A LOAD_LMC_REJ is received with parameters:
%%  * errorCode = ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL
%%  * errorDescription = "Requested LMC not found or DB busy loading"
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-05-30, QMAGSED
%%    First version
%%
%%  2012-10-31, EEDAJA
%%    In case of DUS, duxi is loaded
%%
%%  2013-12-10, ebacemi
%%    Revised the test case
%%
%%------------------------------------------------------------------------------
bci_ld3() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_DBC_BCI_OM:1:A"},
				{slogan, "BCI Load DP LMC: Wrong Path"}]}].

bci_ld3(_Config) ->
	ct:pal("bci_ld3"),

	{ok, session_up} = coli:subscribe_state(?SHELL_COMMAND),
	{ok, session_up} = osegw:subscribe_state(?OSE_GW_DEAMON_1),

	nci_bci_states:set_state([{state, starting_lmc_not_loaded}]),

	ok = nci_bci_actions:conn_establish([]),

	LoadModule = get_lmc_name(),
	SearchPath = "/c/will/not/work",

	ct:pal("Action_1"),
	ok = nci_bci_actions:load_lmc([ {searchPath, SearchPath},
									{loadModule, LoadModule},
									{expectedSigNo, ?ELIB_BC_LOAD_LMC_REJ},
									{errorCode, ?ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL},
									{errorDescription, {regexp, "Requested LMC not found or DB busy loading*"}}]),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id BCI_LD4
%%
%% $Header
%%  BCI Load DP LMC: Corrupt LMC
%%
%% $Description
%%  To verify LMC loading with a corrupt LMC
%%
%% $Requirements
%%  CBD_DBC_BCI_OM:1:A
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state starting
%%  LMC is not loaded
%%
%% $Action
%%  Send a LOAD_LMC_REQ with parameters:
%%  * loadModule = Corrupt LM (use BPP LM).
%%  * searchPath = <The directory it resides in on MP>
%%
%% $Result
%%  A LOAD_LMC_REJ is received with parameters:
%%  * errorCode = ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL
%%  * errorDescription = "Board is NOT loadable"
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-05-30, QMAGSED
%%    First version
%%  2013-02-06, ejonuna
%%    Removed the allowed ERROR message in the te e log since it isn't allowed
%%  2013-02-28, ejonuna
%%    Removed dependecy to jct.config file
%%  2013-12-10, ebacemi
%%    Revised the test case
%%
%%------------------------------------------------------------------------------
bci_ld4() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_DBC_BCI_OM:1:A"},
				{slogan, "BCI Load DP LMC: Corrupt LMC"}]}].

bci_ld4(_Config) ->
	ct:pal("bci_ld4"),

	{ok, session_up} = coli:subscribe_state(?SHELL_COMMAND),
	{ok, session_up} = osegw:subscribe_state(?OSE_GW_DEAMON_1),

	nci_bci_states:set_state([{state, starting_lmc_not_loaded}]),

	ok = nci_bci_actions:conn_establish([]),

	LoadModule = nci_common_utils:get_board_bcp_name(),
	SearchPath = nci_common_cfg:get_c_loadmodules_path(),

	ct:pal("Action_1"),
	ok = nci_bci_actions:load_lmc([{searchPath, SearchPath},
								   {loadModule, LoadModule},
								   {expectedSigNo, ?ELIB_BC_LOAD_LMC_REJ},
								   {errorCode, ?ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL},
								   {errorDescription, {regexp, "Board is NOT loadable*"}}]),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id BCI_LD5
%%
%% $Header
%%  BCI Load DP LMC: Already Loaded
%%
%% $Description
%%  To verify LMC loading when already loaded (same CXP102066 is used)
%%
%% $Requirements
%%  CBD_DBC_BCI_OM:1:A
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state starting
%%  LMC is not loaded
%%
%% $Action_1
%%  Send a LOAD_LMC_REQ with parameters:
%%  * loadModule = <Name of the LMC>
%%  * searchPath = <The directory it resides in on MP>
%%
%% $Result_1
%%  A LOAD_LMC_CFM is received
%%
%% $Action_2
%%  Send a LOAD_LMC_REQ with parameters:
%%  * loadModule = <Name of the LMC>
%%  * searchPath = <The directory it resides in on MP>
%%
%% $Result_2
%%  A LOAD_LMC_REJ is received with parameters:
%%  * errorCode = ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL
%%  * errorDescription = "DP already loaded and running"
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-05-30, QMAGSED
%%    First version
%%
%%  2012-10-31, EEDAJA
%%    In case of DUS, duxi is loaded
%%
%%  2013-12-10, ebacemi
%%    Revised the test case
%%
%%------------------------------------------------------------------------------
bci_ld5() ->[{userdata,[{wp, ""}, 
				{requirement, "CBD_DBC_BCI_OM:1:A"},
				{slogan, "BCI Load DP LMC: Already Loaded"}]}].

bci_ld5(_Config) ->
	ct:pal("bci_ld5"),

	{ok, session_up} = coli:subscribe_state(?SHELL_COMMAND),
	{ok, session_up} = osegw:subscribe_state(?OSE_GW_DEAMON_1),

	nci_bci_states:set_state([{state, starting_lmc_not_loaded}]),

	ok = nci_bci_actions:conn_establish([]),

	LoadModule = get_lmc_name(),
	SearchPath = nci_common_cfg:get_c_loadmodules_path(),

	ct:pal("Action_1"),
	ok = nci_bci_actions:load_lmc([{searchPath, SearchPath},
								   {loadModule, LoadModule}]),

	ct:pal("Action_2"),
	ok = nci_bci_actions:load_lmc([{searchPath, SearchPath},
								   {loadModule, LoadModule},
								   {expectedSigNo, ?ELIB_BC_LOAD_LMC_REJ},
								   {errorCode, ?ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL},
								   {errorDescription, {regexp, "DP already loaded and running*"}}]),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id BCI_LD8
%%
%% $Header
%%  BCI Load DP LMC: State Disabled
%%
%% $Description
%%  Shall NOT be possible to load LMC, State Disabled
%%
%% $Requirements
%%  CBD_DBC_BCI_OM:1:A
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state disabled
%%  LMC is not loaded
%%
%% $Action_1
%%  Send a LOAD_LMC_REQ with parameters:
%%  * loadModule = <Name of the LMC>
%%  * searchPath = <The directory it resides in on MP>
%%
%% $Result_1
%%  A LOAD_LMC_REJ is received with parameters:
%%  * errorCode = ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL
%%  * errorDescription = "Invalid O&M state"
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  2013-01-16, ejonuna
%%
%% Revision history:
%%  2012-05-30, QMAGSED
%%    First version
%%
%%  2012-10-31, EEDAJA
%%    In case of DUS, duxi is loaded
%%  2013-01-16, ejonuna
%%    Updated header searchPath = after review
%%  2013-01-16, ejonuna
%%    Updated after review
%%  2013-01-17, ejonuna
%%    Updated after review
%%  2013-12-10, ebacemi
%%    Revised the test case
%%------------------------------------------------------------------------------
bci_ld8() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_DBC_BCI_OM:1:A"},
				{slogan, "BCI Load DP LMC: State disabled"}]}].

bci_ld8(_Config) ->
	ct:pal("bci_ld8"),

	{ok, session_up} = coli:subscribe_state(?SHELL_COMMAND),
	{ok, session_up} = osegw:subscribe_state(?OSE_GW_DEAMON_1),

	nci_bci_states:set_state([{state, starting_lmc_not_loaded}]),

	ok = nci_bci_actions:conn_establish([]),

	ok = nci_bci_actions:disable_operation([]),

	LoadModule = get_lmc_name(),
	SearchPath = nci_common_cfg:get_c_loadmodules_path(),

	%% Load LMC
	ct:pal("Action_1"),
	ok = nci_bci_actions:load_lmc([{searchPath, SearchPath},
								   {loadModule, LoadModule},
								   {expectedSigNo, ?ELIB_BC_LOAD_LMC_REJ},
								   {errorCode, ?ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL},
								   {errorDescription, {regexp, "Invalid O&M state*"}}]),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000). 

%%##############################################################################
%% $ChapterH2 Restart Board
%%
%% DU BC shall restart the board upon request
%%
%% $End
%%##############################################################################

%%------------------------------------------------------------------------------
%% $Id BCI_RB1
%%
%% $Header
%%  State Starting
%%
%% $Description
%%  Verify restart board in state starting
%%
%% $Requirements
%%  CBD_START-RESTART_BCI_OM:2:A
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state starting
%%
%%  We supervise the target process using the OSE attach functionality, so that the attach signals are not consumed by our test clients
%%
%% $Action
%%  Send a RESTART_BOARD_FWD with parameters: traceInformation = "Test case BCI_RB1"
%%
%% $Result
%%  An attach signal is received or the node is restarted. A node restart is valid result according to 
%%  IWD BPAI, 1/55 19-CEH 101 69/1 Chapter 18
%%
%% $Result
%%  The trace log contains a trace with the specified information
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  2012-10-15, EJOJUNA
%%
%% Revision history:
%%  2012-05-30, QMAGSED
%%    First version
%%
%%  2012-10-16, EEDAJA
%%    Minor changes after review comments
%%
%%  2012-11-15, EJONUNA
%%    Now also handles the valid result of a node restart as a result of RESTART_BOARD_FWD
%%  2013-01-21, ejonuna
%%    Added enabling and disabling of trace1 NCI_COMMON to make trace detection work
%%
%%
%%------------------------------------------------------------------------------
bci_rb1() ->
	[{userdata,[{wp, ""}, {requirement, "CBD_START-RESTART_BCI_OM:2:A"},{slogan, "Verify restart board in state starting"}]}].

bci_rb1(_Config) ->
	bci_rb("bci_rb1", starting).

bci_rb(Name, State) ->
	ct:pal(Name),

	nci_bci_states:set_state([{state, State}]),

	%% Connect to BCI interface
	ok = nci_bci_actions:conn_establish([]),

	%% Audit
	case State of
		starting ->
			ok = nci_bci_actions:audit([{expectedSigNo, ?ELIB_BC_AUDIT_CFM},
										{expectedMainState, ?ELIB_BC_MAIN_STATE_STARTING}]);
		starting_lmc_loaded ->
			ok = nci_bci_actions:audit([{expectedSigNo, ?ELIB_BC_AUDIT_CFM},
										{expectedMainState, ?ELIB_BC_MAIN_STATE_STARTING}]);
		operational ->
			ok = nci_bci_actions:audit([{expectedSigNo, ?ELIB_BC_AUDIT_CFM},
										{expectedMainState, ?ELIB_BC_MAIN_STATE_OPERATIONAL}]);
		disabled ->
			ok = nci_bci_actions:audit([{expectedSigNo, ?ELIB_BC_AUDIT_CFM},
										{expectedMainState, ?ELIB_BC_MAIN_STATE_DISABLED}])
	end,

	ok = osegw:create(#osegw{name = ?OSE_GW_DEAMON_2, 
							iap = osegw,
							opt = [ {ping_timeout, 6000}, 
									{codec_config, 
									{?SIG_MODS, 
									sizeof,
									osegw_ose,big}}]}),

	{ok, Pid} = osegw:hunt(?OSE_GW_DEAMON_2, ?BC_SERVER),
	{ok, _Attref} = osegw:attach(?OSE_GW_DEAMON_2, Pid),

	%% Restart Board
	coli:cmd(?SHELL_COMMAND, "te e trace1 RICM_CONTROL"),
	coli:cmd(?SHELL_COMMAND, "te save RICM_CONTROL"),
	LogString = string:concat("Test case ", string:to_upper(Name)),
	ok = nci_bci_actions:restartboard_fwd([{traceInformation, LogString}]),

	Result = osegw:recv(?OSE_GW_DEAMON_2, [], 60000),

	case Result of	
		{ok, {Pid, ?OSEGW_OS_ATTACH_SIG, <<>>}} -> 
			ok;
		{error,session_down} ->
			CPPTelnet = cpp_server:get_value(?CPP_NAME, coli),
			ok = cpp_lib:poll_load_start(CPPTelnet,120*1000),
			ok = coli:wait_for_session_up(?SHELL_COMMAND, 60*1000),
			ok = osegw:wait_for_session_up(?OSE_GW_DEAMON_1, 60*1000),
			ok = osegw:wait_for_session_up(?OSE_GW_DEAMON_2, 60*1000)
	end,

	ok = osegw:delete(?OSE_GW_DEAMON_2),

	%% Find string in TE log
	FindString = string:join([".*", LogString, ".*"], ""),
	nci_common_utils:find_string_in_te_log(?SHELL_COMMAND, FindString),

	coli:cmd(?SHELL_COMMAND, "te d trace1 RICM_CONTROL"),
	coli:cmd(?SHELL_COMMAND, "te save RICM_CONTROL"),

	nci_bci_states:restart_board(LogString),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id BCI_RB2
%%
%% $Header
%%  State Operational
%%
%% $Description
%%  Verify restart board in state operational
%%
%% $Requirements
%%  CBD_START-RESTART_BCI_OM:1:A
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  The DU BC is in state operational
%%
%%  We supervise the target process using the OSE attach functionality, so that the attach signals are not consumed by our test clients
%%
%% $Action
%%  Send a RESTART_BOARD_FWD with parameters:
%%
%%  traceInformation = "Test case BCI_RB2"
%%
%% $Result
%%  An attach signal is received or the node is restarted. A node restart is valid result according to 
%%  IWD BPAI, 1/55 19-CEH 101 69/1 Chapter 18
%%
%% $Result
%%  The trace log contains a trace with the specified information
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-05-30, QMAGSED
%%    First version
%%
%%------------------------------------------------------------------------------
bci_rb2() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_START-RESTART_BCI_OM:1:A"},
				{slogan, "State Operational"}]}].

bci_rb2(_Config) ->
	bci_rb("bci_rb2", operational).

%%------------------------------------------------------------------------------
%% $Id BCI_RB3
%%
%% $Header
%%  State Disabled
%%
%% $Description
%%  Verify restart board in state disabled
%%
%% $Requirements
%%  CBD_START-RESTART_BCI_OM:1:A
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state disabled
%%
%%  We supervise the target process using the OSE attach functionality, so that the attach signals are not consumed by our test clients
%%
%% $Action
%%  Send a RESTART_BOARD_FWD with parameters:
%%
%%  traceInformation = "Test case BCI_RB3"
%%
%% $Result
%%  An attach signal is received or the node is restarted. A node restart is valid result according to 
%%  IWD BPAI, 1/55 19-CEH 101 69/1 Chapter 18
%%
%% $Result
%%  The trace log contains a trace with the specified information
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-05-30, QMAGSED
%%    First version
%%
%%------------------------------------------------------------------------------
bci_rb3() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_START-RESTART_BCI_OM:1:A"},
				{slogan, "State Disabled"}]}].

bci_rb3(_Config) ->
	bci_rb("bci_rb3", disabled).

%%##############################################################################
%% $ChapterH2 Subscribe Faults
%%
%% DU BC shall allow a BC client to subscribe on fault indications.
%%
%% $End
%%##############################################################################

%%------------------------------------------------------------------------------
%% $Id BCI_SF1
%%
%% $Header
%%  State Starting
%%
%% $Description
%%  Verify subscribe faults in state starting
%%
%% $Requirements
%%  CBD_FAULT_BCI_FU:1:A
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state starting
%%
%% $Action_1
%%  Send a SUBSCRIBE_FAULTS_REQ
%%
%% $Result_1
%%  A SUBSCRIBE_FAULTS_CFM is received
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-05-30, QMAGSED
%%    First version
%%
%%------------------------------------------------------------------------------
bci_sf1() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_FAULT_BCI_FU:1:A"},
				{slogan, "State Starting"}]}].

bci_sf1(_Config) ->
	ct:pal("bci_sf1"),

	{ok, session_up} = coli:subscribe_state(?SHELL_COMMAND),
	{ok, session_up} = osegw:subscribe_state(?OSE_GW_DEAMON_1),

	nci_bci_states:set_state([{state, starting_lmc_loaded}]),

	%% Connect to BCI interface
	ok = nci_bci_actions:conn_establish([]),

	%% Subscribe Faults
	ct:pal("Action_1"),
	ok = nci_bci_actions:subscribe_faults([]),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id BCI_SF2
%%
%% $Header
%%  State Operational
%%
%% $Description
%%  Verify subscribe faults in state operational
%%
%% $Requirements
%%  CBD_FAULT_BCI_FU:1:A
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state operational
%%
%% $Action_1
%%  Send a SUBSCRIBE_FAULTS_REQ
%%
%% $Result_1
%%  A SUBSCRIBE_FAULTS_CFM is received
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-05-30, QMAGSED
%%    First version
%%
%%------------------------------------------------------------------------------
bci_sf2() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_FAULT_BCI_FU:1:A"},
				{slogan, "State Operational"}]}].

bci_sf2(_Config) ->
	ct:pal("bci_sf2"),

	{ok, session_up} = coli:subscribe_state(?SHELL_COMMAND),
	{ok, session_up} = osegw:subscribe_state(?OSE_GW_DEAMON_1),

	nci_bci_states:set_state([{state, operational}]),

	%% Subscribe Faults
	ct:pal("Action_1"),
	ok = nci_bci_actions:subscribe_faults([]),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id BCI_SF3
%%
%% $Header
%%  State Disabled
%%
%% $Description
%%  Verify subscribe faults in state disabled
%%
%% $Requirements
%%  CBD_FAULT_BCI_FU:1:A
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  The DU BC is in state disabled
%%
%% $Action_1
%%  Send a SUBSCRIBE_FAULTS_REQ
%%
%% $Result_1
%%  A SUBSCRIBE_FAULTS_CFM is received
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-05-30, QMAGSED
%%    First version
%%
%%------------------------------------------------------------------------------
bci_sf3() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_FAULT_BCI_FU:1:A"},
				{slogan, "State Disabled"}]}].

bci_sf3(_Config) ->
	ct:pal("bci_sf3"),

	{ok, session_up} = coli:subscribe_state(?SHELL_COMMAND),
	{ok, session_up} = osegw:subscribe_state(?OSE_GW_DEAMON_1),

	nci_bci_states:set_state([{state, disabled}]),

	%% Connect to BCI interface
	ok = nci_bci_actions:conn_establish([]),

	%% Subscribe Faults
	ct:pal("Action_1"),
	ok = nci_bci_actions:subscribe_faults([]),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id BCI_SF4
%%
%% $Header
%%  Max No Of Clients
%%
%% $Description
%%  To verify that a maximum of 6 clients can be subscribing simultaneously
%%
%% $Requirements
%%  CBD_FAULT_BCI_FU:1:A
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  One client has performed a connection establish procedure since last restart
%%
%%  No subscribe faults procedure has been performed
%%
%% $Action_1
%%  6 clients sends a SUBSCRIBE_FAULTS_REQ each
%%
%% $Result_1
%%  6 clients receives a SUBSCRIBE_FAULTS_CFM each
%%
%% $Action_2
%%  Seventh client sends a SUBSCRIBE_FAULTS_REQ
%%
%% $Result_2
%%  Seventh client receives a SUBSCRIBE_FAULTS_REJ with parameters:
%%
%%  errorCode = UNSUCCESSFUL
%%
%%  errorDescription = "Too many subscribing clients already active"
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-05-30, QMAGSED
%%    First version
%%
%%------------------------------------------------------------------------------
bci_sf4() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_FAULT_BCI_FU:1:A"},
				{slogan, "Max No Of Clients"}]}].

bci_sf4(_Config) ->
	ct:pal("bci_sf4"),

	{ok, session_up} = coli:subscribe_state(?SHELL_COMMAND),
	{ok, session_up} = osegw:subscribe_state(?OSE_GW_DEAMON_1),

	%% Restart Board
	ok = nci_bci_actions:conn_establish([]),
	LogString = string:concat("Test case ", string:to_upper("bci_sf4")),
	nci_bci_states:restart_board( LogString ),

	%% Create 6 more GWs
	ok = osegw:create(#osegw{name = ?OSE_GW_DEAMON_2, 
				 iap = osegw, 
				 opt = [{ping_timeout, 6000}, 
					{codec_config, 
					{?SIG_MODS, 
					 sizeof, 
						 osegw_ose,big}}]}),
	ok = osegw:create(#osegw{name = ?OSE_GW_DEAMON_3, 
				 iap = osegw, 
				 opt = [{ping_timeout, 6000}, 
					{codec_config, 
					{?SIG_MODS, 
					 sizeof, 
						 osegw_ose,big}}]}),
	ok = osegw:create(#osegw{name = ?OSE_GW_DEAMON_4, 
				 iap = osegw, 
				 opt = [{ping_timeout, 6000}, 
					{codec_config, 
					{?SIG_MODS, 
					 sizeof, 
						 osegw_ose,big}}]}),
	ok = osegw:create(#osegw{name = ?OSE_GW_DEAMON_5, 
				 iap = osegw, 
				 opt = [{ping_timeout, 6000}, 
					{codec_config, 
					{?SIG_MODS, 
					 sizeof, 
						 osegw_ose,big}}]}),
	ok = osegw:create(#osegw{name = ?OSE_GW_DEAMON_6, 
				 iap = osegw, 
				 opt = [{ping_timeout, 6000}, 
					{codec_config, 
					{?SIG_MODS, 
					 sizeof, 
						 osegw_ose,big}}]}),
	ok = osegw:create(#osegw{name = ?OSE_GW_DEAMON_7, 
				 iap = osegw, 
				 opt = [{ping_timeout, 6000}, 
					{codec_config, 
					{?SIG_MODS, 
					 sizeof, 
						 osegw_ose,big}}]}),

	%% First Client Connect to BCI interface
	ok = nci_bci_actions:conn_establish([{oseGwDeamon,?OSE_GW_DEAMON_1},
				 		 {expectedSigNo, ?ELIB_BC_CONN_ESTABLISH_CFM}]),
	%% Subscribe Faults
	ct:pal("Action_1"),
	ok = nci_bci_actions:subscribe_faults([{oseGwDeamon,?OSE_GW_DEAMON_1}]),
	ok = nci_bci_actions:subscribe_faults([{oseGwDeamon,?OSE_GW_DEAMON_2}]),
	ok = nci_bci_actions:subscribe_faults([{oseGwDeamon,?OSE_GW_DEAMON_3}]),
	ok = nci_bci_actions:subscribe_faults([{oseGwDeamon,?OSE_GW_DEAMON_4}]),
	ok = nci_bci_actions:subscribe_faults([{oseGwDeamon,?OSE_GW_DEAMON_5}]),
	ok = nci_bci_actions:subscribe_faults([{oseGwDeamon,?OSE_GW_DEAMON_6}]),

	%% Subscribe Faults should fail
	ct:pal("Action_2"),
	ok = nci_bci_actions:subscribe_faults([{oseGwDeamon,?OSE_GW_DEAMON_7},
						   {expectedSigNo, ?ELIB_BC_SUBSCRIBE_FAULTS_REJ},
						   {errorCode, 1},
						   {errorDescription, {regexp, "Too many subscribing clients already active*"}}]),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(?OSE_GW_DEAMON_1, 2000),
	nci_common_utils:check_outstanding_faults(?OSE_GW_DEAMON_2, 200),
	nci_common_utils:check_outstanding_faults(?OSE_GW_DEAMON_3, 200),
	nci_common_utils:check_outstanding_faults(?OSE_GW_DEAMON_4, 200),
	nci_common_utils:check_outstanding_faults(?OSE_GW_DEAMON_5, 200),
	nci_common_utils:check_outstanding_faults(?OSE_GW_DEAMON_6, 200),
	nci_common_utils:check_outstanding_faults(?OSE_GW_DEAMON_7, 2000),

	%% Delete created OSE GWs
	ok = osegw:delete(?OSE_GW_DEAMON_2),
	ok = osegw:delete(?OSE_GW_DEAMON_3),
	ok = osegw:delete(?OSE_GW_DEAMON_4),
	ok = osegw:delete(?OSE_GW_DEAMON_5),
	ok = osegw:delete(?OSE_GW_DEAMON_6),
	ok = osegw:delete(?OSE_GW_DEAMON_7).

%%##############################################################################
%% $ChapterH2 Visual Indication Handling
%%
%% DU BC shall be able to change LED state upon BC client request.
%%
%% $End
%%##############################################################################

%%------------------------------------------------------------------------------
%% $Id BCI_SVI1
%%
%% $Header
%%  State Starting
%%
%% $Description
%%  Verify that used VII states behave according to [1] and [2] in some normal cases
%%
%% $Requirements
%%  CBD_DBC_VII_FU:1:A
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  DUL has product number KDU 137 533/4
%%
%%  DU BC is in state starting
%%
%% $Action_1
%%  Send a BC_SET_VISUAL_INDICATION_REQ with parameters:
%%
%%  visualizedState = BC_VISUAL_STATE_RESET 
%%
%% $Result_1
%%  A BC_SET_VISUAL_INDICATION_CFM is received.
%%
%% $Action_2
%%  Check the vii state
%%
%% $Result_2
%%  The vii state indicates:
%%
%%  no visual indication
%%
%% $Action_3
%%  Send a BC_SET_VISUAL_INDICATION_REQ with parameters:
%%
%%  visualizedState= BC_VISUAL_STATE_MISSING_RESOURCE
%%
%% $Result_3
%%  A BC_SET_VISUAL_INDICATION_CFM is received
%%
%% $Action_4
%%  Check the vii state
%%
%% $Result_4
%%  The vii state indicates:
%%
%%  missing_resource = "yes"
%%
%% $Action_5
%%  Send a BC_SET_VISUAL_INDICATION_REQ with parameters:
%%
%%  visualizedState= BC_VISUAL_STATE_LOAD_TEST_IN_PROGRESS
%%
%% $Result_5
%%  A BC_SET_VISUAL_INDICATION_CFM is received
%%
%% $Action_6
%%  Check the vii state
%%
%% $Result_6
%%  The vii state indicates:
%%
%%  missing_resource = "yes"
%%
%%  load_start = "yes"
%%
%% $Action_7
%%  Send a BC_SET_VISUAL_INDICATION_REQ with parameters:
%%
%%  visualizedState= BC_VISUAL_STATE_MISSING_RESOURCE_END
%%
%% $Result_7
%%  A BC_SET_VISUAL_INDICATION_CFM is received
%%
%% $Action_8
%%  Check the vii state
%%
%% $Result_8
%%  The vii state indicates:
%%
%%  load_start = "yes"
%%
%% $Action_9
%%  Send a BC_SET_VISUAL_INDICATION_REQ with parameters:
%%
%%  visualizedState= BC_VISUAL_STATE_LOAD_TEST_IN_PROGRESS_END
%%
%% $Result_9
%%  A BC_SET_VISUAL_INDICATION_CFM is received
%%
%% $Action_10
%%  Check the vii state
%%
%% $Result_10
%%  The vii state indicates:
%%
%%  no visual indication
%%
%% $Action_11
%%  Send a BC_SET_VISUAL_INDICATION_REQ with parameters:
%%
%%  visualizedState = BC_VISUAL_STATE_BOARD_LOCKED
%%
%% $Result_11
%%  A BC_SET_VISUAL_INDICATION_CFM is received
%%
%% $Action_12
%%  Check the vii state
%%
%% $Result_12
%%  The vii state indicates:
%%
%%  board_locked = "yes"
%%
%% $Action_13
%%  Send a BC_SET_VISUAL_INDICATION_REQ with parameters: 
%%
%%  visualizedState= BC_VISUAL_STATE_BOARD_UNLOCKED
%%
%% $Result_13
%%  A BC_SET_VISUAL_INDICATION_CFM is received
%%
%% $Action_14
%%  Check the vii state
%%
%% $Result_14
%%  The vii state indicates:
%%
%%  no visual indication
%%
%% $Action_15
%%  Send a BC_SET_VISUAL_INDICATION_REQ with parameters:
%%
%%  visualizedState = BC_VISUAL_STATE_FAULT
%%
%% $Result_15
%%  A BC_SET_VISUAL_INDICATION_CFM is received
%%
%% $Action_16
%%  Check the vii state
%%
%% $Result_16
%%  The vii state indicates:
%%
%%  fault = "yes"
%%
%% $Action_17
%%  Send a BC_SET_VISUAL_INDICATION_REQ with parameters:
%%
%%  visualizedState = BC_VISUAL_STATE_NO_FAULT
%%
%% $Result_17
%%  A BC_SET_VISUAL_INDICATION_CFM is received
%%
%% $Action_18
%%  Check the vii state
%%
%% $Result_18
%%  The vii state indicates:
%%
%%  no visual indication
%%
%% $Action_19
%%  Send a BC_SET_VISUAL_INDICATION_REQ with parameters:
%%
%%  visualizedState = BC_VISUAL_STATE_SHUTDOWN
%%
%% $Result_19
%%  A BC_SET_VISUAL_INDICATION_CFM is received
%%
%% $Action_20
%%  Check the vii state
%%
%% $Result_20
%%  The vii state indicates:
%%
%%  shutdown = "yes"
%%
%% $Action_21
%%  Send a BC_SET_VISUAL_INDICATION_REQ with parameters:
%%
%%  visualizedState = BC_VISUAL_STATE_BOARD_BUSY
%%
%% $Result_21
%%  A BC_SET_VISUAL_INDICATION_CFM is received
%%
%% $Action_22
%%  Check the vii state
%%
%% $Result_22
%%  The vii state indicates:
%%
%%  shutdown = "yes"
%%
%% $Action_23
%%  Send a BC_SET_VISUAL_INDICATION_REQ with parameters:
%%
%%  visualizedState= BC_VISUAL_STATE_SHUTDOWN_END
%%
%% $Result_23
%%  A BC_SET_VISUAL_INDICATION_CFM is received
%%
%% $Action_24
%%  Check the vii state
%%
%% $Result_24
%%  The vii state indicates:
%%
%%  board_busy = "yes"
%%
%% $Action_25
%%  Send a BC_SET_VISUAL_INDICATION_REQ with parameters:
%%
%%  visualizedState = BC_VISUAL_STATE_RESET
%%
%% $Result_25
%%  A BC_SET_VISUAL_INDICATION_CFM is received
%%
%% $Action_26
%%  Check the vii state
%%
%% $Result_26
%%  The vii state indicates:
%%
%%  no visual indication
%%
%% $Action_27
%%  Send a BC_SET_VISUAL_INDICATION_REQ with parameters:
%%
%%  visualizedState = BC_VISUAL_STATE_NO_POWER
%%
%% $Result_27
%%  A BC_SET_VISUAL_INDICATION_CFM is received
%%
%% $Action_28
%%  Check the vii state
%%
%% $Result_28
%%  The vii state indicates:
%%
%%  no_power = "yes"
%%
%% $Action_29
%%  Send a BC_SET_VISUAL_INDICATION_REQ with parameters:
%%
%%  visualizedState= BC_VISUAL_STATE_POWER_PRESENT
%%
%% $Result_29
%%  A BC_SET_VISUAL_INDICATION_CFM is received
%%
%% $Action_30
%%  Check the vii state
%%
%% $Result_30
%%  The vii state indicates:
%%
%%  no visual indication
%%
%% $Action_31
%%  Send a BC_SET_VISUAL_INDICATION_REQ with parameters:
%%
%%  visualizedState= BC_VISUAL_STATE_BOOT_TEST_IN_PROGRESS
%%
%% $Result_31
%%  A BC_SET_VISUAL_INDICATION_CFM is received
%%
%% $Action_32
%%  Check the vii state
%%
%% $Result_32
%%  The vii state indicates:
%%
%%  boottest = "yes"
%%
%% $Action_33
%%  Send a BC_SET_VISUAL_INDICATION_REQ with parameters:
%%
%%  visualizedState= BC_VISUAL_STATE_BOOT_TEST_IN_PROGRESS_END
%%
%% $Result_33
%%  A BC_SET_VISUAL_INDICATION_CFM is received
%%
%% $Action_34
%%  Check the vii state
%%
%% $Result_34
%%  The vii state indicates:
%%
%%  no visual indication
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-05-30, QMAGSED
%%    First version
%%
%%  2012-10-31, EEDAJA
%%    Modified according to testing results
%%
%%  2014-01-30, EISMELE
%%    Added support for DUS31_02 board
%%
%%------------------------------------------------------------------------------
bci_svi1() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_DBC_VII_FU:1:A"},
				{slogan, "State Starting"}]}].

bci_svi1(_Config) ->
	bci_svi("bci_svi1", starting_lmc_loaded ).

bci_svi( Name, State ) ->
	ct:pal( Name ),

	{ok, session_up} = coli:subscribe_state(?SHELL_COMMAND),
	{ok, session_up} = osegw:subscribe_state(?OSE_GW_DEAMON_1),

	nci_bci_states:set_state([{state, State}]),

	case nci_common_cfg:get_board_prodnr(?SHELL_COMMAND) of
		"KDU 137 533/4" ->
			IsBackup = true;
		"KDU 137 533/3" ->
			IsBackup = false;
		 _Default ->
			IsBackup = true
	end,

	%% Connect to BCI interface
	ok = nci_bci_actions:conn_establish([]),

	ct:pal("Action_1,2"),	
	%% VII ELIB_BC_VISUAL_STATE_RESET
	ok = nci_bci_actions:set_vii([{expectedSigNo, ?ELIB_BC_SET_VISUAL_INDICATION_CFM},
							{visualizedState, ?ELIB_BC_VISUAL_STATE_RESET}]),
	ok = nci_bci_actions:check_vii_board_state([{viiInfo, false}]),

	ct:pal("Action_3,4"),	
	%% VII ELIB_BC_VISUAL_STATE_MISSING_RESOURCE
	ok = nci_bci_actions:set_vii([{expectedSigNo, ?ELIB_BC_SET_VISUAL_INDICATION_CFM},
							{visualizedState, ?ELIB_BC_VISUAL_STATE_MISSING_RESOURCE}]),
	ok = nci_bci_actions:check_vii_board_state([{viiInfo, true},
							{isBackup, IsBackup},
							{missingResource, "YES"}]),

	ct:pal("Action_5,6"),	
	%% VII ELIB_BC_VISUAL_STATE_LOAD_TEST_IN_PROGRESS
	ok = nci_bci_actions:set_vii([{expectedSigNo, ?ELIB_BC_SET_VISUAL_INDICATION_CFM},
							{visualizedState, ?ELIB_BC_VISUAL_STATE_LOAD_TEST_IN_PROGRESS}]),
	ok = nci_bci_actions:check_vii_board_state([{viiInfo, true},
							{isBackup, IsBackup},
							{missingResource, "YES"},
							{loadStart, "YES"}]),

	ct:pal("Action_7,8"),	
	%% VII ELIB_BC_VISUAL_STATE_MISSING_RESOURCE_END
	ok = nci_bci_actions:set_vii([{expectedSigNo, ?ELIB_BC_SET_VISUAL_INDICATION_CFM},
							{visualizedState, ?ELIB_BC_VISUAL_STATE_MISSING_RESOURCE_END}]),
	ok = nci_bci_actions:check_vii_board_state([{viiInfo, true},
							{isBackup, IsBackup},
							{loadStart, "YES"}]),

	ct:pal("Action_9,10"),	
	%% VII ELIB_BC_VISUAL_STATE_LOAD_TEST_IN_PROGRESS_END
	ok = nci_bci_actions:set_vii([{expectedSigNo, ?ELIB_BC_SET_VISUAL_INDICATION_CFM},
							{visualizedState, ?ELIB_BC_VISUAL_STATE_LOAD_TEST_IN_PROGRESS_END}]),
	ok = nci_bci_actions:check_vii_board_state([{viiInfo, false}]),


	ct:pal("Action_11,12"),	
	%% VII ELIB_BC_VISUAL_STATE_BOARD_LOCKED
	ok = nci_bci_actions:set_vii([{expectedSigNo, ?ELIB_BC_SET_VISUAL_INDICATION_CFM},
							{visualizedState, ?ELIB_BC_VISUAL_STATE_BOARD_LOCKED}]),
	ok = nci_bci_actions:check_vii_board_state([{viiInfo, true},
							{isBackup, IsBackup},
							{boardLocked, "YES"}]),

	ct:pal("Action_13,14"),	
	%% VII ELIB_BC_VISUAL_STATE_BOARD_UNLOCKED
	ok = nci_bci_actions:set_vii([{expectedSigNo, ?ELIB_BC_SET_VISUAL_INDICATION_CFM},
							{visualizedState, ?ELIB_BC_VISUAL_STATE_BOARD_UNLOCKED},
							{viiInfo, false}]),
	ok = nci_bci_actions:check_vii_board_state([{viiInfo, false}]),

	ct:pal("Action_15,16"),	
	%% VII ELIB_BC_VISUAL_STATE_FAULT
	ok = nci_bci_actions:set_vii([{expectedSigNo, ?ELIB_BC_SET_VISUAL_INDICATION_CFM},
							{visualizedState, ?ELIB_BC_VISUAL_STATE_FAULT}]),
	ok = nci_bci_actions:check_vii_board_state([{viiInfo, true},
							{isBackup, IsBackup},
							{fault, "YES"}]),

	ct:pal("Action_17,18"),	
	%% VII ELIB_BC_VISUAL_STATE_NO_FAULT
	ok = nci_bci_actions:set_vii([{expectedSigNo, ?ELIB_BC_SET_VISUAL_INDICATION_CFM},
							{visualizedState, ?ELIB_BC_VISUAL_STATE_NO_FAULT}]),
	ok = nci_bci_actions:check_vii_board_state([{viiInfo, false}]),

	ct:pal("Action_19,20"),	
	%% VII ELIB_BC_VISUAL_STATE_SHUTDOWN
	ok = nci_bci_actions:set_vii([{expectedSigNo, ?ELIB_BC_SET_VISUAL_INDICATION_CFM},
							{visualizedState, ?ELIB_BC_VISUAL_STATE_SHUTDOWN}]),
	ok = nci_bci_actions:check_vii_board_state([{viiInfo, true},
							{isBackup, IsBackup},
							{shutdown, "YES"}]),

	%% VII ELIB_BC_VISUAL_STATE_BOARD_BUSY
	%% VII ELIB_BC_VISUAL_STATE_SHUTDOWN_END
	case nci_common_utils:get_du() of
		dus -> % DUS41
			BoardBusy = "NO";
		mRBS_lte -> % mRBS
			BoardBusy = "NO";
		_ -> % DUL20
			BoardBusy = "YES"
	end,
	
	case nci_common_cfg:get_board_prodnr(?SHELL_COMMAND) of
		"KDU 137 533/3" ->
			ViiSetCmd1 = [{expectedSigNo, ?ELIB_BC_SET_VISUAL_INDICATION_CFM},
						{visualizedState, ?ELIB_BC_VISUAL_STATE_BOARD_BUSY}],
			ViiStateCmd1 = [{viiInfo, true},
						{isBackup, IsBackup},
						{boardBusy, BoardBusy},
						{shutdown, "YES"}];
		_ ->
			ViiSetCmd1 = [{expectedSigNo, ?ELIB_BC_SET_VISUAL_INDICATION_CFM},
						{visualizedState, ?ELIB_BC_VISUAL_STATE_BOARD_BUSY}],
			ViiStateCmd1 = [{viiInfo, true},
						{isBackup, IsBackup},
						{shutdown, "YES"}]
	end,

	ct:pal("Action_21,22"),	
	ok = nci_bci_actions:set_vii(ViiSetCmd1),
	ok = nci_bci_actions:check_vii_board_state(ViiStateCmd1),

	case nci_common_cfg:get_board_prodnr(?SHELL_COMMAND) of
		"KDU 137 533/4" ->
			ViiSetCmd2 = [{expectedSigNo, ?ELIB_BC_SET_VISUAL_INDICATION_CFM},
						{visualizedState, ?ELIB_BC_VISUAL_STATE_SHUTDOWN_END}],
			ViiStateCmd2 = [{viiInfo, false}];
		"KDU 137 533/3" ->
			ViiSetCmd2 = [{expectedSigNo, ?ELIB_BC_SET_VISUAL_INDICATION_CFM},
						{visualizedState, ?ELIB_BC_VISUAL_STATE_SHUTDOWN_END}],
			ViiStateCmd2 = [{viiInfo, true},
						{isBackup, IsBackup},
						{boardBusy, BoardBusy}];
		_ ->
			ViiSetCmd2 = [{expectedSigNo, ?ELIB_BC_SET_VISUAL_INDICATION_CFM},
						{visualizedState, ?ELIB_BC_VISUAL_STATE_SHUTDOWN_END}],
			ViiStateCmd2 = [{viiInfo, true}]
	end,

	ct:pal("Action_23,24"),	
	ok = nci_bci_actions:set_vii(ViiSetCmd2),
	ok = nci_bci_actions:check_vii_board_state(ViiStateCmd2),

	ct:pal("Action_25,26"),	
	%% VII ELIB_BC_VISUAL_STATE_RESET
	ok = nci_bci_actions:set_vii([{expectedSigNo, ?ELIB_BC_SET_VISUAL_INDICATION_CFM},
							{visualizedState, ?ELIB_BC_VISUAL_STATE_RESET}]),
	ok =  nci_bci_actions:check_vii_board_state([{viiInfo, false}]),

	%% VII ELIB_BC_VISUAL_STATE_NO_POWER
	ok = nci_bci_actions:set_vii([{expectedSigNo, ?ELIB_BC_SET_VISUAL_INDICATION_CFM},
							{visualizedState, ?ELIB_BC_VISUAL_STATE_NO_POWER}]),
	ok =  nci_bci_actions:check_vii_board_state([{viiInfo, true},
							{isBackup, IsBackup},
							{noPower, "YES"}]),

	ct:pal("Action_29,30"),	
	%% VII ELIB_BC_VISUAL_STATE_POWER_PRESENT
	ok = nci_bci_actions:set_vii([{expectedSigNo, ?ELIB_BC_SET_VISUAL_INDICATION_CFM},
							{visualizedState, ?ELIB_BC_VISUAL_STATE_POWER_PRESENT}]),
	ok =  nci_bci_actions:check_vii_board_state([{viiInfo, false}]),

	ct:pal("Action_31,32"),	
	%% VII ELIB_BC_VISUAL_STATE_BOOT_TEST_IN_PROGRESS
	ok = nci_bci_actions:set_vii([{expectedSigNo, ?ELIB_BC_SET_VISUAL_INDICATION_CFM},
							{visualizedState, ?ELIB_BC_VISUAL_STATE_BOOT_TEST_IN_PROGRESS}]),
	ok =  nci_bci_actions:check_vii_board_state([{viiInfo, true},
							{isBackup, IsBackup},
							{boottest, "YES"}]),

	ct:pal("Action_33,34"),	
	%% VII ELIB_BC_VISUAL_STATE_BOOT_TEST_IN_PROGRESS_END
	ok = nci_bci_actions:set_vii([{expectedSigNo, ?ELIB_BC_SET_VISUAL_INDICATION_CFM},
							{visualizedState, ?ELIB_BC_VISUAL_STATE_BOOT_TEST_IN_PROGRESS_END}]),
	ok =  nci_bci_actions:check_vii_board_state([{viiInfo, false}]),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id BCI_SVI2
%%
%% $Header
%%  State Operational
%%
%% $Description
%%  Verify that used VII states behave according to [1] and [2] in some normal cases in state operational
%%
%% $Requirements
%%  CBD_DBC_VII_FU:1:A
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  DUL has product number KDU 137 533/4
%%
%%  DU BC is in state operational
%%
%% $Action
%%  Send a BC_SET_VISUAL_INDICATION_REQ with parameters:
%%
%%  visualizedState = BC_VISUAL_STATE_RESET 
%%
%% $Result
%%  A BC_SET_VISUAL_INDICATION_CFM is received.
%%
%% $Action
%%  Check the vii state
%%
%% $Result
%%  The vii state indicates:
%%
%%  no visual indication
%%
%% $Action
%%  Send a BC_SET_VISUAL_INDICATION_REQ with parameters:
%%
%%  visualizedState= BC_VISUAL_STATE_MISSING_RESOURCE
%%
%% $Result
%%  A BC_SET_VISUAL_INDICATION_CFM is received
%%
%% $Action
%%  Check the vii state
%%
%% $Result
%%  The vii state indicates:
%%
%%  missing_resource = "yes"
%%
%% $Action
%%  Send a BC_SET_VISUAL_INDICATION_REQ with parameters:
%%
%%  visualizedState= BC_VISUAL_STATE_LOAD_TEST_IN_PROGRESS
%%
%% $Result
%%  A BC_SET_VISUAL_INDICATION_CFM is received
%%
%% $Action
%%  Check the vii state
%%
%% $Result
%%  The vii state indicates:
%%
%%  missing_resource = "yes"
%%
%%  load_start = "yes"
%%
%% $Action
%%  Send a BC_SET_VISUAL_INDICATION_REQ with parameters:
%%
%%  visualizedState= BC_VISUAL_STATE_MISSING_RESOURCE_END
%%
%% $Result
%%  A BC_SET_VISUAL_INDICATION_CFM is received
%%
%% $Action
%%  Check the vii state
%%
%% $Result
%%  The vii state indicates:
%%
%%  load_start = "yes"
%%
%% $Action
%%  Send a BC_SET_VISUAL_INDICATION_REQ with parameters:
%%
%%  visualizedState= BC_VISUAL_STATE_LOAD_TEST_IN_PROGRESS_END
%%
%% $Result
%%  A BC_SET_VISUAL_INDICATION_CFM is received
%%
%% $Action
%%  Check the vii state
%%
%% $Result
%%  The vii state indicates:
%%
%%  no visual indication
%%
%% $Action
%%  Send a BC_SET_VISUAL_INDICATION_REQ with parameters:
%%
%%  visualizedState = BC_VISUAL_STATE_BOARD_LOCKED
%%
%% $Result
%%  A BC_SET_VISUAL_INDICATION_CFM is received
%%
%% $Action
%%  Check the vii state
%%
%% $Result
%%  The vii state indicates:
%%
%%  board_locked = "yes"
%%
%% $Action
%%  Send a BC_SET_VISUAL_INDICATION_REQ with parameters: 
%%
%%  visualizedState= BC_VISUAL_STATE_BOARD_UNLOCKED
%%
%% $Result
%%  A BC_SET_VISUAL_INDICATION_CFM is received
%%
%% $Action
%%  Check the vii state
%%
%% $Result
%%  The vii state indicates:
%%
%%  no visual indication
%%
%% $Action
%%  Send a BC_SET_VISUAL_INDICATION_REQ with parameters:
%%
%%  visualizedState = BC_VISUAL_STATE_FAULT
%%
%% $Result
%%  A BC_SET_VISUAL_INDICATION_CFM is received
%%
%% $Action
%%  Check the vii state
%%
%% $Result
%%  The vii state indicates:
%%
%%  fault = "yes"
%%
%% $Action
%%  Send a BC_SET_VISUAL_INDICATION_REQ with parameters:
%%
%%  visualizedState = BC_VISUAL_STATE_NO_FAULT
%%
%% $Result
%%  A BC_SET_VISUAL_INDICATION_CFM is received
%%
%% $Action
%%  Check the vii state
%%
%% $Result
%%  The vii state indicates:
%%
%%  no visual indication
%%
%% $Action
%%  Send a BC_SET_VISUAL_INDICATION_REQ with parameters:
%%
%%  visualizedState = BC_VISUAL_STATE_SHUTDOWN
%%
%% $Result
%%  A BC_SET_VISUAL_INDICATION_CFM is received
%%
%% $Action
%%  Check the vii state
%%
%% $Result
%%  The vii state indicates:
%%
%%  shutdown = "yes"
%%
%% $Action
%%  Send a BC_SET_VISUAL_INDICATION_REQ with parameters:
%%
%%  visualizedState = BC_VISUAL_STATE_BOARD_BUSY
%%
%% $Result
%%  A BC_SET_VISUAL_INDICATION_CFM is received
%%
%% $Action
%%  Check the vii state
%%
%% $Result
%%  The vii state indicates:
%%
%%  shutdown = "yes"
%%
%% $Action
%%  Send a BC_SET_VISUAL_INDICATION_REQ with parameters:
%%
%%  visualizedState= BC_VISUAL_STATE_SHUTDOWN_END
%%
%% $Result
%%  A BC_SET_VISUAL_INDICATION_CFM is received
%%
%% $Action
%%  Check the vii state
%%
%% $Result
%%  The vii state indicates:
%%
%%  board_busy = "yes"
%%
%% $Action
%%  Send a BC_SET_VISUAL_INDICATION_REQ with parameters:
%%
%%  visualizedState = BC_VISUAL_STATE_RESET
%%
%% $Result
%%  A BC_SET_VISUAL_INDICATION_CFM is received
%%
%% $Action
%%  Check the vii state
%%
%% $Result
%%  The vii state indicates:
%%
%%  no visual indication
%%
%% $Action
%%  Send a BC_SET_VISUAL_INDICATION_REQ with parameters:
%%
%%  visualizedState = BC_VISUAL_STATE_NO_POWER
%%
%% $Result
%%  A BC_SET_VISUAL_INDICATION_CFM is received
%%
%% $Action
%%  Check the vii state
%%
%% $Result
%%  The vii state indicates:
%%
%%  no_power = "yes"
%%
%% $Action
%%  Send a BC_SET_VISUAL_INDICATION_REQ with parameters:
%%
%%  visualizedState= BC_VISUAL_STATE_POWER_PRESENT
%%
%% $Result
%%  A BC_SET_VISUAL_INDICATION_CFM is received
%%
%% $Action
%%  Check the vii state
%%
%% $Result
%%  The vii state indicates:
%%
%%  no visual indication
%%
%% $Action
%%  Send a BC_SET_VISUAL_INDICATION_REQ with parameters:
%%
%%  visualizedState= BC_VISUAL_STATE_BOOT_TEST_IN_PROGRESS
%%
%% $Result
%%  A BC_SET_VISUAL_INDICATION_CFM is received
%%
%% $Action
%%  Check the vii state
%%
%% $Result
%%  The vii state indicates:
%%
%%  boottest = "yes"
%%
%% $Action
%%  Send a BC_SET_VISUAL_INDICATION_REQ with parameters:
%%
%%  visualizedState= BC_VISUAL_STATE_BOOT_TEST_IN_PROGRESS_END
%%
%% $Result
%%  A BC_SET_VISUAL_INDICATION_CFM is received
%%
%% $Action
%%  Check the vii state
%%
%% $Result
%%  The vii state indicates:
%%
%%  no visual indication
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-05-30, QMAGSED
%%    First version
%%
%%  2012-10-31, EEDAJA
%%    Combined with bci_sv1 and bci_sv3 as function bci_svi
%%
%%------------------------------------------------------------------------------
bci_svi2() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_DBC_VII_FU:1:A"},
				{slogan, "State Operational"}]}].

bci_svi2(_Config) ->
	bci_svi("bci_svi2", operational ).

%%------------------------------------------------------------------------------
%% $Id BCI_SVI3
%%
%% $Header
%%  State Disabled
%%
%% $Description
%%  Verify that used VII states behave according to [1] and [2] in some normal cases in state disabled
%%
%% $Requirements
%%  CBD_DBC_VII_FU:1:A
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  DUL has product number KDU 137 533/4
%%
%%  DU BC is in state disabled
%%
%% $Action
%%  Send a BC_SET_VISUAL_INDICATION_REQ with parameters:
%%
%%  visualizedState = BC_VISUAL_STATE_RESET 
%%
%% $Result
%%  A BC_SET_VISUAL_INDICATION_CFM is received.
%%
%% $Action
%%  Check the vii state
%%
%% $Result
%%  The vii state indicates:
%%
%%  no visual indication
%%
%% $Action
%%  Send a BC_SET_VISUAL_INDICATION_REQ with parameters:
%%
%%  visualizedState= BC_VISUAL_STATE_MISSING_RESOURCE
%%
%% $Result
%%  A BC_SET_VISUAL_INDICATION_CFM is received
%%
%% $Action
%%  Check the vii state
%%
%% $Result
%%  The vii state indicates:
%%
%%  missing_resource = "yes"
%%
%% $Action
%%  Send a BC_SET_VISUAL_INDICATION_REQ with parameters:
%%
%%  visualizedState= BC_VISUAL_STATE_LOAD_TEST_IN_PROGRESS
%%
%% $Result
%%  A BC_SET_VISUAL_INDICATION_CFM is received
%%
%% $Action
%%  Check the vii state
%%
%% $Result
%%  The vii state indicates:
%%
%%  missing_resource = "yes"
%%
%%  load_start = "yes"
%%
%% $Action
%%  Send a BC_SET_VISUAL_INDICATION_REQ with parameters:
%%
%%  visualizedState= BC_VISUAL_STATE_MISSING_RESOURCE_END
%%
%% $Result
%%  A BC_SET_VISUAL_INDICATION_CFM is received
%%
%% $Action
%%  Check the vii state
%%
%% $Result
%%  The vii state indicates:
%%
%%  load_start = "yes"
%%
%% $Action
%%  Send a BC_SET_VISUAL_INDICATION_REQ with parameters:
%%
%%  visualizedState= BC_VISUAL_STATE_LOAD_TEST_IN_PROGRESS_END
%%
%% $Result
%%  A BC_SET_VISUAL_INDICATION_CFM is received
%%
%% $Action
%%  Check the vii state
%%
%% $Result
%%  The vii state indicates:
%%
%%  no visual indication
%%
%% $Action
%%  Send a BC_SET_VISUAL_INDICATION_REQ with parameters:
%%
%%  visualizedState = BC_VISUAL_STATE_BOARD_LOCKED
%%
%% $Result
%%  A BC_SET_VISUAL_INDICATION_CFM is received
%%
%% $Action
%%  Check the vii state
%%
%% $Result
%%  The vii state indicates:
%%
%%  board_locked = "yes"
%%
%% $Action
%%  Send a BC_SET_VISUAL_INDICATION_REQ with parameters: 
%%
%%  visualizedState= BC_VISUAL_STATE_BOARD_UNLOCKED
%%
%% $Result
%%  A BC_SET_VISUAL_INDICATION_CFM is received
%%
%% $Action
%%  Check the vii state
%%
%% $Result
%%  The vii state indicates:
%%
%%  no visual indication
%%
%% $Action
%%  Send a BC_SET_VISUAL_INDICATION_REQ with parameters:
%%
%%  visualizedState = BC_VISUAL_STATE_FAULT
%%
%% $Result
%%  A BC_SET_VISUAL_INDICATION_CFM is received
%%
%% $Action
%%  Check the vii state
%%
%% $Result
%%  The vii state indicates:
%%
%%  fault = "yes"
%%
%% $Action
%%  Send a BC_SET_VISUAL_INDICATION_REQ with parameters:
%%
%%  visualizedState = BC_VISUAL_STATE_NO_FAULT
%%
%% $Result
%%  A BC_SET_VISUAL_INDICATION_CFM is received
%%
%% $Action
%%  Check the vii state
%%
%% $Result
%%  The vii state indicates:
%%
%%  no visual indication
%%
%% $Action
%%  Send a BC_SET_VISUAL_INDICATION_REQ with parameters:
%%
%%  visualizedState = BC_VISUAL_STATE_SHUTDOWN
%%
%% $Result
%%  A BC_SET_VISUAL_INDICATION_CFM is received
%%
%% $Action
%%  Check the vii state
%%
%% $Result
%%  The vii state indicates:
%%
%%  shutdown = "yes"
%%
%% $Action
%%  Send a BC_SET_VISUAL_INDICATION_REQ with parameters:
%%
%%  visualizedState = BC_VISUAL_STATE_BOARD_BUSY
%%
%% $Result
%%  A BC_SET_VISUAL_INDICATION_CFM is received
%%
%% $Action
%%  Check the vii state
%%
%% $Result
%%  The vii state indicates:
%%
%%  shutdown = "yes"
%%
%% $Action
%%  Send a BC_SET_VISUAL_INDICATION_REQ with parameters:
%%
%%  visualizedState= BC_VISUAL_STATE_SHUTDOWN_END
%%
%% $Result
%%  A BC_SET_VISUAL_INDICATION_CFM is received
%%
%% $Action
%%  Check the vii state
%%
%% $Result
%%  The vii state indicates:
%%
%%  board_busy = "yes"
%%
%% $Action
%%  Send a BC_SET_VISUAL_INDICATION_REQ with parameters:
%%
%%  visualizedState = BC_VISUAL_STATE_RESET
%%
%% $Result
%%  A BC_SET_VISUAL_INDICATION_CFM is received
%%
%% $Action
%%  Check the vii state
%%
%% $Result
%%  The vii state indicates:
%%
%%  no visual indication
%%
%% $Action
%%  Send a BC_SET_VISUAL_INDICATION_REQ with parameters:
%%
%%  visualizedState = BC_VISUAL_STATE_NO_POWER
%%
%% $Result
%%  A BC_SET_VISUAL_INDICATION_CFM is received
%%
%% $Action
%%  Check the vii state
%%
%% $Result
%%  The vii state indicates:
%%
%%  no_power = "yes"
%%
%% $Action
%%  Send a BC_SET_VISUAL_INDICATION_REQ with parameters:
%%
%%  visualizedState= BC_VISUAL_STATE_POWER_PRESENT
%%
%% $Result
%%  A BC_SET_VISUAL_INDICATION_CFM is received
%%
%% $Action
%%  Check the vii state
%%
%% $Result
%%  The vii state indicates:
%%
%%  no visual indication
%%
%% $Action
%%  Send a BC_SET_VISUAL_INDICATION_REQ with parameters:
%%
%%  visualizedState= BC_VISUAL_STATE_BOOT_TEST_IN_PROGRESS
%%
%% $Result
%%  A BC_SET_VISUAL_INDICATION_CFM is received
%%
%% $Action
%%  Check the vii state
%%
%% $Result
%%  The vii state indicates:
%%
%%  boottest = "yes"
%%
%% $Action
%%  Send a BC_SET_VISUAL_INDICATION_REQ with parameters:
%%
%%  visualizedState= BC_VISUAL_STATE_BOOT_TEST_IN_PROGRESS_END
%%
%% $Result
%%  A BC_SET_VISUAL_INDICATION_CFM is received
%%
%% $Action
%%  Check the vii state
%%
%% $Result
%%  The vii state indicates:
%%
%%  no visual indication
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-05-30, QMAGSED
%%    First version
%%
%%  2012-10-31, EEDAJA
%%    Combined with bci_sv1 and bci_sv2 as function bci_svi
%%
%%------------------------------------------------------------------------------
bci_svi3() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_DBC_VII_FU:1:A"},
				{slogan, "State Disabled"}]}].

bci_svi3(_Config) ->
	bci_svi("bci_svi3", disabled ).

%%------------------------------------------------------------------------------
%% $Id BCI_SVI4
%%
%% $Header
%%  Illegal Visual State
%%
%% $Description
%%  Verify that VII states behave according to [1] and [2] when a faulty state is given in state starting
%%
%% $Requirements
%%  CBD_DBC_VII_FU:1:A
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state starting
%%
%% $Action
%%  Send a SET_VISUAL_INDICATION_REQ with parameters:
%%
%%  visualizedState = 0xFFFF
%%
%% $Result
%%  A SET_VISUAL_INDICATION_REJ is received with parameters:
%%
%%  errorCode = UNSUCCESSFUL
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-05-30, QMAGSED
%%    First version
%%
%%------------------------------------------------------------------------------
bci_svi4() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_DBC_VII_FU:1:A"},
				{slogan, "Illegal Visual State"}]}].

bci_svi4(_Config) ->
	ct:pal("bci_svi4"),

	{ok, session_up} = coli:subscribe_state(?SHELL_COMMAND),
	{ok, session_up} = osegw:subscribe_state(?OSE_GW_DEAMON_1),

	nci_bci_states:set_state([{state, starting_lmc_loaded}]),

	%% Connect to BCI interface
	ok = nci_bci_actions:conn_establish([]),

	%% VII ELIB_BC_VISUAL_STATE_RESET
	ok = nci_bci_actions:set_vii([{visualizedState, 65535},
				  {expectedSigNo, ?ELIB_BC_SET_VISUAL_INDICATION_REJ},
				  {errorCode, 1}]),
	%% Check TE Log
	nci_common_utils:check_te_log(?SHELL_COMMAND, "|"++".*ERROR:hwIf_handler_setLed: Unexpected led indication 65535.*"),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%##############################################################################
%% $ChapterH2 Connection Lost
%%
%%
%% $End
%%##############################################################################

%%------------------------------------------------------------------------------
%% $Id BCI_CL1
%%
%% $Header
%%  BCI Connection - State change
%%
%% $Description
%%  To verify that when connection is lost state is changed to starting
%%
%% $Requirements
%%  CBD_START-RESTART_BCI_OM:3:A
%%  CBD_START-RESTART_BCI_OM:1:A
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  Connection establish has been performed by 3 clients (A, B, C)
%%
%% $Action_1
%%  Client A sends a ENABLE_OPERATION_REQ
%%
%% $Result_1
%%  Client A receives a ENABLE_OPERATION_CFM is received
%%
%% $Action_2
%%  Kill client A
%%
%% $Result_2
%%  Client A dies
%%
%% $Action_3
%%  Client B sends a AUDIT_REQ
%%
%% $Result_3
%%  Client B receives a AUDIT_CFM with parameters:
%%  * mainState = MAIN_STATE_OPERATIONAL
%%
%% $Action_4
%%  Kill client B
%%
%% $Result_4
%%  Client B dies
%%
%% $Action_5
%%  Client C sends a AUDIT_REQ
%%
%% $Result_5
%%  Client C receives a AUDIT_CFM with parameters:
%%  * mainState = MAIN_STATE_OPERATIONAL
%%
%% $Action_6
%%  Kill client C
%%
%% $Result_6
%%  Client C dies. Last connection lost. CBCI connection goes to state Not Connected
%%
%% $Action_7
%%  Client D send a CONN_ESTABLISH_REQ, with parameters:
%%  * protocolRev = REV
%%
%% $Result_7
%%  Client D receives a CONN_ESTABLISH_CFM
%%
%% $Action_8
%%  Client D sends a AUDIT_REQ
%%
%% $Result_8
%%  Client D receives a AUDIT_CFM with parameters:
%%  * mainState = MAIN_STATE_STARTING
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-05-30, QMAGSED
%%    First version
%%  2013-08-07, ebacemi
%%    Revised the whole test case
%%
%%------------------------------------------------------------------------------
bci_cl1() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_START-RESTART_BCI_OM:3:A, CBD_START-RESTART_BCI_OM:1:A"},
				{slogan, "BCI Connection - State change"}]}].

bci_cl1(_Config) ->
	ct:pal("bci_cl1"),

	{ok, session_up} = coli:subscribe_state(?SHELL_COMMAND),
	{ok, session_up} = osegw:subscribe_state(?OSE_GW_DEAMON_1),

	%% Restart Board
	ok = nci_bci_actions:conn_establish([]),
	nci_bci_states:restart_board( "Test case bci_cl1" ),
	
	%% Create 3 more GWs
	ok = osegw:create(#osegw{name = ?OSE_GW_DEAMON_2, 
							 iap = osegw, 
							 opt = [{ping_timeout, 6000}, 
									{codec_config, 
									 {?SIG_MODS, 
									  sizeof, 
									  osegw_ose,big}}]}),
	ok = osegw:create(#osegw{name = ?OSE_GW_DEAMON_3, 
							 iap = osegw, 
							 opt = [{ping_timeout, 6000}, 
									{codec_config, 
									 {?SIG_MODS, 
									  sizeof, 
									  osegw_ose,big}}]}),
	ok = osegw:create(#osegw{name = ?OSE_GW_DEAMON_4, 
							 iap = osegw, 
							 opt = [{ping_timeout, 6000}, 
									{codec_config, 
									 {?SIG_MODS, 
									  sizeof, 
									  osegw_ose,big}}]}),

	%% Client A, B & C Connect to BCI interface
	ok = nci_bci_actions:conn_establish([{oseGwDeamon,?OSE_GW_DEAMON_2}]),
	ok = nci_bci_actions:conn_establish([{oseGwDeamon,?OSE_GW_DEAMON_3}]),
	ok = nci_bci_actions:conn_establish([{oseGwDeamon,?OSE_GW_DEAMON_4}]),

	LoadModule = get_lmc_name(),
	SearchPath = nci_common_cfg:get_c_loadmodules_path(),

	%% Client A Load LMC
	ok = nci_bci_actions:load_lmc([{oseGwDeamon,?OSE_GW_DEAMON_2},
								   {searchPath, SearchPath},
								   {loadModule, LoadModule},
								   {expectedSigNo, dont_care}]),
	
	%% Client A Enable Operations
	ct:pal("Action_1"),
	ok = nci_bci_actions:enable_operation([{oseGwDeamon,?OSE_GW_DEAMON_2}]),

	%% Kill Client A
	ct:pal("Action_2"),
	ok = osegw:delete(?OSE_GW_DEAMON_2),	

	%% Client B Audit 
	ct:pal("Action_3"),
	ok = nci_bci_actions:audit([{oseGwDeamon,?OSE_GW_DEAMON_3},
								{expectedMainState, ?ELIB_BC_MAIN_STATE_OPERATIONAL}]),	

	%% Kill Client B
	ct:pal("Action_4"),
	ok = osegw:delete(?OSE_GW_DEAMON_3),

	%% Client C Audit 
	ct:pal("Action_5"),
	ok = nci_bci_actions:audit([{oseGwDeamon,?OSE_GW_DEAMON_4},
								{expectedMainState, ?ELIB_BC_MAIN_STATE_OPERATIONAL}]),	

	%% Kill Client C
	ct:pal("Action_6"),
	ok = osegw:delete(?OSE_GW_DEAMON_4),

	%% Client D connect
	ct:pal("Action_7"),
	ok = nci_bci_actions:conn_establish([{oseGwDeamon,?OSE_GW_DEAMON_1}]),

	%% Client D Audit 
	ct:pal("Action_8"),
	ok = nci_bci_actions:audit([{oseGwDeamon,?OSE_GW_DEAMON_1},
								{expectedMainState, ?ELIB_BC_MAIN_STATE_STARTING}]),		

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id BCI_CL2
%%
%% $Header
%%  BCI Connection - Subscription lost
%%
%% $Description
%%  Verify that when connection lost results in that the subscribtions on faults are cleared
%%
%% $Requirements
%%  CBD_FAULT_BCI_FU:1:A
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  Connection establish has been performed by client A
%%
%% $Action_1
%%  Client A sends a SUBSCRIBE_FAULTS_REQ
%%
%% $Result_1
%%  Client A receives a SUBSCRIBE_FAULTS_CFM
%%
%% $Action_2
%%  Client B sends a SUBSCRIBE_FAULTS_REQ
%%
%% $Result_2
%%  Client B receives a SUBSCRIBE_FAULTS_CFM
%%
%% $Action_3
%%  Client C sends a SUBSCRIBE_FAULTS_REQ
%%
%% $Result_3
%%  Client C receives a SUBSCRIBE_FAULTS_CFM
%%
%% $Action_4
%%  Kill client A
%%
%% $Result_4
%%  CBCI connection goes to Not connected state
%%
%% $Action_5
%%  Client D send a CONN_ESTABLISH_REQ with parameters:
%%  * protocolRev = REV
%%
%% $Result_5
%%  Client D receives a CONN_ESTABLISH_CFM is received
%%
%% $Action_6
%%  Fake temperature <TempLimitLowExceptional> using shellcommand: setTemp
%%
%% $Result_6
%%  No FAULT_IND received by any client
%%
%% $Action_7
%%  Client B sends a SUBSCRIBE_FAULTS_REQ
%%
%% $Result_7A
%%  Client B receives a SUBSCRIBE_FAULTS_CFM
%%
%% $Result_7B
%%  Client B receives a A FAULT_IND with parameters:
%%  * faultId = NORMAL_TEMPERATURE_TOO_LOW
%%  * faultDescription = "Temp fault"
%%
%% $Action_8
%%  Client C sends a SUBSCRIBE_FAULTS_REQ.
%%
%% $Result_8A
%%  Client C receives a SUBSCRIBE_FAULTS_CFM
%%
%% $Result_8B
%%  Client A receives a A FAULT_IND with parameters:
%%  * faultId = NORMAL_TEMPERATURE_TOO_LOW
%%  * faultDescription = "Temp fault"
%%
%% $Action_9
%%  Client D sends a SUBSCRIBE_FAULTS_REQ
%%
%% $Result_9A
%%  Client D receives a SUBSCRIBE_FAULTS_CFM.
%%
%% $Result_9B
%%  Client D receives a A FAULT_IND with parameters:
%%  * faultId = NORMAL_TEMPERATURE_TOO_LOW
%%  * faultDescription = "Temp fault"
%%
%% $Action_10
%%  Stop faking temperature
%%
%% $Result_10A
%%  Client B receives a A FAULTCEASE_IND with parameters:
%%  * faultId = NORMAL_TEMPERATURE_TOO_LOW
%%
%% $Result_10B
%%  Client C receives a A FAULTCEASE_IND with parameters:
%%  * faultId = NORMAL_TEMPERATURE_TOO_LOW
%%
%% $Result_10C
%%  Client D receives a A FAULTCEASE_IND with parameters:
%%  * faultId = NORMAL_TEMPERATURE_TOO_LOW
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-05-30, QMAGSED
%%    First version
%%
%%  2013-01-05, Eyanwzh
%%    Add "Action_X" to the test case and add implementation of Result_4,5,7.
%%
%%  2013-01-21, ejonuna
%%    Added enabling and disabling of trace1 NCI_COMMON to make trace detection work
%%
%%  2013-08-07, ebacemi
%%    Removed action that checks for CBCI pending state
%%    Revised some parts of the TC
%%
%%  2013-11-07, emasnok
%%    Introduced utility function for temperature limits. 
%%
%%------------------------------------------------------------------------------
bci_cl2() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_FAULT_BCI_FU:1:A"},
				{slogan, "BCI Connection - Subscription lost"}]}].

bci_cl2(_Config) ->
	ct:pal("bci_cl2"),

	{ok, session_up} = coli:subscribe_state(?SHELL_COMMAND),
	{ok, session_up} = osegw:subscribe_state(?OSE_GW_DEAMON_1),

	%% Restart Board
	ok = nci_bci_actions:conn_establish([]),
	nci_bci_states:restart_board( "Test case bci_cl2" ),

	%% Create 3 more GWs
	ok = osegw:create(#osegw{name = ?OSE_GW_DEAMON_2, 
							 iap = osegw, 
							 opt = [{ping_timeout, 6000}, 
									{codec_config, 
									 {?SIG_MODS, 
									  sizeof, 
									  osegw_ose,big}}]}),
	ok = osegw:create(#osegw{name = ?OSE_GW_DEAMON_3, 
							 iap = osegw, 
							 opt = [{ping_timeout, 6000}, 
									{codec_config, 
									 {?SIG_MODS, 
									  sizeof, 
									  osegw_ose,big}}]}),
	ok = osegw:create(#osegw{name = ?OSE_GW_DEAMON_4, 
							 iap = osegw, 
							 opt = [{ping_timeout, 6000}, 
									{codec_config, 
									 {?SIG_MODS, 
									  sizeof, 
									  osegw_ose,big}}]}),
	
	%% Client A Connect to BCI interface
	ok = nci_bci_actions:conn_establish([{oseGwDeamon,?OSE_GW_DEAMON_2}]),

	LoadModule = get_lmc_name(),
	SearchPath = nci_common_cfg:get_c_loadmodules_path(),

	%% Client A Load LMC
	ok = nci_bci_actions:load_lmc([{oseGwDeamon,?OSE_GW_DEAMON_2},
								   {searchPath, SearchPath},
								   {loadModule, LoadModule},
								   {expectedSigNo, dont_care}]),
								
	%% Client A, B & C Subscribe Faults			
	ct:pal("Action_1"),
	ok = nci_bci_actions:subscribe_faults([{oseGwDeamon,?OSE_GW_DEAMON_2}]),
		
	ct:pal("Action_2"),
	ok = nci_bci_actions:subscribe_faults([{oseGwDeamon,?OSE_GW_DEAMON_3}]),
		
	ct:pal("Action_3"),
	ok = nci_bci_actions:subscribe_faults([{oseGwDeamon,?OSE_GW_DEAMON_4}]),

	%% Kill Client A
	ct:pal("Action_4"),
	ok = osegw:delete(?OSE_GW_DEAMON_2),
	nci_common_utils:find_string_in_te_log(?SHELL_COMMAND, "Interface CBCI is now Not Connected"),
	
	%% Client D Connect to BCI interface
	ct:pal("Action_5"),
	ok = nci_bci_actions:conn_establish([{oseGwDeamon,?OSE_GW_DEAMON_1}]),

	LowTemp = nci_common_cfg:get_temp_param(lowExceptional),

	%% Fake low temp with cbu_command
	ct:pal("Action_6"),
	nci_common_utils:coli_cmd("setTemp " ++ integer_to_list(LowTemp)),
	nci_common_utils:check_outstanding_faults(2000),
	nci_common_utils:check_outstanding_faults(?OSE_GW_DEAMON_3, 2000),
	nci_common_utils:check_outstanding_faults(?OSE_GW_DEAMON_4, 2000),

	%% Client B Subscribe Faults
	ct:pal("Action_7"),
	ok = nci_bci_actions:subscribe_faults([{oseGwDeamon,?OSE_GW_DEAMON_3}]),

	%% Client B receive fault ind
	ok = nci_bci_actions:fault_ind([{oseGwDeamon,?OSE_GW_DEAMON_3},
									{faultId, ?ELIB_CONST_FH_FAULT_ID_NORMAL_TEMPERATURE_TOO_LOW},
									{faultDescription, {regexp, "Temp fault*"}}]),
	
	%% Client C Subscribe Faults
	ct:pal("Action_8"),
	ok = nci_bci_actions:subscribe_faults([{oseGwDeamon,?OSE_GW_DEAMON_4}]),
	
	%% Client C receive fault ind
	ok = nci_bci_actions:fault_ind([{oseGwDeamon,?OSE_GW_DEAMON_4},
									{faultId, ?ELIB_CONST_FH_FAULT_ID_NORMAL_TEMPERATURE_TOO_LOW},
									{faultDescription, {regexp, "Temp fault*"}}]),
	
	%% Client D Subscribe Faults
	ct:pal("Action_9"),
	ok = nci_bci_actions:subscribe_faults([{oseGwDeamon,?OSE_GW_DEAMON_1}]),
	
	%% Client D receive fault ind
	ok = nci_bci_actions:fault_ind([{oseGwDeamon,?OSE_GW_DEAMON_1},
									{faultId, ?ELIB_CONST_FH_FAULT_ID_NORMAL_TEMPERATURE_TOO_LOW},
									{faultDescription, {regexp, "Temp fault*"}}]),
	
	%% Stop fake temp with cbu_command
	ct:pal("Action_10"),
	nci_common_utils:coli_cmd("setTemp"),
	
	%% Client B, C & D receive fault cease ind
	ok = nci_bci_actions:fault_cease_ind([{oseGwDeamon,?OSE_GW_DEAMON_3},
										  {faultId, ?ELIB_CONST_FH_FAULT_ID_NORMAL_TEMPERATURE_TOO_LOW}]),
	ok = nci_bci_actions:fault_cease_ind([{oseGwDeamon,?OSE_GW_DEAMON_4},
										  {faultId, ?ELIB_CONST_FH_FAULT_ID_NORMAL_TEMPERATURE_TOO_LOW}]),
	ok = nci_bci_actions:fault_cease_ind([{oseGwDeamon,?OSE_GW_DEAMON_1},
										  {faultId, ?ELIB_CONST_FH_FAULT_ID_NORMAL_TEMPERATURE_TOO_LOW}]),
	
	%% Kill Client B & C
	ok = osegw:delete(?OSE_GW_DEAMON_3),
	ok = osegw:delete(?OSE_GW_DEAMON_4),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%##############################################################################
%% $ChapterH2 Setting up IQ connections
%%
%% DU BC shall IQ connections.
%%
%% $End
%%##############################################################################

%%------------------------------------------------------------------------------
%% $Id BCI_SII1
%%
%% $Header
%%  State Operational
%%
%% $Description
%%  Test setup IQ HW IF in state operational
%%
%% $Requirements
%%  CBD_DBC_BCI_FU:6:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  Ensure state is in operational
%%
%% $Action_1
%%  Send a GET_CAPABILITIES_REQ
%%
%% $Result_1
%% GET_CAPABILITIES_CFM is received with 5 capabilities:
%% for DULs cap,cap4,cap2,cap3,cap6
%% for DUS41 cap,cap4,cap5,cap3,cap7
%% - CAP_LOADING_SUPPORT
%% - CAP_COMMON_MMI_SUPPORT
%% - CAP_ETH_HW_IF_SUPPORT2
%% - CAP_CLIMATE_CONTROL_SUPPORT
%% - CAP_IQ_HW_IF_SUPPORT
%%
%% $Action_2
%%  Send a ELIB_BC_SETUP_IQ_HW_IF_REQ with parameters:
%%
%%  nofIqlLinks 9 for DULs or 8 for DUS41
%%
%%  list of logicalIds
%%
%% $Result_2
%%  A ELIB_BC_SETUP_IQ_HW_IF_CFM is received
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  2012-12-17, EJONUNA
%%
%% Revision history:
%%  2012-12-03, EEDAJA
%%    First version
%%
%%  2012-12-17, EEDAJA
%%    Review comments implemented
%%
%%------------------------------------------------------------------------------
bci_sii1() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_DBC_BCI_FU:6:C"},
				{slogan, "Test setup IQ HW IF in state operational"}]}].

bci_sii1(_Config) ->
	ct:pal("bci_sii1"),

	bci_sii_pre( operational ),

	%% Setup IQ HW IF
	ct:pal("Action_2"),

	case nci_common_utils:get_du() of
		dus ->
			NofIqLinks = 8,
			LogicalId = [0,1,2,3,4,5,6,7];
		mRBS_lte->
			NofIqLinks = 8,
			LogicalId = [0,1,2,3,4,5,6,7];
		_ ->
			NofIqLinks = 9,
			LogicalId = [0,2,3,0,2,3,13,14,15]
	end,

	ok = nci_bci_actions:setup_iq_hw_if([{nofIqLinks, NofIqLinks},
										{logicalId, LogicalId},
										{expectedSigNo, ?ELIB_BC_SETUP_IQ_HW_IF_CFM}]),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

bci_sii_pre( State ) ->

	{ok, session_up} = coli:subscribe_state(?SHELL_COMMAND),
	{ok, session_up} = osegw:subscribe_state(?OSE_GW_DEAMON_1),

	nci_bci_states:set_state([{state, State}]),

	%% Connect to BCI interface
	ok = nci_bci_actions:conn_establish([]),

	%% Get Cap
	ct:pal("Action_1"),

	{ok, Received} = nci_bci_actions:get_capabilities_get([]),
	ct:pal("Received:~n~s", [osegw_lib:pretty_format(Received, nci_bci_dci)]).

%%------------------------------------------------------------------------------
%% $Id BCI_SII2
%%
%% $Header
%%
%%  State Starting, DP not loaded
%%
%% $Description
%%  Test setup IQ HW IF in state starting_lmc_not_loaded
%%
%% $Requirements
%%  CBD_DBC_BCI_FU:6:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  Ensure state is in starting_lmc_not_loaded
%%
%% $Action_1
%%  Send a GET_CAPABILITIES_REQ
%%
%% $Result_1
%% GET_CAPABILITIES_CFM is received with 5 capabilities:
%% for DULs cap,cap4,cap2,cap3,cap6
%% for DUS41 cap,cap4,cap5,cap3,cap7
%% - CAP_LOADING_SUPPORT
%% - CAP_COMMON_MMI_SUPPORT
%% - CAP_ETH_HW_IF_SUPPORT2
%% - CAP_CLIMATE_CONTROL_SUPPORT
%% - CAP_IQ_HW_IF_SUPPORT
%%
%% $Action_2
%%  Send a ELIB_BC_SETUP_IQ_HW_IF_REQ with parameters:
%%
%%  nofIqlLinks 9 for DULs or 8 for DUS41
%%
%%  list of logicalIds
%%
%% $Result_2
%%  A ELIB_BC_SETUP_IQ_HW_IF_REJ is received
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  2012-12-17, EJONUNA
%%
%% Revision history:
%%  2012-12-04, EEDAJA
%%    First version
%%
%%  2012-12-17, EEDAJA
%%    Review comments implemented
%%
%%------------------------------------------------------------------------------
bci_sii2() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_DBC_BCI_FU:6:C"},
				{slogan, "Test setup IQ HW IF in state starting, DP not loaded"}]}].

bci_sii2(_Config) ->
	ct:pal("bci_sii2"),

	bci_sii_pre( starting_lmc_not_loaded ),

	%% Setup IQ HW IF
	ct:pal("Action_2"),

	case nci_common_utils:get_du() of
		dus ->
			NofIqLinks = 8,
			LogicalId = [0,1,2,3,4,5,6,7];
		mRBS_lte -> %mRBS
			NofIqLinks = 8,
			LogicalId = [0,1,2,3,4,5,6,7];
		_ ->
			NofIqLinks = 9,
			LogicalId = [0,2,3,0,2,3,13,14,15]
	end,

	ok = nci_bci_actions:setup_iq_hw_if([{nofIqLinks, NofIqLinks},
										{logicalId, LogicalId},
										{expectedSigNo, ?ELIB_BC_SETUP_IQ_HW_IF_REJ},
										{errorCode, 1},
										{errorDescription, {regexp, "DP not loaded*"}}]),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id BCI_SII3
%%
%% $Header
%%  State Disabled
%%
%% $Description
%%  Test setup IQ HW IF in state disabled
%%
%% $Requirements
%%  CBD_DBC_BCI_FU:6:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  Ensure state is in disabled
%%
%% $Action_1
%%  Send a GET_CAPABILITIES_REQ
%%
%% $Result_1
%% GET_CAPABILITIES_CFM is received with 5 capabilities:
%% for DULs cap,cap4,cap2,cap3,cap6
%% for DUS41 cap,cap4,cap5,cap3,cap7
%% - CAP_LOADING_SUPPORT
%% - CAP_COMMON_MMI_SUPPORT
%% - CAP_ETH_HW_IF_SUPPORT2
%% - CAP_CLIMATE_CONTROL_SUPPORT
%% - CAP_IQ_HW_IF_SUPPORT
%%
%% $Action_2
%%  Send a ELIB_BC_SETUP_IQ_HW_IF_REQ with parameters:
%%
%%  nofIqlLinks 9 for DULs or 8 for DUS41
%%
%%  list of logicalIds
%%
%% $Result_2
%%  A ELIB_BC_SETUP_IQ_HW_IF_REJ is received
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  2012-12-17, EJONUNA
%%
%% Revision history:
%%  2012-12-04, EEDAJA
%%    First version
%%
%%  2012-12-17, EEDAJA
%%    Review comments implemented
%%
%%------------------------------------------------------------------------------
bci_sii3() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_DBC_BCI_FU:6:C"},
				{slogan, "Test setup IQ HW IF in state disabled"}]}].

bci_sii3(_Config) ->
	ct:pal("bci_sii3"),

	bci_sii_pre( disabled ),

	%% Setup IQ HW IF
	ct:pal("Action_2"),

	case nci_common_utils:get_du() of
		dus ->
			NofIqLinks = 8,
			LogicalId = [0,1,2,3,4,5,6,7];
		mRBS_lte ->
			NofIqLinks = 8,
			LogicalId = [0,1,2,3,4,5,6,7];
		_ ->
			NofIqLinks = 9,
			LogicalId = [0,2,3,0,2,3,13,14,15]
	end,

	ok = nci_bci_actions:setup_iq_hw_if([{nofIqLinks, NofIqLinks},
										{logicalId, LogicalId},
										{expectedSigNo, ?ELIB_BC_SETUP_IQ_HW_IF_REJ},
										{errorCode, 1},
										{errorDescription, {regexp, "Invalid O&M state*"}}]),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id BCI_SII4
%%
%% $Header
%%  Setup only five logical IQ links
%%
%% $Description
%%  Test setup IQ HW IF in with 5 logical links
%%
%% $Requirements
%%  CBD_DBC_BCI_FU:6:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  Ensure state is in operational
%%
%% $Action_1
%%  Send a GET_CAPABILITIES_REQ
%%
%% $Result_1
%% GET_CAPABILITIES_CFM is received with 5 capabilities:
%% for DULs cap,cap4,cap2,cap3,cap6
%% for DUS41 cap,cap4,cap5,cap3,cap7
%% - CAP_LOADING_SUPPORT
%% - CAP_COMMON_MMI_SUPPORT
%% - CAP_ETH_HW_IF_SUPPORT2
%% - CAP_CLIMATE_CONTROL_SUPPORT
%% - CAP_IQ_HW_IF_SUPPORT
%%
%% $Action_2
%%  Send a ELIB_BC_SETUP_IQ_HW_IF_REQ with parameters:
%%
%%  nofIqlLinks 5
%%
%%  list of logicalIds
%%
%% $Result_2
%%  A ELIB_BC_SETUP_IQ_HW_IF_CFM is received
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  2012-12-17, EJONUNA
%%
%% Revision history:
%%  2012-12-04, EEDAJA
%%    First version
%%
%%  2012-12-17, EEDAJA
%%    Review comments implemented
%%
%%------------------------------------------------------------------------------
bci_sii4() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_DBC_BCI_FU:6:C"},
				{slogan, "Test setup IQ HW IF with 5 logical links"}]}].

bci_sii4(_Config) ->
	ct:pal("bci_sii4"),

	bci_sii_pre( operational ),

	%% Setup IQ HW IF
	ct:pal("Action_2"),

	case nci_common_utils:get_du() of
		dus ->
			NofIqLinks = 5,
			LogicalId = [0,2,5,6,7];
		mRBS_lte -> 
			NofIqLinks = 5,
			LogicalId = [0,2,5,6,7];
		_ ->
			NofIqLinks = 5,
			LogicalId = [0,2,3,13,15]
	end,

	ok = nci_bci_actions:setup_iq_hw_if([{nofIqLinks, NofIqLinks},
										{logicalId, LogicalId},
										{expectedSigNo, ?ELIB_BC_SETUP_IQ_HW_IF_CFM}]),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id BCI_SII5
%%
%% $Header
%%  Too many logical links
%%
%% $Description
%%  Test setup IQ HW IF with too many logical links
%%
%% $Requirements
%%  CBD_DBC_BCI_FU:6:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  Ensure state is in operational
%%
%% $Action_1
%%  Send a GET_CAPABILITIES_REQ
%%
%% $Result_1
%% GET_CAPABILITIES_CFM is received with 5 capabilities:
%% for DULs cap,cap4,cap2,cap3,cap6
%% for DUS41 cap,cap4,cap5,cap3,cap7
%% - CAP_LOADING_SUPPORT
%% - CAP_COMMON_MMI_SUPPORT
%% - CAP_ETH_HW_IF_SUPPORT2
%% - CAP_CLIMATE_CONTROL_SUPPORT
%% - CAP_IQ_HW_IF_SUPPORT
%%
%% $Action_2
%%  Send a ELIB_BC_SETUP_IQ_HW_IF_REQ with parameters:
%%
%%  nofIqlLinks 10
%%
%%  list of logicalIds
%%
%% $Result_2
%%  A ELIB_BC_SETUP_IQ_HW_IF_REJ is received
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  2012-12-17, EJONUNA
%%
%% Revision history:
%%  2012-12-04, EEDAJA
%%    First version
%%
%%  2012-12-17, EEDAJA
%%    Review comments implemented
%%
%%------------------------------------------------------------------------------
bci_sii5() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_DBC_BCI_FU:6:C"},
				{slogan, "Test setup IQ HW IF with too many logical links"}]}].

bci_sii5(_Config) ->
	ct:pal("bci_sii5"),

	bci_sii_pre( operational ),

	%% Setup IQ HW IF
	ct:pal("Action_2"),

	case nci_common_utils:get_du() of
		dus ->
			NofIqLinks = 10,
			LogicalId = [0,1,2,3,4,5,6,7,8,9];
		mRBS_lte ->
			NofIqLinks = 10,
			LogicalId = [0,1,2,3,4,5,6,7,8,9];
		_ ->
			NofIqLinks = 10,
			LogicalId = [0,2,3,0,2,3,13,14,15,16]
	end,

	ok = nci_bci_actions:setup_iq_hw_if([{nofIqLinks, NofIqLinks},
										{logicalId, LogicalId},
										{expectedSigNo, ?ELIB_BC_SETUP_IQ_HW_IF_REJ},
										{errorCode, 1},
										{errorDescription, {regexp, "Too many logical links*"}}]),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id BCI_SII6
%%
%% $Header
%%  State Starting
%%
%% $Description
%%  Test setup IQ HW IF, unknown LogicalId
%%
%% $Requirements
%%  CBD_DBC_BCI_FU:6:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  Ensure state is in operational
%%
%% $Action_1
%%  Send a GET_CAPABILITIES_REQ
%%
%% $Result_1
%% GET_CAPABILITIES_CFM is received with 5 capabilities:
%% for DULs cap,cap4,cap2,cap3,cap6
%% for DUS41 cap,cap4,cap5,cap3,cap7
%% - CAP_LOADING_SUPPORT
%% - CAP_COMMON_MMI_SUPPORT
%% - CAP_ETH_HW_IF_SUPPORT2
%% - CAP_CLIMATE_CONTROL_SUPPORT
%% - CAP_IQ_HW_IF_SUPPORT
%%
%% $Action_2
%%  Send a ELIB_BC_SETUP_IQ_HW_IF_REQ with parameters:
%%
%%  nofIqlLinks 1
%%
%%  logicalId = 16
%%
%% $Result_2
%%  A ELIB_BC_SETUP_IQ_HW_IF_REJ is received
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  2012-12-17, EJONUNA
%%
%% Revision history:
%%  2012-12-04, EEDAJA
%%    First version
%%
%%  2012-12-17, EEDAJA
%%    Review comments implemented
%%
%%------------------------------------------------------------------------------
bci_sii6() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_DBC_BCI_FU:6:C"},
				{slogan, "Test setup IQ HW IFunknown LogicalId"}]}].

bci_sii6(_Config) ->

	ct:pal("bci_sii6"),

	bci_sii_pre( operational ),

	%% Setup IQ HW IF
	ct:pal("Action_2"),

	NofIqLinks = 1,
	LogicalId = [16],

	ok = nci_bci_actions:setup_iq_hw_if([{nofIqLinks, NofIqLinks},
										{logicalId, LogicalId},
										{expectedSigNo, ?ELIB_BC_SETUP_IQ_HW_IF_REJ},
										{errorCode, 1},
										{errorDescription, {regexp, "Unknown logical link ID*"}}]),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%##############################################################################
%% $ChapterH2 Setting up the Ethernet
%%
%% DU BC shall set up an Ethernet - XIO connection upon a signal request. In the setup request three values shall be given. - numOfEthHwifMacAddresses , How many mac addresses that shall be used. - ethHwifMacAddressParam , Mac address that shall be used. - Valid range for addressFilterMask is 0x0000 - 0x3F00
%%
%% $End
%%##############################################################################

%%------------------------------------------------------------------------------
%% $Id BCI_ES1
%%
%% $Header
%%  Ethernet-XIO connection:State Starting
%%
%% $Description
%%  Test Ethernet-XIO connection setup in starting state
%%
%% $Requirements
%%  CBD_DBC_BCI_FU:2:A
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  Ensure state is in starting
%%
%% $Action_1
%%  Send a ETH_SETUP_HW_IF_REQ with parameters:
%%  * numOfEthHwifMacAddresses = 1
%%  * ethHwifMacAddressParam = [0,30,223,200,190,50]
%%  * addressFilterMask = 30
%%
%% $Result_1
%%  A ETH_SETUP_HW_IF_REJ is received with parameters:
%%  * errorCode = UNSUCCESSFUL
%%  * errorDescription = "Invalid O&M state"
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-05-30, QMAGSED
%%    First version
%%  2013-09-12, ehklopc
%%    fix header and slogan information
%%
%%------------------------------------------------------------------------------
bci_es1() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_DBC_BCI_FU:2:A"},
				{slogan, "Ethernet-XIO connection:State Starting"}]}].

bci_es1(_Config) ->
	ct:pal("bci_es1"),

	{ok, session_up} = coli:subscribe_state(?SHELL_COMMAND),
	{ok, session_up} = osegw:subscribe_state(?OSE_GW_DEAMON_1),

	nci_bci_states:set_state([{state, starting_lmc_loaded}]),

	ElibBcEthHwifMacAddress = [#'ElibBcEthHwifMacAddressParamS'{snid = 1,
									padding0 = 0,
									macAddress = [0,30,223,200,190,50],
									padding1 = 0}],

	ct:pal("Action_1 & Result_1"),
	%% Setup HW IF
	ok = nci_bci_actions:eth_setup_hw_if([{numOfEthHwifMacAddresses, 1},
						  {ethHwifMacAddressParam, ElibBcEthHwifMacAddress},
						  {addressFilterMask, 32},
						  {expectedSigNo, ?ELIB_BC_ETH_SETUP_HW_IF_REJ},
						  {errorCode, 1},
						  {errorDescription, {regexp, "Invalid O&M state*"}}]),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).
%%------------------------------------------------------------------------------
%% $Id BCI_ES2
%%
%% $Header
%%  Ethernet-XIO connection:State Operational
%%
%% $Description
%%  To verify Ethernet-XIO connection setup when state is in operational
%%
%% $Requirements
%%  CBD_DBC_BCI_FU:2:A
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  Ensure state is in operational
%%
%% $Action_1
%%  Send a ETH_SETUP_HW_IF_REQ with parameters:
%%  * numOfEthHwifMacAddresses = 1
%%  * ethHwifMacAddressParam = [0,30,223,200,190,50]
%%  * addressFilterMask = 30
%%
%% $Result_1
%%  A ETH_SETUP_HW_IF_CFM is received
%%
%% $Action_2
%%  check BciEthSetupHwIf Config Registers
%% 
%% $Result_2
%%  Registers are checked successfully
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-05-30, QMAGSED
%%    First version
%%  2013-09-22, ehklopc
%%    add function to read registers
%%
%%------------------------------------------------------------------------------
bci_es2() ->
	[{userdata,[{wp, ""},
				{requirement, "CBD_DBC_BCI_FU:2:A"},
				{slogan, "Ethernet-XIO connection:State Operational"}]}].

bci_es2(_Config) ->
	ct:pal("bci_es2"),

	{ok, session_up} = coli:subscribe_state(?SHELL_COMMAND),
	{ok, session_up} = osegw:subscribe_state(?OSE_GW_DEAMON_1),

	nci_bci_states:set_state([{state, operational}]),

	ElibBcEthHwifMacAddress = [#'ElibBcEthHwifMacAddressParamS'{snid = 1,
									padding0 = 0,
									macAddress = [0,30,223,200,190,50],
									padding1 = 0}],

	ct:pal("Action_1 & Result_1"),
	%% Setup HW IF
	ok = nci_bci_actions:eth_setup_hw_if([{numOfEthHwifMacAddresses, 1},
						  {ethHwifMacAddressParam, ElibBcEthHwifMacAddress},
						  {addressFilterMask, 30},
						  {expectedSigNo, ?ELIB_BC_ETH_SETUP_HW_IF_CFM}]),

	ct:pal("Action_2"),
	bciEthsetupCheckRegisters(1,ElibBcEthHwifMacAddress,30),

	ct:pal("Result_2"),
	ct:pal("the registers are checked successfully"),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id BCI_ES3
%%
%% $Header
%%  Ethernet-XIO connection:State Disabled
%%
%% $Description
%%  To verify Ethernet-XIO connection setup when state is in disabled
%%
%% $Requirements
%%  CBD_DBC_BCI_FU:2:A
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  Ensure state is in disabled
%%
%% $Action_1
%%  Send a BC_ETH_SETUP_HW_IF_REQ with parameters:
%%  * numOfEthHwifMacAddresses = 1
%%  * ethHwifMacAddressParam = from get_mac
%%  * addressFilterMask = 63
%%
%% $Result_1
%%  A BC_ETH_SETUP_HW_IF_REJ is receivedw ith parameters:
%%  * errorCode = UNSUCCESSFUL
%%  * errorDescription = "Invalid O&M state"
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-05-30, QMAGSED
%%    First version
%%  2013-09-12, ehklopc
%%    fix header and slogan information
%%
%%------------------------------------------------------------------------------
bci_es3() ->
	[{userdata,[{wp, ""}, {requirement, "CBD_DBC_BCI_FU:2:A"},{slogan, "Ethernet-XIO connection:State Disabled"}]}].

bci_es3(_Config) ->
	ct:pal("bci_es3"),

	{ok, session_up} = coli:subscribe_state(?SHELL_COMMAND),
	{ok, session_up} = osegw:subscribe_state(?OSE_GW_DEAMON_1),

	nci_bci_states:set_state([{state, starting_lmc_loaded}]),

	%% Disable operations
	ok = nci_bci_actions:disable_operation([]),

	ElibBcEthHwifMacAddress = [#'ElibBcEthHwifMacAddressParamS'{snid = 1,
									padding0 = 0,
									macAddress = [0,30,223,200,190,50],
									padding1 = 0}],

	ct:pal("Action_1 & Result_1"),
	%% Setup HW IF
	ok = nci_bci_actions:eth_setup_hw_if([{numOfEthHwifMacAddresses, 1},
					  {ethHwifMacAddressParam, ElibBcEthHwifMacAddress},
					  {addressFilterMask, 63},
					  {expectedSigNo, ?ELIB_BC_ETH_SETUP_HW_IF_REJ},
					  {errorCode, 1},
					  {errorDescription, {regexp, "Invalid O&M state*"}}]),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id BCI_ES4
%%
%% $Header
%%  Ethernet-XIO connection:Too many addresses
%%
%% $Description
%%  To verify Ethernet-XIO connection setup with too many addresses
%%
%% $Requirements
%%  CBD_DBC_BCI_FU:2:A
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  Ensure state is operational
%%
%% $Action_1
%%  Send a ETH_SETUP_HW_IF_REQ with parameters:
%%  * numOfEthHwifMacAddresses = 5
%%  * ethHwifMacAddressParam = [0,1,237,252,119,127], [0,1,237,252,119,128], [0,1,237,252,119,129], [0,1,237,252,119,130], [0,1,237,252,119,131]
%%  * addressFilterMask = 18
%%
%% $Result_1
%%  A ETH_SETUP_HW_IF_REJ is received with parameters:
%%  * errorCode = UNSUCCESSFUL
%%  * errorDescription = "Too many MAC addresses"
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-05-30, QMAGSED
%%    First version
%%  2013-09-12, ehklopc
%%    fix header and slogan information
%%
%%------------------------------------------------------------------------------
bci_es4() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_DBC_BCI_FU:2:A"},
				{slogan, "Ethernet-XIO connection:Too many addresses"}]}].

bci_es4(_Config) ->
	ct:pal("bci_es4"),

	{ok, session_up} = coli:subscribe_state(?SHELL_COMMAND),
	{ok, session_up} = osegw:subscribe_state(?OSE_GW_DEAMON_1),

	nci_bci_states:set_state([{state, operational}]),

	ElibBcEthHwifMacAddress = [ #'ElibBcEthHwifMacAddressParamS'{snid = 1,
									padding0 = 0,
									macAddress = [0,1,237,252,119,127],
									padding1 = 0},
								#'ElibBcEthHwifMacAddressParamS'{snid = 2,
									padding0 = 0,
									macAddress = [0,1,237,252,119,128],
									padding1 = 0},
								#'ElibBcEthHwifMacAddressParamS'{snid = 3,
									padding0 = 0,
									macAddress = [0,1,237,252,119,129],
									padding1 = 0},
								#'ElibBcEthHwifMacAddressParamS'{snid = 4,
									padding0 = 0,
									macAddress = [0,1,237,252,119,130],
									padding1 = 0}],

	ct:pal("Action_1 & Result_1"),
	case nci_common_utils:get_du() of
		dul -> % DUL20
			%% Setup HW IF
			ok = nci_bci_actions:eth_setup_hw_if([{numOfEthHwifMacAddresses, 5},
					  {ethHwifMacAddressParam, ElibBcEthHwifMacAddress},
					  {addressFilterMask, 18},
					  {expectedSigNo, ?ELIB_BC_ETH_SETUP_HW_IF_REJ},
					  {errorCode, 1},
					  {errorDescription, {regexp, "Too many MAC addresses*"}}]);
		_ -> % DUS41 and mRBS
			%% Setup HW IF
			ok = nci_bci_actions:eth_setup_hw_if([{numOfEthHwifMacAddresses, 5},
					  {ethHwifMacAddressParam, ElibBcEthHwifMacAddress},
					  {addressFilterMask, 0},
					  {expectedSigNo, ?ELIB_BC_ETH_SETUP_HW_IF_REJ},
					  {errorCode, 1},
					  {errorDescription, {regexp, "Too many MAC addresses*"}}])
	end,

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id BCI_ES5
%%
%% $Header
%%  Ethernet-XIO connection:No address
%%
%% $Description
%%  To verify Ethernet-XIO connection setup with no mac-address
%%
%% $Requirements
%%  CBD_DBC_BCI_FU:2:A
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  Ensure state is operational
%%
%% $Action_1
%%  Send a ETH_SETUP_HW_IF_REQ with parameters:
%%  * numOfEthHwifMacAddresses = 0
%%  * ethHwifMacAddressParam = ""
%%  * addressFilterMask = 17
%%
%% $Result_1
%%  A ETH_SETUP_HW_IF_CFM is received
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-05-30, QMAGSED
%%    First version
%%  2013-09-12, ehklopc
%%    fix header and slogan information
%%
%%------------------------------------------------------------------------------
bci_es5() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_DBC_BCI_FU:2:A"},
				{slogan, "Ethernet-XIO connection:No address"}]}].

bci_es5(_Config) ->
	ct:pal("bci_es5"),

	{ok, session_up} = coli:subscribe_state(?SHELL_COMMAND),
	{ok, session_up} = osegw:subscribe_state(?OSE_GW_DEAMON_1),

	nci_bci_states:set_state([{state, operational}]),

	ElibBcEthHwifMacAddress = [],

	ct:pal("Action_1 & Result_1"),
	%% Setup HW IF
	ok = nci_bci_actions:eth_setup_hw_if([{numOfEthHwifMacAddresses, 0},
					  {ethHwifMacAddressParam, ElibBcEthHwifMacAddress},
					  {addressFilterMask, 17},
					  {expectedSigNo, ?ELIB_BC_ETH_SETUP_HW_IF_CFM}]),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).
%%------------------------------------------------------------------------------
%% $Id BCI_ES6
%%
%% $Header
%%  Ethernet-XIO connection:Re-configure
%%
%% $Description
%%  To verify Ethernet-XIO connection setup and then reconfigure connection
%%
%% $Requirements
%%  CBD_DBC_BCI_FU:2:A
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  Ensure state is operational
%%
%% $Action_1
%%  Send a ETH_SETUP_HW_IF_REQ with parameters:
%%  * numOfEthHwifMacAddresses = 1
%%  * ethHwifMacAddressParam = [0,1,237,252,119,127]
%%  * addressFilterMask = 512
%%
%% $Result_1
%%  A ETH_SETUP_HW_IF_CFM is received
%%
%% $Action_2
%%  check BciEthSetupHwIf Config Registers
%%
%% $Result_2
%%  Registers are checked successfully
%%
%% $Action_3
%%  Send a new ETH_SETUP_HW_IF_REQ with parameters:
%%  * numOfEthHwifMacAddresses = 1
%%  * ethHwifMacAddressParam = 8704
%%  * addressFilterMask = [0,1,237,252,119,242]
%%
%% $Result_3
%%  A ETH_SETUP_HW_IF_CFM is received
%%
%% $Action_4
%%  check BciEthSetupHwIf Config Registers
%%
%% $Result_4
%%  Registers are checked successfully
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-05-30, QMAGSED
%%    First version
%%  2013-09-22, ehklopc
%%    add function to read registers
%%
%%------------------------------------------------------------------------------
bci_es6() ->
	[{userdata,[{wp, ""},
				{requirement, "CBD_DBC_BCI_FU:2:A"},
				{slogan, "Ethernet-XIO connection:Re-configure"}]}].

bci_es6(_Config) ->
	ct:pal("bci_es6"),

	{ok, session_up} = coli:subscribe_state(?SHELL_COMMAND),
	{ok, session_up} = osegw:subscribe_state(?OSE_GW_DEAMON_1),

	nci_bci_states:set_state([{state, operational}]),

	ElibBcEthHwifMacAddress = [#'ElibBcEthHwifMacAddressParamS'{snid = 1,
									padding0 = 0,
									macAddress = [0,1,237,252,119,127],
									padding1 = 0}],

	ElibBcEthHwifMacAddress2 = [#'ElibBcEthHwifMacAddressParamS'{snid = 1,
									 padding0 = 0,
									 macAddress = [0,1,237,252,119,242],
									 padding1 = 0}],

	ct:pal("Action_1 & Result_1"),
	%% Setup HW IF
	ok = nci_bci_actions:eth_setup_hw_if([{numOfEthHwifMacAddresses, 1},
					  {ethHwifMacAddressParam, ElibBcEthHwifMacAddress},
					  {addressFilterMask, 512},
					  {expectedSigNo, ?ELIB_BC_ETH_SETUP_HW_IF_CFM}]),

	ct:pal("Action_2"),
	bciEthsetupCheckRegisters(1,ElibBcEthHwifMacAddress,512),

	ct:pal("Result_2"),
	ct:pal("the registers are checked successfully"),

	ct:pal("Action_3 & Result3"),
	%% Setup HW IF
	ok = nci_bci_actions:eth_setup_hw_if([{numOfEthHwifMacAddresses, 1},
					  {ethHwifMacAddressParam, ElibBcEthHwifMacAddress2},
					  {addressFilterMask, 8704},
					  {expectedSigNo, ?ELIB_BC_ETH_SETUP_HW_IF_CFM}]),

	ct:pal("Action_4"),
	bciEthsetupCheckRegisters(1,ElibBcEthHwifMacAddress2,8704),

	ct:pal("Result_4"),
	ct:pal("the registers are checked successfully"),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id BCI_ES7
%%
%% $Header
%%  Ethernet-XIO connection:Max nr of addresses
%%
%% $Description
%%  To verify Ethernet-XIO connection setup with max numbers of addresses
%%
%% $Requirements
%%  CBD_DBC_BCI_FU:2:A
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  Ensure state is operational
%%
%% $Action_1
%%  Send a ETH_SETUP_HW_IF_REQ with parameters:
%%  * numOfEthHwifMacAddresses = 4
%%  * ethHwifMacAddressParam = [0,1,237,2,119,127], [0,1,237,5,119,128], [0,1,237,20,119,129], [0,1,237,48,119,130]
%%  * addressFilterMask = 0
%%
%% $Result_1
%%  A ETH_SETUP_HW_IF_CFM is received
%%
%% $Action_2
%%  check BciEthSetupHwIf Config Registers
%%
%% $Result_2
%%  Registers are checked successfully
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-05-30, QMAGSED
%%    First version
%%  2013-09-22, ehklopc
%%    add function to read registers
%%
%%------------------------------------------------------------------------------
bci_es7() ->
	[{userdata,[{wp, ""},
				{requirement, "CBD_DBC_BCI_FU:2:A"},
				{slogan, "Ethernet-XIO connection:Max nr of addresses"}]}].

bci_es7(_Config) ->
	ct:pal("bci_es7"),

	{ok, session_up} = coli:subscribe_state(?SHELL_COMMAND),
	{ok, session_up} = osegw:subscribe_state(?OSE_GW_DEAMON_1),

	nci_bci_states:set_state([{state, operational}]),

	ElibBcEthHwifMacAddress = [#'ElibBcEthHwifMacAddressParamS'{snid = 1,
									padding0 = 0,
									macAddress = [0,1,237,2,119,127],
									padding1 = 0},
				   #'ElibBcEthHwifMacAddressParamS'{snid = 2,
									padding0 = 0,
									macAddress = [0,1,237,5,119,128],
									padding1 = 0},
				   #'ElibBcEthHwifMacAddressParamS'{snid = 3,
									padding0 = 0,
									macAddress = [0,1,237,20,119,129],
									padding1 = 0},
				   #'ElibBcEthHwifMacAddressParamS'{snid = 4,
									padding0 = 0,
									macAddress = [0,1,237,48,119,130],
									padding1 = 0}],

	ct:pal("Action_1 & Result_1"),
	%% Setup HW IF
	ok = nci_bci_actions:eth_setup_hw_if([{numOfEthHwifMacAddresses, 4},
								{ethHwifMacAddressParam, ElibBcEthHwifMacAddress},
								{addressFilterMask, 0},
								{expectedSigNo, ?ELIB_BC_ETH_SETUP_HW_IF_CFM}]),

	ct:pal("Action_2"),
	bciEthsetupCheckRegisters(4,ElibBcEthHwifMacAddress,0),

	ct:pal("Result_2"),
	ct:pal("the registers are checked successfully"),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id BCI_ES8
%%
%% $Header
%%  Ethernet-XIO connection:Step through every ETH_LINK_ENABLE register
%%
%% $Description
%%  To verify Ethernet-XIO connection setup with step through every ETH_LINK_ENABLE register for 1,2,3,4 macaddresses
%%
%% $Requirements
%%  CBD_DBC_BCI_FU:2:A
%%
%% $External References 
%%  -
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  Ensure state is operational
%%
%% $Action_1
%%  Send a ETH_SETUP_HW_IF_REQ with parameters:
%%  * numOfEthHwifMacAddresses = 1
%%  * ethHwifMacAddressParam = [0,1,237,2,119,127]
%%  * addressFilterMask = 0
%%
%% $Result_1
%%  A ETH_SETUP_HW_IF_CFM is received
%%
%% $Action_2
%%  check BciEthSetupHwIf Config Registers
%%
%% $Result_2
%%  Registers are checked successfully
%%
%% $Action_3
%%  Send a ETH_SETUP_HW_IF_REQ with parameters:
%%  * numOfEthHwifMacAddresses = 2
%%  * ethHwifMacAddressParam = [0,1,237,2,119,127], [0,1,237,5,119,128]
%%  * addressFilterMask = 0
%%
%% $Result_3
%%  A ETH_SETUP_HW_IF_CFM is received
%%
%% $Action_4
%%  check BciEthSetupHwIf Config Registers
%%
%% $Result_4
%%  Registers are checked successfully
%%
%% $Action_5
%%  Send a ETH_SETUP_HW_IF_REQ with parameters:
%%  * numOfEthHwifMacAddresses = 3
%%  * ethHwifMacAddressParam = [0,1,237,2,119,127], [0,1,237,5,119,128], [0,1,237,20,119,129]
%%  * addressFilterMask = 0
%%
%% $Result_5
%%  A ETH_SETUP_HW_IF_CFM is received
%%
%% $Action_6
%%  check BciEthSetupHwIf Config Registers
%%
%% $Result_6
%%  Registers are checked successfully
%%
%% $Action_7
%%  Send a ETH_SETUP_HW_IF_REQ with parameters:
%%  * numOfEthHwifMacAddresses = 4
%%  * ethHwifMacAddressParam = [0,1,237,2,119,127], [0,1,237,5,119,128], [0,1,237,20,119,129], [0,1,237,48,119,130]
%%  * addressFilterMask = 0
%%
%% $Result_7
%%  A ETH_SETUP_HW_IF_CFM is received
%%
%% $Action_8
%%  check BciEthSetupHwIf Config Registers
%%
%% $Result_8
%%  Registers are checked successfully
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-05-30, QMAGSED
%%    First version
%%  2013-09-22, ehklopc
%%    add function to read registers
%%
%%------------------------------------------------------------------------------
bci_es8() ->
	[{userdata,[{wp, ""},
				{requirement, "CBD_DBC_BCI_FU:2:A"},
				{slogan, "Ethernet-XIO connection:Step through every ETH_LINK_ENABLE register"}]}].

bci_es8(_Config) ->
	ct:pal("bci_es8"),

	{ok, session_up} = coli:subscribe_state(?SHELL_COMMAND),
	{ok, session_up} = osegw:subscribe_state(?OSE_GW_DEAMON_1),

	nci_bci_states:set_state([{state, operational}]),

	ElibBcEthHwifMacAddress = [#'ElibBcEthHwifMacAddressParamS'{snid = 1,
									padding0 = 0,
									macAddress = [0,1,237,2,119,127],
									padding1 = 0}],

	ElibBcEthHwifMacAddress2 = ElibBcEthHwifMacAddress ++
				   [#'ElibBcEthHwifMacAddressParamS'{snid = 2,
									padding0 = 0,
									macAddress = [0,1,237,5,119,128],
									padding1 = 0}],

	ElibBcEthHwifMacAddress3 = ElibBcEthHwifMacAddress2 ++
				   [#'ElibBcEthHwifMacAddressParamS'{snid = 3,
									padding0 = 0,
									macAddress = [0,1,237,20,119,129],
									padding1 = 0}],

	ElibBcEthHwifMacAddress4 = ElibBcEthHwifMacAddress3 ++
				   [#'ElibBcEthHwifMacAddressParamS'{snid = 4,
									padding0 = 0,
									macAddress = [0,1,237,48,119,130],
									padding1 = 0}],

	ct:pal("Action_1 & Result_1"),
	%% Setup HW IF
	ok = nci_bci_actions:eth_setup_hw_if([{numOfEthHwifMacAddresses, 1},
					  {ethHwifMacAddressParam, ElibBcEthHwifMacAddress},
					  {addressFilterMask, 0},
					  {expectedSigNo, ?ELIB_BC_ETH_SETUP_HW_IF_CFM}]),

	ct:pal("Action_2"),
	bciEthsetupCheckRegisters(1,ElibBcEthHwifMacAddress,0),

	ct:pal("Action_3 & Result_3"),
	%% Setup HW IF
	ok = nci_bci_actions:eth_setup_hw_if([{numOfEthHwifMacAddresses, 2},
					  {ethHwifMacAddressParam, ElibBcEthHwifMacAddress2},
					  {addressFilterMask, 0},
					  {expectedSigNo, ?ELIB_BC_ETH_SETUP_HW_IF_CFM}]),

	ct:pal("Action_4"),
	bciEthsetupCheckRegisters(2,ElibBcEthHwifMacAddress2,0),

	ct:pal("Result_4"),
	ct:pal("the registers are checked successfully"),

	ct:pal("Action_5 & Result_5"),
	%% Setup HW IF
	ok = nci_bci_actions:eth_setup_hw_if([{numOfEthHwifMacAddresses, 3},
					  {ethHwifMacAddressParam, ElibBcEthHwifMacAddress3},
					  {addressFilterMask, 0},
					  {expectedSigNo, ?ELIB_BC_ETH_SETUP_HW_IF_CFM}]),

	ct:pal("Action_6"),
	bciEthsetupCheckRegisters(3,ElibBcEthHwifMacAddress3,0),

	ct:pal("Result_6"),
	ct:pal("the registers are checked successfully"),

	ct:pal("Action_7 & Result_7"),
	%% Setup HW IF
	ok = nci_bci_actions:eth_setup_hw_if([{numOfEthHwifMacAddresses, 4},
					  {ethHwifMacAddressParam, ElibBcEthHwifMacAddress4},
					  {addressFilterMask, 0},
					  {expectedSigNo, ?ELIB_BC_ETH_SETUP_HW_IF_CFM}]),

	ct:pal("Action_8"),
	bciEthsetupCheckRegisters(4,ElibBcEthHwifMacAddress4,0),

	ct:pal("Result_8"),
	ct:pal("the registers are checked successfully"),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).
%%------------------------------------------------------------------------------
%% $Id BCI_ES9
%%
%% $Header
%%  Ethernet-XIO connection:Reset the MAC config table
%%
%% $Description
%%  To verify Ethernet-XIO connection setup with snid = 0, resets the MAC config table.
%%
%% $Requirements
%%  CBD_DBC_BCI_FU:4:A
%%
%% $External References
%%  -
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  Ensure state is operational
%%
%% $Action_1
%%  Send a ETH_SETUP_HW_IF_REQ with parameters:
%%  * numOfEthHwifMacAddresses = 1
%%  * ethHwifMacAddressParam = [0,1,237,101,119,127]
%%
%% $Result_1
%%  A ETH_SETUP_HW_IF_CFM is received
%%
%% $Action_2
%%  check BciEthSetupHwIf Config Registers
%%
%% $Result_2
%%  Registers are checked successfully
%%
%% $Action_3
%%  Send a ETH_SETUP_HW_IF_REQ with parameters:
%%  * numOfEthHwifMacAddresses = 1
%%  * snid=0
%%  * ethHwifMacAddressParam = [0,1,237,2,119,127]
%%
%% $Result_3
%%  A ETH_SETUP_HW_IF_CFM is received
%%
%% $Action_4
%%  check BciEthSetupHwIf Config Registers(only valid for DUS41 and mRBS)
%%
%% $Result_4
%%  Registers are checked successfully
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-05-30, QMAGSED
%%    First version
%%  2013-09-22, ehklopc
%%    add function to read registers
%%
%%------------------------------------------------------------------------------
bci_es9() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_DBC_BCI_FU:4:A"},
				{slogan, "Ethernet-XIO connection:Reset the MAC config table"}]}].

bci_es9(_Config) ->
	ct:pal("bci_es9"),

	{ok, session_up} = coli:subscribe_state(?SHELL_COMMAND),
	{ok, session_up} = osegw:subscribe_state(?OSE_GW_DEAMON_1),

	nci_bci_states:set_state([{state, operational}]),

	ElibBcEthHwifMacAddress = [#'ElibBcEthHwifMacAddressParamS'{snid = 1,
									padding0 = 0,
									macAddress = [0,1,237,101,119,127],
									padding1 = 0}],

	ElibBcEthHwifMacAddress2 = [#'ElibBcEthHwifMacAddressParamS'{snid = 0,
									padding0 = 0,
									macAddress = [0,1,237,2,119,127],
									padding1 = 0}],

	ct:pal("Action_1 & Result_1"),
	%% Setup HW IF
	ok = nci_bci_actions:eth_setup_hw_if([{numOfEthHwifMacAddresses, 1},
					  {ethHwifMacAddressParam, ElibBcEthHwifMacAddress},
					  {addressFilterMask, 0},
					  {expectedSigNo, ?ELIB_BC_ETH_SETUP_HW_IF_CFM}]),

	ct:pal("Action_2"),
	bciEthsetupCheckRegisters(1,ElibBcEthHwifMacAddress,0),

	ct:pal("Result_2"),
	ct:pal("the registers are checked successfully"),

	ct:pal("Action_3 & Result_3"),
	%% Setup HW IF
	ok = nci_bci_actions:eth_setup_hw_if([{numOfEthHwifMacAddresses, 1},
					  {ethHwifMacAddressParam, ElibBcEthHwifMacAddress2},
					  {addressFilterMask, 0},
					  {expectedSigNo, ?ELIB_BC_ETH_SETUP_HW_IF_CFM}]),

	ct:pal("Action_4"),
	case nci_common_utils:get_du() of
		dul -> 
			 ok;

		_ -> % dus and mRBS_lte
			bciEthsetupCheckRegisters_DUXI([{numOfEthHwifMacAddresses, 1},
						  {ethHwifMacAddressParam, ElibBcEthHwifMacAddress2},
						  {addressFilterMask, 0}]),
			ct:pal("Result_4"),
			ct:pal("the registers are checked successfully")
	end,

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

bciEthsetupCheckRegisters(Numofaddr,EthHwifMacAddrPar,AddrFilMask)->
	case nci_common_utils:get_du() of
		dul -> 
			bciEthsetupCheckRegisters_GIC([{numOfEthHwifMacAddresses, Numofaddr},
						  {ethHwifMacAddressParam, EthHwifMacAddrPar},
						  {addressFilterMask,AddrFilMask}]);

		_ -> %mRBS and DUS41
			bciEthsetupCheckRegisters_DUXI([{numOfEthHwifMacAddresses, Numofaddr},
						  {ethHwifMacAddressParam, EthHwifMacAddrPar},
						  {addressFilterMask,AddrFilMask}])
	end.

bciEthsetupCheckRegisters_GIC(Parameters) ->
	% The reference is:User Reference for ETH_I block, GIC (15518-CAH 109 1360/1 Uen)
	ct:pal("check registers when the node is DUL ~n"),

	% Read and check value of ETH_I register ETH_EMAC_ADDR_FILTER_MODE 
	16#80000000 = nci_common_utils:rdfpga(16#2b90),

	AddressFilterMask = proplists:get_value(addressFilterMask, Parameters, []),
	NumOfEthHwifMacAddresses = proplists:get_value(numOfEthHwifMacAddresses, Parameters, 0),
	EthHwifMacAddressParam = proplists:get_value(ethHwifMacAddressParam, Parameters, 0),
	
	% Read and check value of ETH_I register ETH_UCAST_LUT_DATA
	ListOfNum = lists:seq(1,NumOfEthHwifMacAddresses),
	lists:foreach(fun(Num) ->
		EthHwifMacAddress = lists:nth(Num, EthHwifMacAddressParam),
		Address = element(4,EthHwifMacAddress),
		ct:pal("The value of Address is: ~p~n",[Address]),
		Value = lists:foldl(fun(X,SUM)->
					X+256*SUM 
			end,
			0,Address),
		UlutAddr = ((Value band 16#00000000001F)*4) bor 16#2C00,
		UlutVal = nci_common_utils:rdfpga(UlutAddr),
		ExpectedUlutVal = 16#8000000c bor (Num-1),
		ExpectedUlutVal = UlutVal
	end,
	ListOfNum),

	% Read and check value of ETH_I register ETH_MCAST_LUT_DATA
	16#8000000e = nci_common_utils:rdfpga(16#2C80),

	% Read and check value of ETH_I register ETH_UC_MAC_ADDR_0
	EthHwifMacAddress1 = lists:nth(NumOfEthHwifMacAddresses, EthHwifMacAddressParam),
	Address1 = element(4,EthHwifMacAddress1),
	ct:pal("The value of Address1 is: ~p~n",[Address1]),
	Value1 = lists:foldl(fun(X,SUM)->
				X+256*SUM 
		end,
		0,Address1),
	ExpectedMac0Val = Value1 band 16#00FFFFFFE0,
	Mac0Addr = 16#2804,
	Mac0Val = nci_common_utils:rdfpga(Mac0Addr),
	ExpectedMac0Val = Mac0Val,

	% Read and check value of ETH_I register ETH_UC_MAC_ADDR_1
	EthHwifMacAddress2 = lists:nth(1, EthHwifMacAddressParam),
	Address2 = element(4,EthHwifMacAddress2),
	ct:pal("The value of Address2 is: ~p~n",[Address2]),
	Value2 = lists:foldl(fun(X,SUM)->
				X+256*SUM 
		end,
		0,Address2),
	ct:pal("The value of Value2 is: ~p~n",[Value2]),
	ExpectedMac1Val = (Value2 band 16#FF00000000) bsr 32,
	Mac1Addr = 16#2808,
	Mac1Val = nci_common_utils:rdfpga(Mac1Addr),
	ExpectedMac1Val = Mac1Val,

	% Read and check value of ETH_I register ETH_UC_MAC_ADDR_MASK
	ExpectedMaskVal = (AddressFilterMask bsr 10) bxor 16#3F,
	MaskAddr = 16#283C,
	MaskVal = nci_common_utils:rdfpga(MaskAddr),
	ExpectedMaskVal = MaskVal.

bciEthsetupCheckRegisters_DUXI(Parameters) ->
	% Read and check value of GPA_MUX (GPA_MUX_mRBS for mRBS) SW register GPAX_ACP_ING_MAC_TABLE_CONFIG
	% The references are: User Reference for DUXI_S41 (15518-CEH 101 698/2 Uen),User Reference for DUXI_S_mRBS (15518-CEH 101 728/1 Uen),Users Reference for GPA_MUX (15518-CAH 109 2013 Uen).

	DU = nci_common_utils:get_du(),
	BaseAddress = 
		case DU of
			dus ->
				16#30000;
			mRBS_lte ->
				16#2800;
			_ ->
				ct:fail("DU not supported: ~p", [DU])
		end,

	ct:pal("check registers when the node is DUS41 or mRBS~n"),

	NumOfEthHwifMacAddresses = proplists:get_value(numOfEthHwifMacAddresses, Parameters, 0),
	EthHwifMacAddressParam = proplists:get_value(ethHwifMacAddressParam, Parameters, 0),

	ListOfNum = lists:seq(1,NumOfEthHwifMacAddresses),
	lists:foreach(fun(Num) ->

		ThenthElement = lists:nth(Num, EthHwifMacAddressParam),
		Address = element(4,ThenthElement),
		ct:pal("The value of Address is: ~p~n",[Address]),
		Value = lists:foldl(fun(X,SUM)->
					X+256*SUM 
			end,
			0,Address),
		EthHwifMacAddress = integer_to_list(Value,16),
		Snid = element(2,ThenthElement),
		case Snid of
			0 ->
				16#00000000 = nci_common_utils:rdfpga(BaseAddress + 16#40);

			_ -> ok
		end,

		% verify the routing of the ACP ingress packets is right
		case EthHwifMacAddress of
			"1ED65777F" ->
				16#0000000b = nci_common_utils:rdfpga(BaseAddress + 16#1D4);

			_ -> ok
		end,

		case NumOfEthHwifMacAddresses of
			4 ->
				case nci_common_utils:get_du() of
					dus ->
						% Wait 1 second to allow the GPA_MUX sw register written, it will be removed when bugzillaitem #625 is resolved
						timer:sleep(1000),

						% read mac_table_config1
						16#00000008 = nci_common_utils:rdfpga(BaseAddress + 16#90),

						% read mac_table_config2
						16#00000002 = nci_common_utils:rdfpga(BaseAddress + 16#54),

						% read mac_table_config3
						16#00000001 = nci_common_utils:rdfpga(BaseAddress + 16#100),

						% read mac_table_config4
						16#0000000b = nci_common_utils:rdfpga(BaseAddress + 16#48);

					mRBS_lte ->
						% read mac_table_config1
						16#00000001 = nci_common_utils:rdfpga(BaseAddress + 16#90),

						% read mac_table_config2
						16#00000000 = nci_common_utils:rdfpga(BaseAddress + 16#54),

						% read mac_table_config3
						16#00000000 = nci_common_utils:rdfpga(BaseAddress + 16#100),

						% read mac_table_config4
						16#0000000b = nci_common_utils:rdfpga(BaseAddress + 16#48)
				end;
			_ -> ok
		end
	end,
	ListOfNum).
%%##############################################################################
%% $ChapterH2 Temperature Measurement Start
%%
%% DU BC shall read a hot spot sensor witha a specified interval and return temperature to the BC client. Default inrtervall is 1 sec (hotSpotMeasurementPeriod).
%%
%% $End
%%##############################################################################

%%------------------------------------------------------------------------------
%% $Id BCI_TMS1
%%
%% $Header
%%  Temperature Measurement - State Starting
%%
%% $Description
%%  Temp Measurement Start in state Starting
%%
%% $Requirements
%%  CBD_EVENT_BCI_FU:1A
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  DP LMC is loaded.
%%  Ensure state is in starting
%%  Fake temperature 56 with shellcommand "setTemp 56"
%%
%% $Action_1
%%  Send a TEMP_MEAS_START_REQ with parameters:
%%  * hotspotmeasperiod = 1
%%
%% $Result_1a
%%  A TEMP_MEAS_START_CFM is received
%%
%% $Result_1b
%%  A ELIB_BC_TEMP_MEAS_IND is received within 1 second with parameters:
%%  * numSensors = 1
%%  * hotspotmeasperiod = 1
%%  * hotSpotTemperature = 56
%%
%% $Action_2
%%  Check that the string "ABN:ELIB_BC_TEMP_MEAS_IND" does not appear in the T&E log according to HO94737.
%%
%% $Result_2
%%  T&E log does not contain the above string.
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Revision history:
%%  2012-05-30, QMAGSED
%%    First version
%%
%%  2013-08-10, EDEYICH
%%    Update after reviewed
%%
%%  2013-09-09, EBACEMI
%%    Updated with a new action
%%
%%------------------------------------------------------------------------------
bci_tms1() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_EVENT_BCI_FU:1A"},
				{slogan, "Temperature Measurement - State Starting"}]}].

bci_tms1(_Config) ->
	ct:pal("bci_tms1"),
	bci_tms_pre( starting_lmc_loaded ),

	%% Temp
	ct:pal("Action_1 & Result_1a"),
	ok = nci_bci_actions:temp_meas_start([{expectedSigNo, ?ELIB_BC_TEMP_MEAS_START_CFM},
										{hotspotmeasperiod, 1}]),

	%% Get temp 5 times
	ct:pal("Result_1b"),
	ReceiveTemp = 56 * 100,
	TempParams = [{expectedIndNo, ?ELIB_BC_TEMP_MEAS_IND},
				  {hotspotmeasperiod, 1},
				  {numSensors, 1},
				  {hotSpotTemperature, [ReceiveTemp, 0, 0, 0, 0, 0, 0, 0, 0, 0]}],

	ok = nci_bci_actions:temp_meas_ind(TempParams),
	ok = nci_bci_actions:temp_meas_ind(TempParams),
	ok = nci_bci_actions:temp_meas_ind(TempParams),
	ok = nci_bci_actions:temp_meas_ind(TempParams),
	ok = nci_bci_actions:temp_meas_ind(TempParams),

	ct:pal("Action_2"),
	%% TR HO94737
	nci_common_utils:string_not_in_te_log(?SHELL_COMMAND, "ABN:ELIB_BC_TEMP_MEAS_IND"),

	bci_tms_post().


bci_tms_pre( State ) ->
	{ok, session_up} = coli:subscribe_state(?SHELL_COMMAND),
	{ok, session_up} = osegw:subscribe_state(?OSE_GW_DEAMON_1),

	%% Need to load DP LMC before going to disabled state
	case State of
		disabled ->
			nci_bci_states:set_state([{state, starting_lmc_loaded}]);
		_ ->
			ok
	end,

	nci_bci_states:set_state([{state, State}]),

	%% Connect to BCI interface
	ok = nci_bci_actions:conn_establish([{oseGwDeamon, ?OSE_GW_DEAMON_1}]),

	%% Fake temp with cbu_command
	Temp = 56,
	nci_common_utils:coli_cmd(io_lib:format("setTemp ~p",[Temp])).


bci_tms_post() ->
	%% Stop fake temp  with cbu_command
	nci_common_utils:coli_cmd("setTemp "),

	%% Restart OSE_GW_DEAMON_1
	ok = nci_common_utils:restart_osegw(),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id BCI_TMS2
%%
%% $Header
%%  Temperature Measurement - State Operational
%%
%% $Description
%%  Temp Measurement Start in state Operational
%%
%% $Requirements
%%  CBD_EVENT_BCI_FU:1A
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  DP LMC is loaded
%%  Ensure state is in operational
%%  Fake temperature 56 with shellcommand "setTemp 56"
%%
%% $Action_1
%%  Send a TEMP_MEAS_START_REQ with parameters:
%%  * hotspotmeasperiod = 5
%%
%% $Result_1a
%%  A TEMP_MEAS_START_CFM is received
%%
%% $Result_1b
%%  A ELIB_BC_TEMP_MEAS_IND is received within 5 seconds with parameters: 
%%  * numSensors = 1
%%  * hotspotmeasperiod = 5
%%  * hotSpotTemperature = 56
%%
%% $Action_2
%%  Check that the string "ABN:ELIB_BC_TEMP_MEAS_IND" does not appear in the T&E log according to HO94737.
%%
%% $Result_2
%%  T&E log does not contain the above string.
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Revision history:
%%  2012-05-30, QMAGSED
%%    First version
%%
%%  2013-08-10, EDEYICH
%%    Update after reviewed
%%
%%  2013-09-09, EBACEMI
%%    Updated with a new action
%%
%%------------------------------------------------------------------------------
bci_tms2() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_EVENT_BCI_FU:1A"},
				{slogan, "Temperature Measurement - State Operational"}]}].

bci_tms2(_Config) ->
	ct:pal("bci_tms2"),
	bci_tms_pre( operational ),

	%% Temp
	ct:pal("Action_1 & Result_1a"),
	ok = nci_bci_actions:temp_meas_start([{expectedSigNo, ?ELIB_BC_TEMP_MEAS_START_CFM},
										{hotspotmeasperiod, 5}]),

	%% Get temp 5 times
	ct:pal("Result_1b"),
	ReceiveTemp = 56 * 100,
	TempParams = [{expectedIndNo, ?ELIB_BC_TEMP_MEAS_IND},
				  {hotspotmeasperiod, 5},
				  {numSensors, 1},
				  {hotSpotTemperature, [ReceiveTemp, 0, 0, 0, 0, 0, 0, 0, 0, 0]}],

	ok = nci_bci_actions:temp_meas_ind(TempParams),
	ok = nci_bci_actions:temp_meas_ind(TempParams),
	ok = nci_bci_actions:temp_meas_ind(TempParams),
	ok = nci_bci_actions:temp_meas_ind(TempParams),
	ok = nci_bci_actions:temp_meas_ind(TempParams),

	ct:pal("Action_2"),
	%% TR HO94737
	nci_common_utils:string_not_in_te_log(?SHELL_COMMAND, "ABN:ELIB_BC_TEMP_MEAS_IND"),

	bci_tms_post().

%%------------------------------------------------------------------------------
%% $Id BCI_TMS3
%%
%% $Header
%%  Temperature Measurement - State Disabled
%%
%% $Description
%%  Temp Measurement Start in state Disabled
%%
%% $Requirements
%%  CBD_EVENT_BCI_FU:1A
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  DP LMC is loaded
%%  Ensure state is in disable
%%  Fake temperature 56 with shellcommand "setTemp 56"
%%
%% $Action_1
%%  Send a TEMP_MEAS_START_REQ with parameters: 
%%  * hotspotmeasperiod = 3
%%
%% $Result_1a
%%  A TEMP_MEAS_START_CFM is received
%%
%% $Result_1b
%%  A ELIB_BC_TEMP_MEAS_IND is received within 3 seconds with parameters:
%%  * numSensors = 1
%%  * hotspotmeasperiod = 3
%%  * hotSpotTemperature = 56
%%
%% $Action_2
%%  Check that the string "ABN:ELIB_BC_TEMP_MEAS_IND" does not appear in the T&E log according to HO94737.
%%
%% $Result_2
%%  T&E log does not contain the above string.
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Revision history:
%%  2012-05-30, QMAGSED
%%    First version
%%
%%  2013-08-10, EDEYICH
%%    Update after reviewed
%%
%%  2013-09-09, EBACEMI
%%    Fixed a bug where the TC was able to enter disabled state without DP LMC loaded.
%%    Updated with a new action.
%%
%%------------------------------------------------------------------------------
bci_tms3() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_EVENT_BCI_FU:1A"},
				{slogan, "Temperature Measurement - State Disabled"}]}].

bci_tms3(_Config) ->
	ct:pal("bci_tms3"),
	bci_tms_pre(disabled),

	%% Temp
	ct:pal("Action_1 & Result_1a"),
	ok = nci_bci_actions:temp_meas_start([{expectedSigNo, ?ELIB_BC_TEMP_MEAS_START_CFM},
										  {hotspotmeasperiod, 3}]),

	%% Get temp 5 times
	ct:pal("Result_1b"),
	ReceiveTemp = 56 * 100,
	TempParams = [{expectedIndNo, ?ELIB_BC_TEMP_MEAS_IND},
				  {hotspotmeasperiod, 3},
				  {numSensors, 1},
				  {hotSpotTemperature, [ReceiveTemp, 0, 0, 0, 0, 0, 0, 0, 0, 0]}],

	ok = nci_bci_actions:temp_meas_ind(TempParams),
	ok = nci_bci_actions:temp_meas_ind(TempParams),
	ok = nci_bci_actions:temp_meas_ind(TempParams),
	ok = nci_bci_actions:temp_meas_ind(TempParams),
	ok = nci_bci_actions:temp_meas_ind(TempParams),

	ct:pal("Action_2"),
	%% TR HO94737
	nci_common_utils:string_not_in_te_log(?SHELL_COMMAND, "ABN:ELIB_BC_TEMP_MEAS_IND"),

	bci_tms_post().

%%------------------------------------------------------------------------------
%% $Id BCI_TMS4
%%
%% $Header
%%  Temperature Measurement - Period out of range
%%
%% $Description
%%  Shall NOT be possible to set hotspotmeasperiod out of range (range is 1..5 sec), in BCI Temp Measurement Start, State Starting
%%
%% $Requirements
%%  CBD_EVENT_BCI_FU:1A
%%
%% $External References 
%%  elibBcTemperature.sig
%%
%%  #define ELIB_BC_TEMP_MEAS_START_REQ (ELIB_BC_TEMPERATURE_SIGBASE + 0)    /* !- SIGNO(struct ElibBcTempMeasStartReqS) -! */
%%  /*****************************************************************************
%%  * Signal: ELIB_BC_TEMP_MEAS_START_REQ (0x1659100)
%%  *//**
%%  * @param addressInfo          -
%%  * @param hotSpotMeasurementPeriod
%%  *                             Time interval for DB/AU to wait between 
%%  *                             sending of ELIB_BC_TEMP_MEAS_IND Values: 
%%  *                             1..5. One to one mapping of time in seconds.
%%  ****************************************************************************/
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  Ensure state is in starting
%%
%% $Action_1
%%  Send a TEMP_MEAS_START_REQ with parameters: 
%%  * hotspotmeasperiod = 6
%%
%% $Result_1
%%  A TEMP_MEAS_START_REJ is received with parameters: 
%%  * errorDescription = "Invalid Measurement period" 
%%  * errorCode = UNSUCCESSFUL
%%
%% $Action_2
%%  Send a TEMP_MEAS_START_REQ with parameters: 
%%  * hotspotmeasperiod = 0
%%
%% $Result_2
%%  A TEMP_MEAS_START_REJ is received with parameters: 
%%  * errorDescription = "Invalid Measurement period" 
%%  * errorCode = UNSUCCESSFUL
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Revision history:
%%  2012-05-30, QMAGSED
%%    First version
%%
%%  2013-08-10, EDEYICH
%%    Update after reviewed
%%
%%------------------------------------------------------------------------------
bci_tms4() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_EVENT_BCI_FU:1A"},
				{slogan, "Temperature Measurement - Period out of range"}]}].

bci_tms4(_Config) ->
	ct:pal("bci_tms4"),
	bci_tms_pre( starting_lmc_loaded ),

	%% Temp 
	ct:pal("Action_1 & Result_1"),
	ok = nci_bci_actions:temp_meas_start([{oseGwDeamon, ?OSE_GW_DEAMON_1},
										{expectedSigNo, ?ELIB_BC_TEMP_MEAS_START_REJ},
										{hotspotmeasperiod, 6},
										{errorCode, 1},
										{errorDescription, {regexp, "Invalid Measurement period*"}}]),

	%% Temp 
	ct:pal("Action_2 & Result_2"),
	ok = nci_bci_actions:temp_meas_start([{oseGwDeamon, ?OSE_GW_DEAMON_1},
										{expectedSigNo, ?ELIB_BC_TEMP_MEAS_START_REJ},
										{hotspotmeasperiod, 0},
										{errorCode, 1},
										{errorDescription, {regexp, "Invalid Measurement period*"}}]),
	bci_tms_post().

%%------------------------------------------------------------------------------
%% $Id BCI_TMS5
%%
%% $Header
%%  Temperature Measurement - DP LMC not loaded
%%
%% $Description
%%  When LMC is not loaded "BCI Temp Measurement Start req" shall result in REJ
%%
%% $Requirements
%%  CBD_EVENT_BCI_FU:1A
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  Ensure state is in starting
%%
%% $Action_1
%%  Send a TEMP_MEAS_START_REQ REQ with parameters:
%%  * hotspotmeasperiod = 1
%%
%% $Result_1
%%  A TEMP_MEAS_START_REJ is received with parameters: 
%%  * errorDescription = "DP not loaded" 
%%  * errorCode = UNSUCCESSFUL
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Revision history:
%%  2012-05-30, QMAGSED
%%    First version
%%
%%  2013-08-10, EDEYICH
%%    Update after reviewed
%%
%%------------------------------------------------------------------------------
bci_tms5() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_EVENT_BCI_FU:1A"},
				{slogan, "Temperature Measurement - DP LMC not loaded"}]}].

bci_tms5(_Config) ->
	ct:pal("bci_tms5"),
	bci_tms_pre( starting_lmc_not_loaded ),

	%% Temp 
	ct:pal("Action_1 & Result_1"),
	ok = nci_bci_actions:temp_meas_start([{oseGwDeamon, ?OSE_GW_DEAMON_1},
										{expectedSigNo, ?ELIB_BC_TEMP_MEAS_START_REJ},
										{hotspotmeasperiod, 1},
										{errorCode, 1},
										{errorDescription, {regexp, "DP not loaded*"}}]),

	bci_tms_post().

%%##############################################################################
%% $ChapterH2 Functions for the UCTool
%%
%% DU BC shall route the internal clock to the test connector upon request from a BC client. DU BC shall activate sRio testport upon request from a BC Client. Default shall the port be deactivated.
%%
%% $End
%%##############################################################################

%%------------------------------------------------------------------------------
%% $Id BCI_ACTIVATE_VCXO1
%%
%% $Header
%%  State Starting
%%
%% $Description
%%  Activate VCXO clock for the UCTool in state Starting
%%
%% $Requirements
%%  CBD_HW-Test_BCI_FU:2:A, wp1060
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  Ensure state is in starting
%%
%% $Action
%%  Send a ACTIVATE_VC_XO_REQ
%%
%% $Result
%%  A ACTIVATE_VC_XO_CFM is received
%%
%% $Action
%%  Check that the lowest bit in P_CLK_MUX register is set with shellcommand "rdfpga 0x1E2C"
%%
%% $Result
%%  The output should be "00000001"
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-10-08, EEDAJA
%%    First version
%%
%%------------------------------------------------------------------------------ 
bci_activate_vcxo1() ->
	[{userdata,[{wp, ""},
				{requirement, "CBD_HW-Test_BCI_FU:2:A"},
				{slogan, ""},
				{hwConfig, hwConfigA}]}].

bci_activate_vcxo1(_Config) ->
	ct:pal("bci_activate_vcxo1"),

	% Set state, make audit, establish BCI and DCI connections, subscribe faults
	set_state_and_connect( starting_lmc_loaded ),

	%% Subscribe Faults DCI
	ok = nci_dci_actions:subscribe_faults([]),

	%% Activate VCXO
	ok = nci_bci_actions:activate_vcxo([]),

	%% Activate VCXO second time
	ok = nci_bci_actions:activate_vcxo([]),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id BCI_ACTIVATE_VCXO2
%%
%% $Header
%%  State Operational
%%
%% $Description
%%  Activate VCXO clock for the UCTool in state Operational
%%
%% $Requirements
%%  CBD_HW-Test_BCI_FU:2:A, wp1060
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  Ensure state is in operational
%%
%% $Action
%%  Send a ACTIVATE_VC_XO_REQ
%%
%% $Result
%%  A ACTIVATE_VC_XO_CFM is received
%%
%% $Action
%%  Check that the lowest bit in P_CLK_MUX register is set with shellcommand "rdfpga 0x1E2C"
%%
%% $Result
%%  The output should be "00000001"
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-10-08, EEDAJA
%%    First version
%%
%%------------------------------------------------------------------------------
bci_activate_vcxo2() ->
	[{userdata,[{wp, ""},
				{requirement, "CBD_HW-Test_BCI_FU:2:A"},
				{slogan, ""},
				{hwConfig, hwConfigA}]}].

bci_activate_vcxo2(_Config) ->
	ct:pal("bci_activate_vcxo2"),

	% Set state, make audit, establish BCI and DCI connections, subscribe faults
	set_state_and_connect( operational ),

	%% Subscribe Faults DCI
	ok = nci_dci_actions:subscribe_faults([]),

	%% Activate VCXO
	ok = nci_bci_actions:activate_vcxo([]),

	%% Activate VCXO second time
	ok = nci_bci_actions:activate_vcxo([]),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id BCI_ACTIVATE_VCXO3
%%
%% $Header
%%  State Disabled
%%
%% $Description
%%  Activate VCXO clock for the UCTool in state Disabled, shall result in REJ
%%
%% $Requirements
%%  CBD_HW-Test_BCI_FU:2:A, wp1060
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  Ensure state is in disabled
%%
%% $Action
%%  Send a ACTIVATE_VC_XO_REQ
%%
%% $Result
%%  A ACTIVATE_VC_XO_REJ is received with parameters: 
%%  errorDescription = "Invalid O&M state" 
%%  errorCode = UNSUCCESSFUL
%%
%% $Action
%%  Check that the lowest bit in P_CLK_MUX register is set with shellcommand "rdfpga 0x1E2C"
%%
%% $Result
%%  The output should be "XXXXXXX0" where X is 0 or 1
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-10-08, EEDAJA
%%    First version
%%
%%------------------------------------------------------------------------------
bci_activate_vcxo3() ->
	[{userdata,[{wp, ""},
				{requirement, "CBD_HW-Test_BCI_FU:2:A"},
				{slogan, ""},
				{hwConfig, hwConfigA}]}].

bci_activate_vcxo3(_Config) ->
	ct:pal("bci_activate_vcxo3"),

	% Set state, make audit, establish BCI and DCI connections, subscribe faults
	set_state_and_connect( disabled ),

	%% Subscribe Faults DCI
	ok = nci_dci_actions:subscribe_faults([]),

	%% Activate VCXO
	ok = nci_bci_actions:activate_vcxo([{expectedSigNo,?ELIB_BC_ACTIVATE_VC_XO_REJ},
										{errorCode, 1},
										{errorDescription, {regexp, "Invalid O&M state*"}}]),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id BCI_ACTIVATE_VCXO5
%%
%% $Header
%%  DP LMC not loaded
%%
%% $Description
%%  Shall not be possilble to do BCI Test Activate VCXO clock for the UCTool when LMC not loaded
%%
%% $Requirements
%%  CBD_HW-Test_BCI_FU:2:A
%%
%%  wp1060
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  Ensure state is in starting
%%
%%  Ensure LMC is NOT loaded
%%
%% $Action
%%  Send a ACTIVATE_VC_XO_REQ
%%
%% $Result
%%  A ACTIVATE_VC_XO_REJ is received is received with parameters: 
%%  errorDescription = "DP not loaded" 
%%  errorCode = UNSUCCESSFUL
%%
%% $Action
%%  Check that the lowest bit in P_CLK_MUX register is set with shellcommand "rdfpga 0x1E2C"
%%
%% $Result
%%  The output should be "XXXXXXX0" where X is 0 or 1
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-10-08, EEDAJA
%%    First version
%%
%%------------------------------------------------------------------------------
bci_activate_vcxo5() ->
	[{userdata,[{wp, ""},
				{requirement, "CBD_HW-Test_BCI_FU:2:A"},
				{slogan, ""},
				{hwConfig, hwConfigA}]}].

bci_activate_vcxo5(_Config) ->
	ct:pal("bci_activate_vcxo5"),

	% Set state, make audit, establish BCI and DCI connections, subscribe faults
	set_state_and_connect( starting_lmc_not_loaded ),

	%% Subscribe Faults DCI
	ok = nci_dci_actions:subscribe_faults([]),

	%% Activate VCXO
	ok = nci_bci_actions:activate_vcxo([{expectedSigNo,?ELIB_BC_ACTIVATE_VC_XO_REJ},
										{errorCode, 1},
										{errorDescription, {regexp, "DP not loaded*"}}]),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id BCI_ACTIVATE_SRIO_TESTPORT1
%%
%% $Header
%%  State Starting
%%
%% $Description
%%  Activate sRIO test port for the UCTool, State Starting
%%
%% $Requirements
%%  CBD_HW-Test_BCI_FU:1:A
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  Ensure state is in starting
%%
%%  Ensure SRIO testport is disable
%%
%% $Action
%%  Send a ACTIVATE_SRIO_TEST_PORT_REQ with parameter: 
%%  portNr = 0
%%
%% $Result
%%  A ACTIVATE_SRIO_TEST_PORT_CFM is received
%%
%% $Action
%%  Check that the testport is enabled with shellcommand "swport 2816 1".
%%
%% $Result
%%  The output should be "Port is Enabled"
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-10-02, EEDAJA
%%    First version
%%
%%------------------------------------------------------------------------------
bci_activate_srio_testport1() ->
	[{userdata,[{wp, ""},
				{requirement, "CBD_HW-Test_BCI_FU:1:A"},
				{slogan, ""}]}].

bci_activate_srio_testport1(_Config) ->
	ct:pal( "bci_activate_srio_testport1" ),

	bci_act_srio_tp_pre(starting_lmc_loaded),

	%% Disable SRIO test port
	nci_common_utils:coli_cmd("swport 2816 1 disable"),

	%% Check that sRIO test port is disabled
	nci_common_utils:coli_cmd("swport 2816 1","Port is Disabled"),

	nci_bci_actions:activate_srio_test_port([]),

	%% Check that sRIO test port is enabled
	nci_common_utils:coli_cmd("swport 2816 1","Port is Enabled"),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

		
bci_act_srio_tp_pre( State ) ->

	nci_bci_states:set_state([{state, State}]),

	{ok, session_up} = coli:subscribe_state(?SHELL_COMMAND),
	{ok, session_up} = osegw:subscribe_state(?OSE_GW_DEAMON_1),

	%% Connect to BCI interface
	ok = nci_bci_actions:conn_establish([]),

	%% Subscribe Faults BCI
	ok = nci_bci_actions:subscribe_faults([]).

%%------------------------------------------------------------------------------
%% $Id BCI_ACTIVATE_SRIO_TESTPORT2
%%
%% $Header
%%  State Operational
%%
%% $Description
%%  Activate sRIO test port for the UCTool, State Operational. Portnr does NOT matter (RICM does not care about portNr)
%%
%% $Requirements
%%  CBD_HW-Test_BCI_FU:1:A, wp1060
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  Ensure state is in starting
%%
%%  Ensure SRIO testport is disable
%%
%% $Action
%%  Send a ACTIVATE_SRIO_TEST_PORT_REQ with parameter: 
%%  portNr = 0
%%
%% $Result
%%  A ACTIVATE_SRIO_TEST_PORT_CFM is received
%%
%% $Action
%%  Check that the testport is enabled with shellcommand "swport 2816 1".
%%
%% $Result
%%  The output should be "Port is Enabled"
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-10-02, EEDAJA
%%    First version
%%
%%------------------------------------------------------------------------------
bci_activate_srio_testport2() ->
	[{userdata,[{wp, ""},
				{requirement, "CBD_HW-Test_BCI_FU:1:A"},
				{slogan, ""}]}].

bci_activate_srio_testport2(_Config) ->
	ct:pal( "bci_activate_srio_testport2" ),

	bci_act_srio_tp_pre(operational),

	%% Disable SRIO test port
	nci_common_utils:coli_cmd("swport 2816 1 disable"),

	%% Check that sRIO test port is disabled
	nci_common_utils:coli_cmd("swport 2816 1","Port is Disabled"),

	nci_bci_actions:activate_srio_test_port([]),

	%% Check that sRIO test port is enabled
	nci_common_utils:coli_cmd("swport 2816 1","Port is Enabled"),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id BCI_ACTIVATE_SRIO_TESTPORT3
%%
%% $Header
%%  State Disabled
%%
%% $Description
%%  Activate sRIO test port for the UCTool, State Disabled, shall result in REJ
%%
%% $Requirements
%%  CBD_HW-Test_BCI_FU:1:A
%%
%%  wp1060
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  Ensure state is in starting
%%
%%  Ensure SRIO testport is disable
%%
%% $Action
%%  Send a ACTIVATE_SRIO_TEST_PORT_REQ with parameter: 
%%  portNr = 10
%%
%% $Result
%%  A ACTIVATE_SRIO_TEST_PORT_REJ is received with parameters: 
%%  errorDescription = "Invalid O&M state"
%%
%% $Action
%%  Check that the testport is enabled with shellcommand "swport 2816 1".
%%
%% $Result
%%  The output should be "Port is Disabled"
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-10-20, EEDAJA
%%	First version
%%
%%------------------------------------------------------------------------------
bci_activate_srio_testport3() ->
	[{userdata,[{wp, ""},
				{requirement, "CBD_HW-Test_BCI_FU:1:A"},
				{slogan, ""}]}].

bci_activate_srio_testport3(_Config) ->
	ct:pal( "bci_activate_srio_testport3" ),

	bci_act_srio_tp_pre(operational), % State will be changed later to disabled

	%% Disable SRIO test port
	nci_common_utils:coli_cmd("swport 2816 1 disable"),

	%% Check that sRIO test port is disabled
	nci_common_utils:coli_cmd("swport 2816 1","Port is Disabled"),

	nci_bci_states:set_state([{state, disabled}]),

	nci_bci_actions:activate_srio_test_port([{expectedSigNo, ?ELIB_BC_ACTIVATE_SRIO_TEST_PORT_REJ},
											{errorCode, 1},
											{errorDescription, {regexp, "Invalid O&M state*"}}]),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id BCI_ACTIVATE_SRIO_TESTPORT5
%%
%% $Header
%%  LMC not loaded
%%
%% $Description
%%  Shall not be possilble to activate sRIO test port for the UCTool, when DP not loaded
%%
%% $Requirements
%%  CBD_HW-Test_BCI_FU:1:A
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  Ensure state is in starting
%%
%%  Ensure LMC is NOT loaded
%%
%% $Action
%%  Send a ACTIVATE_SRIO_TEST_PORT_REQ with parameter: 
%%  portNr = 0
%%
%% $Result
%%  A ACTIVATE_SRIO_TEST_PORT_REJ is received with parameters: 
%%  errorDescription = "DP not loaded"
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-10-20, EEDAJA
%%    First version
%%
%%------------------------------------------------------------------------------
bci_activate_srio_testport5() ->
	[{userdata,[{wp, ""},
				{requirement, "CBD_HW-Test_BCI_FU:1:A"},
				{slogan, ""}]}].

bci_activate_srio_testport5(_Config) ->
	ct:pal( "bci_activate_srio_testport5" ),

	bci_act_srio_tp_pre(starting_lmc_not_loaded),

	nci_bci_actions:activate_srio_test_port([{expectedSigNo, ?ELIB_BC_ACTIVATE_SRIO_TEST_PORT_REJ},
											{errorCode, 1},
											{errorDescription, {regexp, "DP not loaded*"}}]),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id BCI_ACTIVATE_SRIO_TESTPORT6
%%
%% $Header
%%  Test Port Disabled
%%
%% $Description
%%  Check that sRIO test port is set to disabled by default. After a reload and lmc is loaded the the test port shall be disabled
%%
%% $Requirements
%%  CBD_HW-Test_BCI_FU:1:A
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  Ensure state is in starting
%%
%%  Ensure SRIO testport is disable
%%
%% $Action
%%  Load DP
%%
%% $Result
%%  The LMC is loaded on the board
%%
%% $Action
%%  Read the status of port 1 on SRIO switch (snid 2816) with the COLI command swport
%%
%% $Result
%%  Test port shall be disabled
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%    First version
%%
%%------------------------------------------------------------------------------


%%##############################################################################
%% $ChapterH2 BPAI Fault supervision
%%
%%
%% $End
%%##############################################################################

%%------------------------------------------------------------------------------
%% $Id BCI_FAKE_BPP_SWFAULT 
%%
%% $Header
%%  Fake BPP SW fault
%%
%% $Description
%%  BCI fake BPP SW Fault
%%
%% $Requirements
%%  CBD_FAULT_BCI_FU:1:A 
%%  CBD_FAULT_BCI_FU:2:A
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  BCI state is starting.
%%  DP LMC is loaded.
%%
%% $Action_1
%%  Generate BPP SW Fault with shellcommand "fakeFault 0 1"
%%
%% $Result_1
%%  A BC_FAULT_IND signal is received with parameters: 
%%  * faultId = CONST_FH_FAULT_ID_SW_ERROR
%%  * faultDescription = "CBD I&V generated BMR_FAULT_IND*"
%%
%% $Action_2
%%  Cease BPP SW Fault with shellcommand "fakeFaultCease 0"
%%
%% $Result_2
%%  A FAULT_CEASE_IND signal is received with parameters: 
%%  * faultId = CONST_FH_FAULT_ID_SW_ERROR
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-05-30, QMAGSED
%%    First version
%%  2013-10-09, EBACEMI
%%    Removed T&E log check.
%%    Cleaned up the TC.
%%
%%------------------------------------------------------------------------------
bci_fake_bpp_swfault() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_FAULT_BCI_FU:1:A, CBD_FAULT_BCI_FU:2:A"},
				{slogan, "Fake BPP SW fault"}]}].

bci_fake_bpp_swfault(_Config) ->
	ct:pal("bci_bpp_sw_fault"),

	{ok, session_up} = coli:subscribe_state(?SHELL_COMMAND),
	{ok, session_up} = osegw:subscribe_state(?OSE_GW_DEAMON_1),

	nci_bci_states:set_state([{state, starting_lmc_loaded}]),

	ok = nci_bci_actions:subscribe_faults([]),

	ct:pal("Action_1"),
	%% Fake BPP fault with cbu_command
	nci_common_utils:coli_cmd("fakeFault 0 1"),

	ct:pal("Result_1"),
	ok = nci_bci_actions:fault_ind([{faultId, ?ELIB_CONST_FH_FAULT_ID_SW_ERROR},
									{faultDescription, {regexp, "CBD I&V generated BMR_FAULT_IND*"}}]),

	ct:pal("Action_2"),
	%% Cease BPP fault with cbu_command
	nci_common_utils:coli_cmd("fakeFaultCease 0"),

	ct:pal("Result_2"),
	ok = nci_bci_actions:fault_cease_ind([{faultId, ?ELIB_CONST_FH_FAULT_ID_SW_ERROR}]),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id BCI_FAKE_BPP_HWFAULT
%%
%% $Header
%%  Fake BPP HW fault.
%%
%% $Description
%%  BCI fake BPP HW Fault
%%
%% $Requirements
%%  CBD_FAULT_BCI_FU:1:A
%%  CBD_FAULT_BCI_FU:2:A
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  BCI state is starting.
%%  DP LMC is loaded.
%%
%% $Action_1
%%  Generate BPP HW Fault with shellcommand "fakeFault 1 1"
%%
%% $Result_1a
%%  A BC_FAULT_IND signal is received with parameters: 
%%  * faultId = CONST_FH_FAULT_ID_HWF_FOR_EVALUATION
%%  * faultDescription = "802;CBD I&V generated BMR_FAULT_IND*"
%%
%% $Result_1b
%%  The string "802;CBD I&V generated BMR_FAULT_IND*" is found in the hwlog
%%
%% $Action_2
%%  Cease BPP HW Fault with shellcommand "fakeFaultCease 0"
%%
%% $Result_2
%%  A FAULT_CEASE_IND signal is received with parameters: 
%%  * faultId = CONST_FH_FAULT_ID_HWF_FOR_EVALUATION
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-05-30, QMAGSED
%%    First version
%%  2013-10-09, EBACEMI
%%    Removed T&E log check.
%%    Cleaned up the TC.
%%
%%------------------------------------------------------------------------------
bci_fake_bpp_hwfault() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_FAULT_BCI_FU:1:A, CBD_FAULT_BCI_FU:2:A"},
				{slogan, "Fake BPP HW fault"}]}].

bci_fake_bpp_hwfault(_Config) ->
	ct:pal("bci_bpp_hw_fault"),

	{ok, session_up} = coli:subscribe_state(?SHELL_COMMAND),
	{ok, session_up} = osegw:subscribe_state(?OSE_GW_DEAMON_1),

	nci_bci_states:set_state([{state, starting_lmc_loaded}]),

	ok = nci_bci_actions:subscribe_faults([]),

	ct:pal("Action_1"),
	%% Fake BPP fault with cbu_command
	nci_common_utils:coli_cmd("fakeFault 1 1"),

	ct:pal("Result_1a"),
	ok = nci_bci_actions:fault_ind([{faultId, ?ELIB_CONST_FH_FAULT_ID_HWF_FOR_EVALUATION},
									{faultDescription, {regexp, "802;CBD I&V generated BMR_FAULT_IND*"}}]),

	ct:pal("Result_1b"),
	nci_common_utils:find_string_in_dumpelg(?SHELL_COMMAND, ".*802;CBD I&V generated BMR_FAULT_IND.*"),

	ct:pal("Action_2"),
	%% Cease BPP fault with cbu_command
	nci_common_utils:coli_cmd("fakeFaultCease 1"),

	ct:pal("Result_2"),
	ok = nci_bci_actions:fault_cease_ind([{faultId, ?ELIB_CONST_FH_FAULT_ID_HWF_FOR_EVALUATION}]),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%##############################################################################
%% $ChapterH2 Temperature and tempsensor supervision
%%
%%  The temperature on the board is supervised to detect and inform the fault subscriber when 
%%  temperature is out of range. Fault cease shall be sent when temperature is reduced by 3 degrees 
%%  on the safe side of the limit causing the fault indication. The temperature limits are board
%%  type specific and may even be board revision specific. For absolute values see BVL for the 
%%  specific board. The table below illustrates temperature limits and the cease levels.
%%
%% $Table(
%% Temp | Alarm                   | Temp written inHwlog
%%

%% <EH>     Exceptional High          Yes
%%
%% <EH-3>   Cease Exceptional High
%%
%% <NH>     Normal high
%%
%% <NH-3>   Cease Normal high
%%
%% <NL+3>   Cease Normal low
%%
%% <NL>     Normal low
%%
%% <EL+3>   Cease Exceptional low
%%
%% <EL>     Exceptional low           Yes
%% )
%%
%% $End
%%##############################################################################

%%------------------------------------------------------------------------------
%% $Id BCI_FAKE_TEMP1
%%
%% $Header
%%  BCI - Temperature limits and thresholds, state Starting
%%
%% $Description
%%  BCI fake temperature faults, state Starting. Verify that temperature faults 
%%  handles correctly.
%%
%% $Requirements
%%  CBD_FAULT_BCI_FU:1:A
%%  CBD_FAULT_BCI_FU:3:A
%%  CBD_FAULT_BCI_FU:4:A
%%  CBD_FAULT_BCI_FU:5:A
%%  CBD_FAULT_BCI_FU:7:A
%%  CBD_FAULT_BCI_FU:10:A
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  Ensure BCI is in state starting.
%%  DP LMC is loaded.
%%  Subscription for BCI faults.
%%
%% $Action_1
%%  Fake temperature <TempLimitLowNooperation> using shellcommand: setTemp
%%
%% $Result 1a
%%  A FAULT_IND signal received with parameter:
%%  faultId = NORMAL_TEMPERATURE_TOO_LOW
%%
%% $Result 1b
%%  A FAULT_IND signal received with parameters:
%%  faultId = EXCEPTIONAL_TEMPERATURE_TOO_LOW
%%
%% $Action_2
%%  Check HWLog with shellcommand "dumpelg"
%%
%% $Result 2
%%  An entry "Exceptional temp too low;<TempLimitLowNooperation>C" exists
%%
%% $Action_3
%%  Fake temperature <TempLimitExceptional + 3> using shellcommand: setTemp
%%
%% $Result 3a
%%  A FAULTCEASE_IND signal received with parameter:
%%  faultId = EXCEPTIONAL_TEMPERATURE_TOO_LOW
%%
%% $Result 3b
%%  A FAULTCEASE_IND signal received with parameter:
%%  faultId = NORMAL_TEMPERATURE_TOO_LOW
%%
%% $Action_4
%%  Fake temperature <TempLimitHighNooperation> using shellcommand: setTemp
%%
%% $Result 4a
%%  A FAULT_IND signal received with parameter:
%%  faultId = NORMAL_TEMPERATURE_TOO_HIGH
%%
%% $Result 4b
%%  A FAULT_IND signal received with parameter:
%%  faultId = EXCEPTIONAL_TEMPERATURE_TOO_HIGH
%%
%% $Action_5
%%  Check HWLog with shellcommand "dumpelg"
%%
%% $Result 5
%%  An entry "Exceptional temp too high;<TempLimitHighNooperation>C" exists
%%
%% $Action_6
%%  Fake temperature <TempLimitHighExceptional - 3> using shellcommand: setTemp
%%
%% $Result 6a
%%  A FAULTCEASE_IND signal received with parameters:
%%  faultId = EXCEPTIONAL_TEMPERATURE_TOO_HIGH
%%
%% $Result 6b
%%  A FAULTCEASE_IND signal received with parameters:
%%  faultId = NORMAL_TEMPERATURE_TOO_HIGH
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-05-30, QMAGSED
%%    First version
%%
%%  2012-11-06, EEDAJA
%%    Moved the logic to subroutine bci_fake_temp
%%
%%  2012-12-03, EEDAJA
%%    Increased the too high temperature from 70 to 90 because for DUS41 70 is ok
%%
%%  2012-12-14, EEDAJA
%%    Too high temperature is 70 for DUL20 and 90 for DUS41
%%    Minor editorial changes
%%
%%  2013-01-17, ejonuna
%%    Minor correction done to temp string check from dumpelg 
%%
%%  2013-11-07, emasnok
%%    Introduced utility function for temperature limits. 
%%    Replaced temperature values in header with temperature-limit-names.
%%    Removed some obsolete action/results from header.
%%
%%------------------------------------------------------------------------------
bci_fake_temp1() ->
	[{userdata,[{wp, ""},
				{requirement, "CBD_FAULT_BCI_FU:1:A, CBD_FAULT_BCI_FU:3:A, CBD_FAULT_BCI_FU:4:A" ++
							"CBD_FAULT_BCI_FU:5:A, CBD_FAULT_BCI_FU:7:A, CBD_FAULT_BCI_FU:10:A"},
				{slogan, "BCI - Temperature limits and thresholds, state Starting"}]}].

bci_fake_temp1(_Config) ->
	bci_fake_temp("bci_fake_temp1", starting_lmc_loaded).

bci_fake_temp(Name, State ) ->

	ct:pal(Name),

	{ok, session_up} = coli:subscribe_state(?SHELL_COMMAND),
	{ok, session_up} = osegw:subscribe_state(?OSE_GW_DEAMON_1),

	case State of
		disabled ->
			nci_bci_states:set_state([{state, starting_lmc_loaded}]);
		_ -> ok
	end,
	nci_bci_states:set_state([{state, State}]),

	%% Clear HW Log
	nci_common_utils:clear_dumpelg(?SHELL_COMMAND),

	%% Connect to BCI interface
	ok = nci_bci_actions:conn_establish([]),

	%% Subscribe Faults
	ok = nci_bci_actions:subscribe_faults([]),

	ct:pal("Action_1"),
	LowTemp = nci_common_cfg:get_temp_param(lowNoOperation),

	%% Fake low temp with cbu_command
	nci_common_utils:coli_cmd(io_lib:format("setTemp ~p",[LowTemp])),

	%% Receive fault ind
	ok = nci_bci_actions:fault_ind([{faultId, ?ELIB_CONST_FH_FAULT_ID_NORMAL_TEMPERATURE_TOO_LOW},
						{faultDescription, {regexp, "Temp fault*"}}]),
	ok = nci_bci_actions:fault_ind([{faultId, ?ELIB_CONST_FH_FAULT_ID_EXCEPTIONAL_TEMPERATURE_TOO_LOW},
						{faultDescription, {regexp, "Temp fault*"}}]),

	%% Read HW log
	ct:pal("Action_2"),
	nci_common_utils:find_string_in_dumpelg(?SHELL_COMMAND, io_lib:format(".*sensor: \\d;Exceptional temp too low;~pC",[LowTemp])),

	ct:pal("Action_3"),
	%% Allowed temp is limit + 3 degrees
	AllowedTempLow = nci_common_cfg:get_temp_param(lowExceptional) + 3,
	nci_common_utils:coli_cmd(io_lib:format("setTemp ~p",[AllowedTempLow])),

	%% Receive fault cease ind
	ok = nci_bci_actions:fault_cease_ind([{faultId, ?ELIB_CONST_FH_FAULT_ID_EXCEPTIONAL_TEMPERATURE_TOO_LOW}]),
	ok = nci_bci_actions:fault_cease_ind([{faultId, ?ELIB_CONST_FH_FAULT_ID_NORMAL_TEMPERATURE_TOO_LOW}]),

	ct:pal("Action_4"),
	HighTemp = nci_common_cfg:get_temp_param(highNoOperation),
	nci_common_utils:coli_cmd(io_lib:format("setTemp ~p",[HighTemp])),

	%% Receive fault ind
	ok = nci_bci_actions:fault_ind([{faultId, ?ELIB_CONST_FH_FAULT_ID_NORMAL_TEMPERATURE_TOO_HIGH},
					{faultDescription, {regexp, "Temp fault*"}}]),

	ok = nci_bci_actions:fault_ind([{faultId, ?ELIB_CONST_FH_FAULT_ID_EXCEPTIONAL_TEMPERATURE_TOO_HIGH},
					{faultDescription, {regexp, "Temp fault*"}}]),

	%% Read HW log
	ct:pal("Action_5"),
	nci_common_utils:find_string_in_dumpelg(?SHELL_COMMAND, io_lib:format(".*sensor: \\d;Exceptional temp too high;.*~pC",[HighTemp])),

	%% Fake allowed temp (highExceptional - 3) with cbu_command
	ct:pal("Action_6"),
	AllowedTempHigh = nci_common_cfg:get_temp_param(highExceptional) - 3,
	nci_common_utils:coli_cmd(io_lib:format("setTemp ~p",[AllowedTempHigh])),

	%% Receive fault cease ind
	ok = nci_bci_actions:fault_cease_ind([{faultId, ?ELIB_CONST_FH_FAULT_ID_EXCEPTIONAL_TEMPERATURE_TOO_HIGH}]),

	ok = nci_bci_actions:fault_cease_ind([{faultId, ?ELIB_CONST_FH_FAULT_ID_NORMAL_TEMPERATURE_TOO_HIGH}]),

	%% Stop fake temp  with cbu_command
	nci_common_utils:coli_cmd("setTemp "),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id BCI_FAKE_TEMP2
%%
%% $Header
%%  BCI - Temperature limits and thresholds, state Operational
%%
%% $Description
%%  BCI fake temperature faults, state Operational. Verify that temperature faults 
%%  handles correctly. Test case sequence is identical with BCI_FAKE_TEMP1 but 
%%  for state Operational.
%%
%% $Requirements
%%  CBD_FAULT_BCI_FU:1:A
%%  CBD_FAULT_BCI_FU:3:A
%%  CBD_FAULT_BCI_FU:4:A
%%  CBD_FAULT_BCI_FU:5:A
%%  CBD_FAULT_BCI_FU:7:A
%%  CBD_FAULT_BCI_FU:10:A
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  BCI is in state operational.
%%  DP LMC is loaded.
%%  Subscription for BCI faults.
%%
%% $Action
%%  For all actions and results: see BCI_FAKE_TEMP1
%%
%% $Result
%%  For all actions and results: see BCI_FAKE_TEMP1
%%
%% $Postcondition
%%  See BCI_FAKE_TEMP1
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-05-30, QMAGSED
%%    First version
%%
%%  2012-11-06, EEDAJA
%%    Moved the logic to subroutine bci_fake_temp
%%
%%  2012-12-03, EEDAJA
%%    Increased the too high temperature from 70 to 90 because for DUS41 70 is ok
%%
%%  2012-12-14, EEDAJA
%%    Too high temperature is 70 for DUL20 and 90 for DUS41
%%    Minor editorial changes
%%
%%  2013-11-07, EMASNOK
%%    Updated header
%%
%%------------------------------------------------------------------------------
bci_fake_temp2() ->
	[{userdata,[{wp, ""},
				{requirement, "CBD_FAULT_BCI_FU:1:A, CBD_FAULT_BCI_FU:3:A, CBD_FAULT_BCI_FU:4:A" ++
					 "CBD_FAULT_BCI_FU:5:A, CBD_FAULT_BCI_FU:7:A, CBD_FAULT_BCI_FU:10:A"},
				{slogan, "BCI - Temperature limits and thresholds, state Operational"}]}].

bci_fake_temp2(_Config) ->
	bci_fake_temp("bci_fake_temp2", operational).

%%------------------------------------------------------------------------------
%% $Id BCI_FAKE_TEMP3
%%
%% $Header
%%  BCI - Temperature limits and thresholds, state Disabled
%%
%% $Description
%%  BCI fake temperature faults, State Disabled. Verify that temperature faults 
%%  handles correctly. Test case sequence is identical with BCI_FAKE_TEMP1 but 
%%  for state Disabled.
%%
%% $Requirements
%%  CBD_FAULT_BCI_FU:1:A
%%  CBD_FAULT_BCI_FU:3:A
%%  CBD_FAULT_BCI_FU:4:A
%%  CBD_FAULT_BCI_FU:9:A
%%  CBD_FAULT_BCI_FU:10:A
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  BCI is in state disabled.
%%  DP LMC is loaded.
%%  Subscription for BCI faults
%%
%% $Action
%%  For all actions and results: see BCI_FAKE_TEMP1
%%
%% $Result
%%  For all actions and results: see BCI_FAKE_TEMP1
%%
%% $Postcondition
%%  See BCI_FAKE_TEMP1
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-05-30, QMAGSED
%%    First version
%%
%%  2012-11-06, EEDAJA
%%    Moved the logic to subroutine bci_fake_temp
%%
%%  2012-12-03, EEDAJA
%%    Increased the too high temperature from 70 to 90 because for DUS41 70 is ok
%%
%%  2012-12-14, EEDAJA
%%    Too high temperature is 70 for DUL20 and 90 for DUS41
%%    Minor editorial changes
%%
%%  2013-11-07, EMASNOK
%%    Updated test case header
%%
%%------------------------------------------------------------------------------
bci_fake_temp3() ->
	[{userdata,[{wp, ""},
				{requirement, "CBD_FAULT_BCI_FU:1:A, CBD_FAULT_BCI_FU:3:A, CBD_FAULT_BCI_FU:4:A" ++
					 "CBD_FAULT_BCI_FU:5:A, CBD_FAULT_BCI_FU:7:A, CBD_FAULT_BCI_FU:10:A"},
				{slogan, "BCI - Temperature limits and thresholds, state Disabled"}]}].

bci_fake_temp3(_Config) ->
	bci_fake_temp("bci_fake_temp3", disabled).

%%------------------------------------------------------------------------------
%% $Id BCI_FAKE_TEMP4
%%
%% $Header
%%  BCI - Temperature sensor failure
%%
%% $Description
%%  Fake Temperature Sensor Failure and verify that temperature faults 
%%  handles correctly.
%%
%% $Requirements
%%  CBD_FAULT_BCI_FU:1:A
%%  CBD_FAULT_BCI_FU:3:A
%%  CBD_FAULT_BCI_FU:4:A
%%  CBD_FAULT_BCI_FU:8:A
%%  CBD_FAULT_BCI_FU:9:A
%%  CBD_FAULT_BCI_FU:10:A
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  BCI is in state starting.
%%  DP LMC is loaded.
%%  Subscription for BCI faults
%%
%% $Action_1
%%  Fake tempsensor failure with shellcommand "setTempFail 1"
%%
%% $Result_1
%%  A FAULT_IND signal received with parameters:
%%  faultId = TEMPERATURE_SENSOR_FAILURE
%%
%% $Action_2
%%  Check HWLog with shellcommand "dumpelg"
%%
%% $Result_2
%%  An entry "Temperature Sensor error" exists
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-05-30, QMAGSED
%%    First version
%%
%%  2013-11-11, EMASNOK
%%    Updated test case header
%%
%%------------------------------------------------------------------------------
bci_fake_temp4() ->
	[{userdata,[{wp, ""}, 
	 {requirement,  "CBD_FAULT_BCI_FU:1:A, CBD_FAULT_BCI_FU:3:A, CBD_FAULT_BCI_FU:4:A, " ++
					"CBD_FAULT_BCI_FU:8:A, CBD_FAULT_BCI_FU:9:A, CBD_FAULT_BCI_FU:10:A"},
	 {slogan, "BCI - Temperature sensor failure"}]}].

bci_fake_temp4(_Config) ->
	ct:pal("bci_fake_temp4"),

	{ok, session_up} = coli:subscribe_state(?SHELL_COMMAND),
	{ok, session_up} = osegw:subscribe_state(?OSE_GW_DEAMON_1),

	nci_bci_states:set_state([{state, starting_lmc_loaded}]),

	%% Clear HW Log
	nci_common_utils:clear_dumpelg(?SHELL_COMMAND),

	%% Connect to BCI interface
	ok = nci_bci_actions:conn_establish([{expectedSigNo, ?ELIB_BC_CONN_ESTABLISH_CFM}]),

	%% Subscribe Faults
	ok = nci_bci_actions:subscribe_faults([]),

	%% Fake sensor failure with cbu_command
	nci_common_utils:coli_cmd("setTempFail 1"),

	%% Receive fault ind
	ok = nci_bci_actions:fault_ind([{faultId, ?ELIB_CONST_FH_FAULT_ID_TEMPERATURE_SENSOR_FAILURE},
						{faultDescription, {regexp, "Temp fault*"}}]),

	%% Read HW log
	nci_common_utils:find_string_in_dumpelg(?SHELL_COMMAND, ".*sensor: \\d;Temperature Sensor error"),

	%% Stop fake sensor failure with cbu_command
	nci_common_utils:coli_cmd("setTempFail "),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000),

	nci_bci_states:cold_restart([]).

%%------------------------------------------------------------------------------
%% $Id BCI_FAKE_TEMP5
%%
%% $Header
%%  BCI - Temperature sensor failure when low temperature faults exist
%%
%% $Description
%%  Fake temperature sensor failure when low temperature faults exist.
%%  Verify that temperature and sensor faults handles correctly.
%%
%% $Requirements
%%  CBD_FAULT_BCI_FU:1:A
%%  CBD_FAULT_BCI_FU:3:A
%%  CBD_FAULT_BCI_FU:4:A
%%  CBD_FAULT_BCI_FU:8:A
%%  CBD_FAULT_BCI_FU:9:A
%%  CBD_FAULT_BCI_FU:10:A
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  BCI is in state starting.
%%  DP LMC is loaded.
%%  Subscription for BCI faults
%%
%% $Action_1
%%  Fake temperature <TempLimitLowExceptional> using shellcommand: setTemp
%%
%% $Result_1
%%  A FAULT_IND signal received with parameters:
%%  faultId = NORMAL_TEMPERATURE_TOO_LOW
%%
%% $Action_2
%%  Fake temperature <TempLimitLowNooperation> using shellcommand: setTemp
%%
%% $Result_2
%%  A FAULT_IND signal received with parameters:
%%  faultId = EXCEPTIONAL_TEMPERATURE_TOO_LOW
%%
%% $Action_3
%%  Check HWLog with shellcommand "dumpelg"
%%
%% $Result_3
%%  An entry "Exceptional temp too low;<TempLimitLowNooperation>C" exists
%%
%% $Action_4
%%  Fake tempsensor failure with shellcommand "setTempFail 1"
%%
%% $Result_4a
%%  A FAULT_IND signal received with parameters:
%%  faultId = TEMPERATURE_SENSOR_FAILURE
%%
%% $Result_4b
%%  A FAULTCEASE_IND signal received with parameters:
%%  faultId = EXCEPTIONAL_TEMPERATURE_TOO_LOW
%%
%% $Result_4c
%%  A FAULTCEASE_IND signal received parameters:
%%  faultId = NORMAL_TEMPERATURE_TOO_LOW
%%
%% $Action_5
%%  Check HWLog with shellcommand "dumpelg"
%%
%% $Result_5
%%  An entry "Temperature Sensor error" exists
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  2012-12-14, EEDAJA
%%
%% Revision history:
%%  2012-12-05, EJONUNA
%%    First version
%%
%%  2013-11-07, EMASNOK
%%   Introduced utility function for temperature limits. 
%%   Replaced temperature values in header with temperature-limit-names.
%%
%%------------------------------------------------------------------------------
bci_fake_temp5() ->
	[{userdata,[{wp, ""}, 
	 {requirement,  "CBD_FAULT_BCI_FU:1:A, CBD_FAULT_BCI_FU:3:A, CBD_FAULT_BCI_FU:4:A, " ++
					"CBD_FAULT_BCI_FU:8:A, CBD_FAULT_BCI_FU:9:A, CBD_FAULT_BCI_FU:10:A"},
	 {slogan, "BCI - Temperature sensor failure when low temperature faults exist"}]}].

bci_fake_temp5(_Config) ->
	ct:pal("bci_fake_temp5"),

	{ok, session_up} = coli:subscribe_state(?SHELL_COMMAND),
	{ok, session_up} = osegw:subscribe_state(?OSE_GW_DEAMON_1),

	nci_bci_states:set_state([{state, starting_lmc_loaded}]),

	nci_common_utils:clear_dumpelg(?SHELL_COMMAND),
	ok = nci_bci_actions:conn_establish([]),
	ok = nci_bci_actions:subscribe_faults([]),

	ct:pal("Action_1"),

	%% Fake temperature value for limit: low-exceptional
	LowTemp = nci_common_cfg:get_temp_param(lowExceptional),
	nci_common_utils:coli_cmd(io_lib:format("setTemp ~p",[LowTemp])),

	ct:pal("Result_1"),
	ok = nci_bci_actions:fault_ind([{faultId, ?ELIB_CONST_FH_FAULT_ID_NORMAL_TEMPERATURE_TOO_LOW}]),

	ct:pal("Action_2"),

	%% Get temperature value for limit: low-no-operation
	ExceptionalLowTemp = nci_common_cfg:get_temp_param(lowNoOperation),
	nci_common_utils:coli_cmd(io_lib:format("setTemp ~p",[ExceptionalLowTemp])),

	ct:pal("Result_2"),
	ok = nci_bci_actions:fault_ind([{faultId, ?ELIB_CONST_FH_FAULT_ID_EXCEPTIONAL_TEMPERATURE_TOO_LOW}]),

	ct:pal("Action_3"),
	nci_common_utils:find_string_in_dumpelg(?SHELL_COMMAND, io_lib:format(".*sensor: \\d;Exceptional temp too low;~pC",[ExceptionalLowTemp])),
	ct:pal("Action_4"),
	nci_common_utils:coli_cmd("setTempFail 1"),
	
	ct:pal("Result_4a"),
	ok = nci_bci_actions:fault_ind([{faultId, ?ELIB_CONST_FH_FAULT_ID_TEMPERATURE_SENSOR_FAILURE}]),
	ct:pal("Result_4b"),
	ok = nci_bci_actions:fault_cease_ind([{faultId, ?ELIB_CONST_FH_FAULT_ID_EXCEPTIONAL_TEMPERATURE_TOO_LOW}]),
	ct:pal("Result_4c"),
	ok = nci_bci_actions:fault_cease_ind([{faultId, ?ELIB_CONST_FH_FAULT_ID_NORMAL_TEMPERATURE_TOO_LOW}]),
	
	
	ct:pal("Action_5"),
	nci_common_utils:find_string_in_dumpelg(?SHELL_COMMAND, ".*sensor: \\d;Temperature Sensor error"),

	nci_common_utils:coli_cmd("setTemp"),
	nci_common_utils:coli_cmd("setTempFail 0"),
	
	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000),

	%%Restart needed in order to avoid temp sensor fault ind in eventual subsequent temp test case  
	LogString = string:concat("Test case ", string:to_upper("bci_fake_temp5")),
	nci_bci_states:restart_board( LogString ).


%%------------------------------------------------------------------------------
%% $Id BCI_FAKE_TEMP6
%%
%% $Header
%%  BCI - Temperature sensor failure when high temperature faults exist
%%
%% $Description
%%  Fake temperature sensor failure when high temperature faults exist.
%%  Verify that temperature and sensor faults handles correctly.
%%
%% $Requirements
%%  CBD_FAULT_BCI_FU:1:A
%%  CBD_FAULT_BCI_FU:3:A
%%  CBD_FAULT_BCI_FU:4:A
%%  CBD_FAULT_BCI_FU:8:A
%%  CBD_FAULT_BCI_FU:9:A
%%  CBD_FAULT_BCI_FU:10:A
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  BCI is in state starting.
%%  DP LMC is loaded.
%%  Subscription for BCI faults
%%
%% $Action_1
%%  Fake temperature <TempLimitHighExceptional> using shellcommand: setTemp
%%
%% $Result_1
%%  A FAULT_IND signal received with parameters:
%%  faultId = NORMAL_TEMPERATURE_TOO_HIGH
%%
%% $Action_2
%%  Fake temperature <TempLimitHighNooperation> using shellcommand: setTemp
%%
%% $Result_2
%%  A FAULT_IND signal received with parameters:
%%  faultId = EXCEPTIONAL_TEMPERATURE_TOO_HIGH
%%
%% $Action_3
%%  Check HWLog with shellcommand "dumpelg"
%%
%% $Result_3
%%  An entry "Exceptional temp too high;<TempLimitHighNooperation>C" exists
%%
%% $Action_4
%%  Fake tempsensor failure with shellcommand "setTempFail 1"
%%
%% $Result_4a
%%  A FAULT_IND signal received with parameters:
%%  faultId = TEMPERATURE_SENSOR_FAILURE
%%
%% $Result_4b
%%  A FAULTCEASE_IND signal received with parameters:
%%  faultId = EXCEPTIONAL_TEMPERATURE_TOO_HIGH
%%
%% $Result_4c
%%  A FAULTCEASE_IND signal received parameters:
%%  faultId = NORMAL_TEMPERATURE_TOO_HIGH
%%
%% $Action_5
%%  Check HWLog with shellcommand "dumpelg"
%%
%% $Result_5
%%  An entry "Temperature Sensor error" exists
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  2012-12-14, EEDAJA
%%
%% Revision history:
%%  2012-12-05, EJONUNA
%%    First version
%%
%%  2013-11-07, EMASNOK
%%    Introduced utility function for temperature limits.
%%    Replaced temperature values in header with temperature-limit-names.
%%
%%------------------------------------------------------------------------------
bci_fake_temp6() ->
	[{userdata,[{wp, ""}, 
	 {requirement,  "CBD_FAULT_BCI_FU:1:A, CBD_FAULT_BCI_FU:3:A, CBD_FAULT_BCI_FU:4:A, " ++
					"CBD_FAULT_BCI_FU:8:A, CBD_FAULT_BCI_FU:9:A, CBD_FAULT_BCI_FU:10:A"},
	 {slogan, "BCI - Temperature sensor failure when high temperature faults exist"}]}].

bci_fake_temp6(_Config) ->
	ct:pal("bci_fake_temp6"),

	{ok, session_up} = coli:subscribe_state(?SHELL_COMMAND),
	{ok, session_up} = osegw:subscribe_state(?OSE_GW_DEAMON_1),

	nci_bci_states:set_state([{state, starting_lmc_loaded}]),

	nci_common_utils:clear_dumpelg(?SHELL_COMMAND),
	ok = nci_bci_actions:conn_establish([]),
	ok = nci_bci_actions:subscribe_faults([]),

	ct:pal("Action_1"),
	HighTemp = nci_common_cfg:get_temp_param(highExceptional),
	nci_common_utils:coli_cmd(io_lib:format("setTemp ~p",[HighTemp])),
	
	ct:pal("Result_1"),
	ok = nci_bci_actions:fault_ind([{faultId, ?ELIB_CONST_FH_FAULT_ID_NORMAL_TEMPERATURE_TOO_HIGH}]),

	ct:pal("Action_2"),
	ExceptionalHighTemp = nci_common_cfg:get_temp_param(highNoOperation),
	nci_common_utils:coli_cmd(io_lib:format("setTemp ~p",[ExceptionalHighTemp])),

	ct:pal("Result_2"),
	ok = nci_bci_actions:fault_ind([{faultId, ?ELIB_CONST_FH_FAULT_ID_EXCEPTIONAL_TEMPERATURE_TOO_HIGH}]),

	ct:pal("Action_3"),
	nci_common_utils:find_string_in_dumpelg(
		?SHELL_COMMAND, 
		io_lib:format(".*sensor: \\d;Exceptional temp too high;.*~pC", [ExceptionalHighTemp])),

	ct:pal("Action_4"),
	nci_common_utils:coli_cmd("setTempFail 1"),
	
	ct:pal("Result_4a"),
	ok = nci_bci_actions:fault_ind([{faultId, ?ELIB_CONST_FH_FAULT_ID_TEMPERATURE_SENSOR_FAILURE}]),
	ct:pal("Result_4b"),
	ok = nci_bci_actions:fault_cease_ind([{faultId, ?ELIB_CONST_FH_FAULT_ID_EXCEPTIONAL_TEMPERATURE_TOO_HIGH}]),
	ct:pal("Result_4c"),
	ok = nci_bci_actions:fault_cease_ind([{faultId, ?ELIB_CONST_FH_FAULT_ID_NORMAL_TEMPERATURE_TOO_HIGH}]),
	
	
	ct:pal("Action_5"),
	nci_common_utils:find_string_in_dumpelg(?SHELL_COMMAND, ".*sensor: \\d;Temperature Sensor error"),

	nci_common_utils:coli_cmd("setTemp"),
	nci_common_utils:coli_cmd("setTempFail 0"),
	
	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000),

	%%Restart needed in order to avoid temp sensor fault ind in eventual subsequent temp test case  
	LogString = string:concat("Test case ", string:to_upper("bci_fake_temp6")),
	nci_bci_states:restart_board( LogString ).



%%------------------------------------------------------------------------------
%% $Id BCI_FAKE_TEMP7
%%
%% $Header
%%  BCI - Temperature limits and thresholds for all sensors, state Starting
%%
%% $Description
%%  BCI fake temperature faults, state Starting. Verify that temperature faults 
%%  handles correctly for all sensors.
%%
%% $Requirements
%%  CBD_FAULT_BCI_FU:1:A
%%  CBD_FAULT_BCI_FU:3:A
%%  CBD_FAULT_BCI_FU:4:A
%%  CBD_FAULT_BCI_FU:5:A
%%  CBD_FAULT_BCI_FU:7:A
%%  CBD_FAULT_BCI_FU:10:A
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  Ensure BCI is in state starting.
%%  DP LMC is loaded.
%%  Subscription for BCI faults.
%%  Temperature settings extracted from bvl parameters
%%
%% $Action_1
%%  Fake temperature <TempLimitLowExceptional> using shellcommand: setTemp
%%
%% $Result_1
%%  A FAULT_IND signal received with parameter:
%%  faultId = NORMAL_TEMPERATURE_TOO_LOW
%%
%% $Action_2
%%  Fake temperature <TempLimitLowNooperation> using shellcommand: setTemp
%%
%% $Result_2
%%  A FAULT_IND signal received with parameter:
%%  faultId = EXCEPTIONAL_TEMPERATURE_TOO_LOW
%%
%% $Action_3
%%  Fake temperature <TempLimitLowExceptional + 3> using shellcommand: setTemp
%%
%% $Result_3a
%%  A FAULTCEASE_IND signal received with parameter:
%%  faultId = EXCEPTIONAL_TEMPERATURE_TOO_LOW
%%
%% $Result_3b
%%  A FAULTCEASE_IND signal received with parameter:
%%  faultId = NORMAL_TEMPERATURE_TOO_LOW
%%
%% $Action_4
%%  Fake temperature <TempLimitHighExceptional> using shellcommand: setTemp
%%
%% $Result_4
%%  A FAULT_IND signal received with parameter:
%%  faultId = NORMAL_TEMPERATURE_TOO_HIGH
%%
%%
%% $Action_5
%%  Fake temperature <TempLimitHighNooperation> using shellcommand: setTemp
%%
%% $Result_5
%%  A FAULT_IND signal received with parameter:
%%  faultId = EXCEPTIONAL_TEMPERATURE_TOO_HIGH
%%
%% $Action_6
%%  Fake temperature <TempLimitHighExceptional - 3> using shellcommand: setTemp
%%
%% $Result_6a
%%  A FAULTCEASE_IND signal received with parameters:
%%  faultId = EXCEPTIONAL_TEMPERATURE_TOO_HIGH
%%
%% $Result_6b
%%  A FAULTCEASE_IND signal received with parameters:
%%  faultId = NORMAL_TEMPERATURE_TOO_HIGH
%%
%% $Action_7
%%  Repeat Action 1-6 for all bvl configured sensors
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%
%% Revision history:
%%  2014-01-10, ejonuna
%%    First version
%%
%%------------------------------------------------------------------------------
bci_fake_temp7() ->
	[{userdata,[{wp, ""}, 
	 {requirement,  "CBD_FAULT_BCI_FU:1:A, CBD_FAULT_BCI_FU:3:A, CBD_FAULT_BCI_FU:4:A, " ++
					"CBD_FAULT_BCI_FU:8:A, CBD_FAULT_BCI_FU:9:A, CBD_FAULT_BCI_FU:10:A"},
	 {slogan, "BCI - Temperature limits and thresholds for all sensors, state Starting"}]}].

bci_fake_temp7(_Config) ->
	ct:pal("bci_fake_temp7"),

	nci_bci_states:set_state([{state, starting_lmc_loaded}]),
	ok = nci_bci_actions:subscribe_faults([]),

	TempSensorList = nci_common_utils:get_bvl_temperature_parameters(),
	ct:pal("TempSensorList: ~p",[TempSensorList]),

	lists:foreach(
		fun({_GroupProperty,SensorData}) ->
				Address = integer_to_list(proplists:get_value(address,SensorData)),
				TempLimitLowExceptional = proplists:get_value(tempLimitLowExceptional,SensorData),
				TempLimitLowNooperation = proplists:get_value(tempLimitLowNooperation,SensorData),
				TempLimitHighExceptional = proplists:get_value(tempLimitHighExceptional,SensorData),
				TempLimitHighNooperation = proplists:get_value(tempLimitHighNooperation,SensorData),
				ct:pal("Testing sensor at Address: "++ Address),

				ct:pal("Action_1"),
				nci_common_utils:coli_cmd("setTemp " ++ integer_to_list(TempLimitLowExceptional) ++ " " ++ Address),
				ok = nci_bci_actions:fault_ind([{faultId, ?ELIB_CONST_FH_FAULT_ID_NORMAL_TEMPERATURE_TOO_LOW}]),

				ct:pal("Action_2"),
				nci_common_utils:coli_cmd("setTemp " ++ integer_to_list(TempLimitLowNooperation) ++ " " ++ Address),
				ok = nci_bci_actions:fault_ind([{faultId, ?ELIB_CONST_FH_FAULT_ID_EXCEPTIONAL_TEMPERATURE_TOO_LOW}]),

				%% Allowed temp is low limit + 3 degrees
				AllowedTempLow = TempLimitLowExceptional + 3,
				ct:pal("Action_3"),
				nci_common_utils:coli_cmd("setTemp " ++ integer_to_list(AllowedTempLow) ++ " " ++ Address),

				%% Receive fault cease ind
				ok = nci_bci_actions:fault_cease_ind([{faultId, ?ELIB_CONST_FH_FAULT_ID_EXCEPTIONAL_TEMPERATURE_TOO_LOW}]),
				ok = nci_bci_actions:fault_cease_ind([{faultId, ?ELIB_CONST_FH_FAULT_ID_NORMAL_TEMPERATURE_TOO_LOW}]),


				ct:pal("Action_4"),
				nci_common_utils:coli_cmd("setTemp " ++ integer_to_list(TempLimitHighExceptional) ++ " " ++ Address),
				ok = nci_bci_actions:fault_ind([{faultId, ?ELIB_CONST_FH_FAULT_ID_NORMAL_TEMPERATURE_TOO_HIGH}]),

				ct:pal("Action_5"),
				nci_common_utils:coli_cmd("setTemp " ++ integer_to_list(TempLimitHighNooperation) ++ " " ++ Address),
				ok = nci_bci_actions:fault_ind([{faultId, ?ELIB_CONST_FH_FAULT_ID_EXCEPTIONAL_TEMPERATURE_TOO_HIGH}]),
				
				%% Allowed temp is high limit - 3 degrees
				AllowedTempHigh = TempLimitHighExceptional - 3,
				ct:pal("Action_6"),
				nci_common_utils:coli_cmd("setTemp " ++ integer_to_list(AllowedTempHigh) ++ " " ++ Address),
				
				%% Receive fault cease ind
				ok = nci_bci_actions:fault_cease_ind([{faultId, ?ELIB_CONST_FH_FAULT_ID_EXCEPTIONAL_TEMPERATURE_TOO_HIGH}]),
				ok = nci_bci_actions:fault_cease_ind([{faultId, ?ELIB_CONST_FH_FAULT_ID_NORMAL_TEMPERATURE_TOO_HIGH}])

		end,
		TempSensorList),

	nci_common_utils:coli_cmd("setTemp"),
	
	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults().


%%##############################################################################
%% $ChapterH2 BBCLK supervision
%%
%%
%% $End
%%##############################################################################

%%------------------------------------------------------------------------------
%% $Id BCI_FI1
%%
%% $Header
%%  BBCLK not present
%%
%% $Description
%%  BCI Fault Indication, BBCLK not present. Generate and cease BBCLK not present fault
%%
%% $Requirements
%%  CBD_RICM_LTE-CLOCK-FAULT_FU:1:C
%%
%%  CBD_FAULT_BCI_FU:1:A
%%
%%  CBD_FAULT_BCI_FU:3:A
%%
%%  CBD_FAULT_BCI_FU:4:A
%%
%%  CBD_FAULT_BCI_FU:10:A
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  At least 1 RU
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  State is starting
%%  DP is loaded
%%  CPRI link is up
%%  BBCLK is enabled
%%
%% $Action_1
%%  Set BBCLK disabled
%%
%% $Result_1
%%  A FAULT_IND signal received with parameters:
%%
%%  faultId = CLOCK_FAULT
%%
%% $Action_2
%%  Check that HWLog contains entry for BBCLK being off
%%
%% $Action_3
%%  Set BBCLK enabled
%%
%% $Result_3
%%  A FAULTCEASE_IND signal received with parameters:
%%
%%  faultId = CLOCK_FAULT
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-12-27, EEDAJA
%%    First version
%%
%%  2014-04-01, UABPAR
%%    Removed superfluous code.
%%    Added hwConfigA requirement.
%%
%%------------------------------------------------------------------------------
bci_fi1() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_RICM_LTE-CLOCK-FAULT_FU:1:C, CBD_FAULT_BCI_FU:1:A, CBD_FAULT_BCI_FU:3:A, 
								CBD_FAULT_BCI_FU:4:A, CBD_FAULT_BCI_FU:10:A"},
				{slogan, "BCI Fault Indication, BBCLK not present"},
                {hwConfig, hwConfigA}]}].

bci_fi1(_Config) ->
	ct:pal("bci_fi1"),

	set_state_and_connect( starting_lmc_loaded ),

	Radio1 = nci_ricm_utils:get_first_radio(),

	%% Start CPRI
	ok = nci_dci_actions:start_cpri_link(Radio1),
	ok = nci_dci_actions:cpri_link_ind(Radio1 ++ [{typeOfUnit, '_'},{availStatus, 1}]),

	%% Erase HW log
	nci_common_utils:coli_cmd("erasehwlog", "Successfully erased all hw logs"),

	%% Disable BB CLK
	ct:pal("Action_1"),
	nci_common_utils:coli_cmd("tu c d", ""),


	ct:pal("Result_1"),
	ok = nci_dci_actions:cpri_link_ind(Radio1 ++ [{typeOfUnit, '_'},{availStatus, 0}]),
	ok = nci_bci_actions:fault_ind([{faultId, ?ELIB_CONST_FH_FAULT_ID_CLOCK_FAULT}]),

	ct:pal("Action_2"),
	ok = nci_common_utils:find_string_in_dumpelg(?SHELL_COMMAND, "BB Clock presence error"),


	%% Enable BB CLK
	ct:pal("Action_3"),
	nci_common_utils:coli_cmd("tu c e", ""),


	ct:pal("Result_3"),
	ok = nci_dci_actions:cpri_link_ind(Radio1 ++ [{typeOfUnit, '_'},{availStatus, 1}]),
	ok = nci_bci_actions:fault_cease_ind([{faultId, ?ELIB_CONST_FH_FAULT_ID_CLOCK_FAULT}]),

	ok = nci_dci_actions:reset_cpri_link(Radio1),
	ok = nci_dci_actions:reset_cpri_link_ind(Radio1),

	nci_common_utils:check_outstanding_faults(2000).




%%##############################################################################
%% $ChapterH2 Software designed traces
%%
%%
%% $End
%%##############################################################################

%%------------------------------------------------------------------------------
%% $Id BCI_DBC_1
%%
%% $Header
%%  O&M State
%%
%% $Description
%%  BCI Software designed traces O&M State
%%
%% $Requirements
%%  CBD_START-RESTART_BCI_OM:5:B
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  Ensure state is in starting
%%
%%  Clear TE log
%%
%% $Action_1
%%  Send a ENABLE_OPERATION_REQ
%%
%% $Result_1
%%  A ENABLE_OPERATION_CFM is received
%%
%% $Action_2
%%  Check TE log
%%
%% $Result_2
%%  An entry matching the regular expression "State change, interface: ELIB_BC.+O&M state: Operational" should exist
%%
%% $Action_3
%%  Send a DISABLE_OPERATION_REQ
%%
%% $Result_3
%%  A DISABLE_OPERATION_CFM is received
%%
%% $Action4_
%%  Check TE log with shellcommand "te log read"
%%
%% $Result_4
%%  An entry matching the regular expression "State change, interface: ELIB_BC.+O&M state: Disabled" should exist
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-05-30, QMAGSED
%%    First version
%%  2013-01-21, ejonuna
%%    Added enabling and disabling of trace1 NCI_COMMON to make trace detection work
%%
%%------------------------------------------------------------------------------
bci_dbc_1() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_START-RESTART_BCI_OM:5:B"},
				{slogan, "BCI Software designed traces O&M State"}]}].

bci_dbc_1(_Config) ->
	ct:pal("bci_dbc_1"),

	coli:cmd(?SHELL_COMMAND, "te e trace1 trace2 trace3 RICM_CONTROL"),

	{ok, session_up} = coli:subscribe_state(?SHELL_COMMAND),
	{ok, session_up} = osegw:subscribe_state(?OSE_GW_DEAMON_1),

	nci_bci_states:set_state([{state, starting_lmc_loaded}]),

	%% Connect to BCI interface
	ok = nci_bci_actions:conn_establish([{expectedSigNo, ?ELIB_BC_CONN_ESTABLISH_CFM}]),

	%% Enable operations
	ct:pal("Action_1"),
	coli:cmd(?SHELL_COMMAND, "te e trace1 NCI_COMMON"),
	ok = nci_bci_actions:enable_operation([]),

	%% Audit 
	ok = nci_bci_actions:audit([{expectedSigNo, ?ELIB_BC_AUDIT_CFM},
				{expectedMainState, ?ELIB_BC_MAIN_STATE_OPERATIONAL}]),	

	%% Find in TE log
	ct:pal("Action_2"),
	nci_common_utils:find_string_in_te_log(?SHELL_COMMAND, ".*State change, interface: ELIB_BC.+O&M state: Operational"),

	%% Disable operations
	ct:pal("Action_3"),
	ok = nci_bci_actions:disable_operation([]),
	
	%% Audit 
	ok = nci_bci_actions:audit([{expectedSigNo, ?ELIB_BC_AUDIT_CFM},
				{expectedMainState, ?ELIB_BC_MAIN_STATE_DISABLED}]),	

	%% Find in TE log
	ct:pal("Action_4"),
	nci_common_utils:find_string_in_te_log(?SHELL_COMMAND, ".*State change, interface: ELIB_BC.+O&M state: Disabled"),

	coli:cmd(?SHELL_COMMAND, "te d trace1 NCI_COMMON"),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id BCI_DBC_15
%%
%% $Header
%%  O&M Reject DB
%%
%% $Description
%%  BCI Software designed traces O&M Reject DB
%%
%% $Requirements
%%  CBD_START-RESTART_BCI_OM:5:B
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  Ensure state is in starting
%%
%%  Clear TE log
%%
%% $Action_1
%%  Send a CONN_ESTABLISH_REQ with parameters:
%%
%%  protocolRev = REV + 1
%%
%% $Result_1
%%  A CONN_ESTABLISH_REJ is received with 
%%
%%  errorCode = UNSUCCESSFUL
%%
%% $Action_2
%%  Check TE log with shellcommand "te log read"
%%
%% $Result_2
%%  An entry matching the regular expression "ABN:Signal rejected, signal: ELIB_BC_CONN_ESTABLISH_REJ.+error code: w+" should exist
%%
%% $Action_3
%%  Send a SET_VISUAL_INDICATION_REQ with parameters:
%%
%%  visualizedState = 0xFFFF
%%
%% $Result_3
%%  A SET_VISUAL_INDICATION_REJ is received with parameters:
%%
%%  errorCode = UNSUCCESSFUL
%%
%% $Action_4
%%  Check TE log shellcommand "te log read"
%%
%% $Result_4
%%  An entry matching the regular expression "ABN:Signal rejected, signal: ELIB_BC_SET_VISUAL_INDICATION_REJ.+error code: w+" should exist
%%
%% $Action_5
%%  6 clients sends a SUBSCRIBE_FAULTS_REQ each
%%
%% $Result_5
%%  6 clients receives a SUBSCRIBE_FAULTS_CFM each
%%
%% $Action_6
%%  Seventh client sends a SUBSCRIBE_FAULTS_REQ
%%
%% $Result_6
%%  Seventh client receives a SUBSCRIBE_FAULTS_REJ with parameters:
%%
%%  errorCode = UNSUCCESSFUL
%%
%%  errorDescription = "Too many subscribing clients already active"
%%
%% $Action_7
%%  Check TE log with shellcommand "te log read"
%%
%% $Result_7
%%  An entry matching the regular expression "ABN:Signal rejected, signal: ELIB_BC_SUBSCRIBE_FAULTS_REJ.+error code: w+" should exist
%%
%% $Action_8
%%  Send a LOAD_LMC_REQ with parameters:
%%
%%  loadModule = <Name of the LMC>
%%
%%  searchPath = <The directory it resides in on MP>
%%
%% $Result_8
%%  A LOAD_LMC_REJ is received with parameters:
%%
%%  errorCode = UNSUCCESSFUL
%%
%%  errorDescription = "DP already loaded and running"
%%
%% $Action_9
%%  Check TE log with shellcommand "te log read"
%%
%% $Result_9
%%  An entry matching the regular expression "ABN:Signal rejected, signal: ELIB_BC_LOAD_LMC_REJ.+error code: w+" should exist
%%
%% $Action_10
%%  Send a ETH_SETUP_HW_IF_REQ with parameters:
%%
%%  numOfEthHwifMacAddresses = 1
%%
%%  Valid ethHwifMacAddressParam = from get_mac
%%
%%  Valid addressFilterMask = 0x20
%%
%% $Result_10
%%  A ETH_SETUP_HW_IF_REJ is received with parameters:
%%
%%  errorCode = UNSUCCESSFUL
%%
%%  errorDescription = "Invalid O&M state"
%%
%% $Action_11
%%  Check TE log with shellcommand "te log read"
%%
%% $Result_11
%%  An entry matching the regular expression "ABN:Signal rejected, signal: ELIB_BC_ETH_SETUP_HW_IF_REJ.+error code: w+" should exist
%%
%% $Action_12
%%  Send a DISABLE_OPERATION_REQ
%%
%% $Result_12
%%  A DISABLE_OPERATION_CFM is received
%%
%% $Action_13
%%  Send a ENABLE_OPERATION_REQ
%%
%% $Result_13
%%  A ENABLE_OPERATION_REJ received with parameters:
%%
%%  errorCode= UNSUCCESSFUL
%%
%%  errorDescription = "Invalid O&M state"
%%
%% $Action_14
%%  Check TE log with shellcommand "te log read"
%%
%% $Result_14
%%  An entry matching the regular expression "ABN:Signal rejected, signal: ELIB_BC_ENABLE_OPERATION_REJ.+error code: w+" should exist
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  2013-01-17, eyanwzh
%%
%% Revision history:
%%  2012-12-27, EEDAJA
%%    First version
%%  2013-02-06, ejonuna
%%    Removed the allowed ERROR message in the te e log since it isn't allowed
%%------------------------------------------------------------------------------
bci_dbc_15() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_START-RESTART_BCI_OM:5:B"},
				{slogan, "BCI Software designed traces O&M Reject DB"}]}].

bci_dbc_15(_Config) ->
	ct:pal("bci_dbc_15"),

	{ok, session_up} = coli:subscribe_state(?SHELL_COMMAND),
	{ok, session_up} = osegw:subscribe_state(?OSE_GW_DEAMON_1),

	nci_bci_states:set_state([{state, starting_lmc_loaded}]),

	ct:pal("Action_1"),
	ok = nci_bci_actions:conn_establish([{protocolRev, ?ELIB_BC_REV + 1},
										{expectedSigNo, ?ELIB_BC_CONN_ESTABLISH_REJ},
										{errorCode, 1},
										{errorDescription, {regexp, "Invalid protocol revision*"}}]),
	%% Find in TE log
	ct:pal("Action_2"),
	nci_common_utils:find_string_in_te_log(?SHELL_COMMAND, ".*ABN:Signal rejected, signal: ELIB_BC_CONN_ESTABLISH_REJ.*"),

	%% VII ELIB_BC_VISUAL_STATE_LOAD_TEST_IN_PROGRESS
	ct:pal("Action_3"),
	nci_bci_actions:set_vii([{expectedSigNo, ?ELIB_BC_SET_VISUAL_INDICATION_REJ},
						{visualizedState, 16#FFFF},
						{errorCode, 1}]),
	%% Find in TE log
	ct:pal("Action_4"),
	nci_common_utils:find_string_in_te_log(?SHELL_COMMAND, ".*ABN:Signal rejected, signal: ELIB_BC_SET_VISUAL_INDICATION_REJ.*"),

	%% Create 6 more GWs
	ok = osegw:create(#osegw{name = ?OSE_GW_DEAMON_2, 
				 iap = osegw, 
				 opt = [{ping_timeout, 6000}, 
					{codec_config, 
					{?SIG_MODS, 
					 sizeof, 
						 osegw_ose,big}}]}),
	ok = osegw:create(#osegw{name = ?OSE_GW_DEAMON_3, 
				 iap = osegw, 
				 opt = [{ping_timeout, 6000}, 
					{codec_config, 
					{?SIG_MODS, 
					 sizeof, 
						 osegw_ose,big}}]}),
	ok = osegw:create(#osegw{name = ?OSE_GW_DEAMON_4, 
				 iap = osegw, 
				 opt = [{ping_timeout, 6000}, 
					{codec_config, 
					{?SIG_MODS, 
					 sizeof, 
						 osegw_ose,big}}]}),
	ok = osegw:create(#osegw{name = ?OSE_GW_DEAMON_5, 
				 iap = osegw, 
				 opt = [{ping_timeout, 6000}, 
					{codec_config, 
					{?SIG_MODS, 
					 sizeof, 
						 osegw_ose,big}}]}),
	ok = osegw:create(#osegw{name = ?OSE_GW_DEAMON_6, 
				 iap = osegw, 
				 opt = [{ping_timeout, 6000}, 
					{codec_config, 
					{?SIG_MODS, 
					 sizeof, 
						 osegw_ose,big}}]}),
	ok = osegw:create(#osegw{name = ?OSE_GW_DEAMON_7, 
				 iap = osegw, 
				 opt = [{ping_timeout, 6000}, 
					{codec_config, 
					{?SIG_MODS, 
					 sizeof, 
						 osegw_ose,big}}]}),

	%% First Client Connect to BCI interface
	ok = nci_bci_actions:conn_establish([{oseGwDeamon,?OSE_GW_DEAMON_1},
				 		 {expectedSigNo, ?ELIB_BC_CONN_ESTABLISH_CFM}]),
	%% Subscribe Faults
	ct:pal("Action_6"),
	ok = nci_bci_actions:subscribe_faults([{oseGwDeamon,?OSE_GW_DEAMON_1}]),
	ok = nci_bci_actions:subscribe_faults([{oseGwDeamon,?OSE_GW_DEAMON_2}]),
	ok = nci_bci_actions:subscribe_faults([{oseGwDeamon,?OSE_GW_DEAMON_3}]),
	ok = nci_bci_actions:subscribe_faults([{oseGwDeamon,?OSE_GW_DEAMON_4}]),
	ok = nci_bci_actions:subscribe_faults([{oseGwDeamon,?OSE_GW_DEAMON_5}]),
	ok = nci_bci_actions:subscribe_faults([{oseGwDeamon,?OSE_GW_DEAMON_6}]),

	%% Subscribe Faults should fail
	ct:pal("Action_7"),
	ok = nci_bci_actions:subscribe_faults([{oseGwDeamon,?OSE_GW_DEAMON_7},
						   {expectedSigNo, ?ELIB_BC_SUBSCRIBE_FAULTS_REJ},
						   {errorCode, 1},
						   {errorDescription, {regexp, "Too many subscribing clients already active*"}}]),
	%% Find in TE log
	ct:pal("Action_7"),
	nci_common_utils:find_string_in_te_log(?SHELL_COMMAND, ".*.*ABN:Signal rejected, signal: ELIB_BC_SUBSCRIBE_FAULTS_REJ.*"),

	%% Load LMC
	ct:pal("Action_8"),
	LoadModule = get_lmc_name(),
	SearchPath = nci_common_cfg:get_c_loadmodules_path(),
	ok = nci_bci_actions:load_lmc([ {searchPath, SearchPath},
									{loadModule, LoadModule},
									{expectedSigNo, ?ELIB_BC_LOAD_LMC_REJ},
									{errorCode, 1},
									{errorDescription, {regexp, "DP already loaded and running*"}}]),
	%% Find in TE log
	ct:pal("Action_9"),
	nci_common_utils:find_string_in_te_log(?SHELL_COMMAND, ".*ABN:Signal rejected, signal: ELIB_BC_LOAD_LMC_REJ.*"),

	%% Setup HW IF
	ct:pal("Action_10"),
	ElibBcEthHwifMacAddress = [#'ElibBcEthHwifMacAddressParamS'{snid = 1,
									padding0 = 0,
									macAddress = [0,30,223,200,190,50],
									padding1 = 0}],

	ok = nci_bci_actions:eth_setup_hw_if([{numOfEthHwifMacAddresses, 1},
						  {ethHwifMacAddressParam, ElibBcEthHwifMacAddress},
						  {addressFilterMask, 16#20},
						  {expectedSigNo, ?ELIB_BC_ETH_SETUP_HW_IF_REJ},
						  {errorCode, 1},
						  {errorDescription, {regexp, "Invalid O&M state*"}}]),
	%% Find in TE log
	ct:pal("Action_11"),
	nci_common_utils:find_string_in_te_log(?SHELL_COMMAND, ".*ABN:Signal rejected, signal: ELIB_BC_ETH_SETUP_HW_IF_REJ.*"),

	%% Disable operations
	ct:pal("Action_12"),
	ok = nci_bci_actions:disable_operation([]),

	%% Enable operations
	ct:pal("Action_13"),
	ok = nci_bci_actions:enable_operation([{expectedSigNo, ?ELIB_BC_ENABLE_OPERATION_REJ},
											{errorCode, 1},
											{errorDescription, {regexp, "Invalid O&M state*"}}]),
	%% Find in TE log
	ct:pal("Action_14"),
	nci_common_utils:find_string_in_te_log(?SHELL_COMMAND, ".*ABN:Signal rejected, signal: ELIB_BC_ENABLE_OPERATION_REJ.*"),

	%% Kill GWs
	ok = osegw:delete(?OSE_GW_DEAMON_2),
	ok = osegw:delete(?OSE_GW_DEAMON_3),
	ok = osegw:delete(?OSE_GW_DEAMON_4),
	ok = osegw:delete(?OSE_GW_DEAMON_5),
	ok = osegw:delete(?OSE_GW_DEAMON_6),
	ok = osegw:delete(?OSE_GW_DEAMON_7),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%##############################################################################
%% $ChapterH2 Add Radio Control
%%
%%
%% $End
%%##############################################################################

%%------------------------------------------------------------------------------
%% $Id DCI_ARC1
%%
%% $Header
%%  State Starting
%%
%% $Description
%%  Verify add radio control in state starting
%%
%% $Requirements
%%  CBD_RICM_DCI-ADD-RADIO-CTL_FU:1:C
%%
%%  CBD_RICM_EL1CI-REG-ESTABLISH_FU:1:C
%%
%%  CBD_RICM_EL1CI-LTE-ECP_X_FU:1:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state starting.
%%
%%  CPRI Link is up for first radio
%%
%% $Action
%%  Send an ADD_RADIO_CTL_REQ
%%
%% $Result
%%  An ADD_RADIO_CTL_CFM is received
%%
%% $Result
%%  An ADD_RADIO_CTL_IND is received with
%%
%%  connStatus = 1
%%
%% $Action
%%  Test the connection with shellcommand "lhsh BXP_3_1 lmclist"
%%
%% $Result
%%  The shellcommand is successful
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-05-30, QMAGSED
%%    First version
%%
%%------------------------------------------------------------------------------
dci_arc1() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_RICM_DCI-ADD-RADIO-CTL_FU:1:C, CBD_RICM_EL1CI-REG-ESTABLISH_FU:1:C, CBD_RICM_EL1CI-LTE-ECP_X_FU:1:C"},
				{slogan, "State Starting"},
				{hwConfig, hwConfigA}]}].

dci_arc1(_Config) ->
	dci_arc("dci_arc1", starting_lmc_loaded).


dci_arc(Name, State) ->
	ct:pal(Name),

	% Set state, make audit, establish BCI and DCI connections, subscribe faults
	set_state_and_connect( State ),

	%% Subscribe Faults DCI
	ok = nci_dci_actions:subscribe_faults([]),
	
	Radio1 = nci_ricm_utils:get_first_radio(),
	RuLnhPath = proplists:get_value(ruLnhPath, Radio1),

	%% Start CPRI
	ok = nci_dci_actions:start_cpri_link(Radio1),

	ok = nci_dci_actions:cpri_link_ind(Radio1 ++ [{typeOfUnit, '_'},{availStatus, 1}]),

	%% Add Radio Control
	nci_dci_actions:add_radio_control(Radio1 ++ [{expectedSigNo, ?RICM_ADD_RADIO_CTL_CFM}]),

	nci_dci_actions:radio_control_ind(Radio1 ++ [{connStatus, 1}]),

	nci_common_utils:coli_cmd("lhsh " ++ RuLnhPath ++ " lmclist", "SlotProt State"),

	%% Reset CPRI Link
	ok = nci_dci_actions:reset_cpri_link(Radio1),

	ok = nci_dci_actions:reset_cpri_link_ind(Radio1),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id DCI_ARC2
%%
%% $Header
%%  State Operational
%%
%% $Description
%%  Verify add radio control in state operational
%%
%% $Requirements
%%  CBD_RICM_DCI-ADD-RADIO-CTL_FU:1:C
%%
%%  CBD_RICM_EL1CI-REG-ESTABLISH_FU:1:C
%%
%%  CBD_RICM_EL1CI-LTE-ECP_X_FU:1:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  The DU BC is in state starting.
%%
%%  CPRI Link is up for the first radio
%%
%% $Action
%%  Send an ADD_RADIO_CTL_REQ
%%
%% $Result
%%  An ADD_RADIO_CTL_CFM is received
%%
%% $Result
%%  An ADD_RADIO_CTL_IND is received with
%%
%%  connStatus = 1
%%
%%  huntPath = BXP_0_1
%%
%% $Action
%%  Test the connection with shellcommand "lhsh BXP_0_1 lmclist"
%%
%% $Result
%%  The shellcommand is successful
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-05-30, QMAGSED
%%    First version
%%
%%------------------------------------------------------------------------------
dci_arc2() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_RICM_DCI-ADD-RADIO-CTL_FU:1:C, CBD_RICM_EL1CI-REG-ESTABLISH_FU:1:C, CBD_RICM_EL1CI-LTE-ECP_X_FU:1:C"},
				{slogan, "State Operational"},
				{hwConfig, hwConfigA}]}].

dci_arc2(_Config) ->
	dci_arc("dci_arc2", operational).

%%------------------------------------------------------------------------------
%% $Id DCI_ARC3
%%
%% $Header
%%  State Disabled
%%
%% $Description
%%  Verify add radio control in state disabled
%%
%% $Requirements
%%  CBD_RICM_DCI-ADD-RADIO-CTL_FU:1:C
%%
%%  CBD_RICM_EL1CI-REG-ESTABLISH_FU:1:C
%%
%%  CBD_RICM_EL1CI-LTE-ECP_X_FU:1:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state disabled.
%%
%%  CPRI Link is up for the first radio
%%
%% $Action
%%  Send a ADD_RADIO_CTL_REQ
%%
%% $Result
%%  A ADD_RADIO_CLT_REJ is received with parameters:
%%
%%  errorCode = UNSUCCESSFUL
%%
%%  errorDescription = Invalid O&M state
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  2012-10-16, EYANWZH
%%
%% Revision history:
%%  2012-10-02, EEDAJA
%%    First version
%%
%%  2012-10-16, EEDAJA
%%    Minor changes after review
%%
%%------------------------------------------------------------------------------
dci_arc3() ->
	[{userdata,[{wp, ""},
				{requirement, "CBD_RICM_DCI-ADD-RADIO-CTL_FU:1:C, CBD_RICM_EL1CI-REG-ESTABLISH_FU:1:C, CBD_RICM_EL1CI-LTE-ECP_X_FU:1:C"},
				{slogan, "Verify add radio control in state disabled"},
				{hwConfig, hwConfigA}]}].

dci_arc3(_Config) ->
	ct:pal("dci_arc3"),

	% Set state, make audit, establish BCI and DCI connections, subscribe faults
	set_state_and_connect( starting_lmc_loaded ),

	%% Subscribe Faults DCI
	ok = nci_dci_actions:subscribe_faults([]),
	
	Radio1 = nci_ricm_utils:get_first_radio(),

	%% Start CPRI
	ok = nci_dci_actions:start_cpri_link(Radio1),

	ok = nci_dci_actions:cpri_link_ind(Radio1 ++ [{typeOfUnit, '_'},{availStatus, 1}]),
			
	nci_bci_states:set_state([{state, disabled}]),
			
	%% Add Radio Control
	nci_dci_actions:add_radio_control(Radio1 ++ [
										{expectedSigNo, ?RICM_ADD_RADIO_CTL_REJ},
										{errorCode, 1},
										{errorDescription, {regexp, "Invalid O&M state*"}}]),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).


%%------------------------------------------------------------------------------
%% $Id DCI_ARC4
%%
%% $Header
%%  CPRI Link Not Up
%%
%% $Description
%%  Verify add radio control when the CPRI link is not up
%%
%% $Requirements
%%  CBD_RICM_DCI-ADD-RADIO-CTL_FU:1:C
%%
%%  CBD_RICM_EL1CI-REG-ESTABLISH_FU:1:C
%%
%%  CBD_RICM_EL1CI-LTE-ECP_X_FU:1:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state starting
%%
%%  CPRI Link is up for the first radio
%%
%% $Action
%%  Send a ADD_RADIO_CTL_REQ
%%
%% $Result
%%  A ADD_RADIO_CLT_REJ is received with parameters:
%%
%%  errorCode = UNSUCCESSFUL
%%
%%  errorDescription = "ruId not in use"
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  2012-11-04, EJONUNA
%%
%% Revision history:
%%  2012-10-15, EYANWZH
%%    First version
%%
%%------------------------------------------------------------------------------
dci_arc4() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_RICM_DCI-ADD-RADIO-CTL_FU:1:C, CBD_RICM_EL1CI-REG-ESTABLISH_FU:1:C, CBD_RICM_EL1CI-LTE-ECP_X_FU:1:C"},
				{slogan, "ruId not in use"},
				{hwConfig, hwConfigA}]}].

dci_arc4(_Config) ->
	ct:pal("dci_arc4"),

	% Set state, make audit, establish BCI and DCI connections, subscribe faults
	set_state_and_connect( starting_lmc_loaded ),

	%% Subscribe Faults DCI
	ok = nci_dci_actions:subscribe_faults([]),
	
	Radio1 = nci_ricm_utils:get_first_radio(),

	%% Add Radio Control
	nci_dci_actions:add_radio_control(Radio1 ++ [
										{expectedSigNo, ?RICM_ADD_RADIO_CTL_REJ},
										{errorCode, 1},
										{errorDescription, {regexp, "ruId not in use*"}}]),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id DCI_ARC5
%%
%% $Header
%%  Already Added
%%
%% $Description
%%  Verify add radio control when  link is already established
%%
%% $Requirements
%%  CBD_RICM_DCI-ADD-RADIO-CTL_FU:1:C
%%
%%  CBD_RICM_EL1CI-REG-ESTABLISH_FU:1:C
%%
%%  CBD_RICM_EL1CI-LTE-ECP_X_FU:1:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state starting
%%
%%  Radio control for the first radio has been added
%%
%% $Action
%%  Send a ADD_RADIO_CTL_REQ
%%
%% $Result
%%  An ADD_RADIO_CTL_IND is received with parameters:
%%
%%  connStatus = 1
%%
%%  huntPath = BXP_0_1
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  2012-11-05, EJONUNA
%%
%% Revision history:
%%  2012-10-15, EYANWZH
%%    First version
%%
%%------------------------------------------------------------------------------
dci_arc5() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_RICM_DCI-ADD-RADIO-CTL_FU:1:C, CBD_RICM_EL1CI-REG-ESTABLISH_FU:1:C, CBD_RICM_EL1CI-LTE-ECP_X_FU:1:C"},
				{slogan, "Link already established"},
				{hwConfig, hwConfigA}]}].

dci_arc5(_Config) ->
	ct:pal("dci_arc5"),

	% Set state, make audit, establish BCI and DCI connections, subscribe faults
	set_state_and_connect( starting_lmc_loaded ),

	%% Subscribe Faults DCI
	ok = nci_dci_actions:subscribe_faults([]),
	
	Radio1 = nci_ricm_utils:get_first_radio(),
	RuLnhPath = proplists:get_value(ruLnhPath, Radio1),

	%% Start CPRI
	ok = nci_dci_actions:start_cpri_link(Radio1),

	ok = nci_dci_actions:cpri_link_ind(Radio1 ++ [{typeOfUnit, '_'},{availStatus, 1}]),

	%% Add Radio Control
	nci_dci_actions:add_radio_control(Radio1 ++ [{expectedSigNo, ?RICM_ADD_RADIO_CTL_CFM}]),

	nci_dci_actions:radio_control_ind(Radio1 ++ [{connStatus, 1}]),

	nci_common_utils:coli_cmd("lhsh " ++ RuLnhPath ++ " lmclist", "SlotProt State"),

	%% Add Radio Control again
	nci_dci_actions:add_radio_control(Radio1 ++ [{expectedSigNo, ?RICM_ADD_RADIO_CTL_CFM}]),

	nci_dci_actions:radio_control_ind(Radio1 ++ [{connStatus, 1}]),

	nci_common_utils:coli_cmd("lhsh " ++ RuLnhPath ++ " lmclist", "SlotProt State"),

	%% Reset CPRI Link
	ok = nci_dci_actions:reset_cpri_link(Radio1),

	ok = nci_dci_actions:reset_cpri_link_ind(Radio1),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id DCI_ARC8
%%
%% $Header
%%  DP not loaded
%%
%% $Description
%%  Add Radio Control, DP not loaded
%%
%% $Requirements
%%  CBD_RICM_DCI-ADD-RADIO-CTL_FU:1:C
%%
%%  CBD_RICM_EL1CI-REG-ESTABLISH_FU:1:C
%%
%%  CBD_RICM_EL1CI-LTE-ECP_X_FU:1:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  The LMC is NOT loaded
%%
%% $Action
%%  Send a ADD_RADIO_CTL_REQ
%%
%% $Result
%%  A ADD_RADIO_CTL_REJ is received with
%%
%%  errorCode = UNSUCCESSFUL
%%
%%  errorDescription = "DP not loaded"
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-05-30, QMAGSED
%%    First version
%%
%%------------------------------------------------------------------------------
dci_arc8() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_RICM_DCI-ADD-RADIO-CTL_FU:1:C, CBD_RICM_EL1CI-REG-ESTABLISH_FU:1:C, CBD_RICM_EL1CI-LTE-ECP_X_FU:1:C"},
				{slogan, "DP not loaded"},
				{hwConfig, hwConfigA}]}].

dci_arc8(_Config) ->
	ct:pal("dci_arc8"),

	% Set state, make audit, establish BCI and DCI connections, subscribe faults
	set_state_and_connect( starting_lmc_not_loaded ),

	%% Subscribe Faults DCI
	ok = nci_dci_actions:subscribe_faults([]),

	Radio1 = nci_ricm_utils:get_first_radio(),

	%% Start CPRI
	ok = nci_dci_actions:start_cpri_link(Radio1 ++ [{expectedSigNo, ?RICM_START_CPRI_LINK_REJ}]),

	%% Add Radio Control
	nci_dci_actions:add_radio_control(Radio1 ++ [
										{expectedSigNo, ?RICM_ADD_RADIO_CTL_REJ},
										{errorCode, 1},
										{errorDescription, {regexp, "DP not loaded*"}}]),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id DCI_ARC9
%%
%% $Header
%%  ruId out of range and max value
%%
%% $Description
%%  Add Radio Control, Invalid ruId. Supported range is 1-65535
%%
%% $Requirements
%%  CBD_RICM_DCI-ADD-RADIO-CTL_FU:1:C
%%
%%  CBD_RICM_EL1CI-REG-ESTABLISH_FU:1:C
%%
%%  CBD_RICM_EL1CI-LTE-ECP_X_FU:1:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state starting.
%%
%%  CPRI link is UP with ruId = 65535, port 4 and cascade 1
%%
%% $Action
%%  Send a ADD_RADIO_CTL_REQ with parameters:
%%
%%  ruId = 0
%%
%% $Result
%%  A ADD_RADIO_CTL_REJ is received with parameters:
%%
%%  ruId = 1
%%
%%  errorCode = UNSUCCESSFUL
%%
%%  errorDescription = "Invalid ruId"
%%
%% $Action
%%  Send a ADD_RADIO_CTL_REQ with parameters:
%%
%%  ruId = 65535
%%
%% $Result
%%  A ADD_RADIO_CTL_CFM is received with parameters:
%%
%%  ruId = 65535
%%
%% $Result
%%  A ADD_RADIO_CTL_IND is received with parameters:
%%
%%  ruId = 65535 
%%
%%  connStatus = 1 
%%
%%  huntPath = BXP_3_1
%%
%% $Action
%%  Test the connection with shellcommand "lhsh BXP_3_1 lmclist"
%%
%% $Result
%%  The shellcommand is successful
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  2012-12-17, EJONUNA
%%
%% Revision history:
%%  2012-12-06, EEDAJA
%%    First version
%%
%%------------------------------------------------------------------------------
dci_arc9() ->
	[{userdata,[{wp, ""},
				{requirement, "CBD_RICM_DCI-ADD-RADIO-CTL_FU:1:C, CBD_RICM_EL1CI-REG-ESTABLISH_FU:1:C, CBD_RICM_EL1CI-LTE-ECP_X_FU:1:C"},
				{slogan, "Invalid ruId"},
				{hwConfig, hwConfigA}]}].

dci_arc9(_Config) ->
	ct:pal("dci_arc9"),

	% Set state, make audit, establish BCI and DCI connections, subscribe faults
	set_state_and_connect( starting_lmc_loaded ),

	%% Subscribe Faults DCI
	ok = nci_dci_actions:subscribe_faults([]),

	Radio1 = nci_ricm_utils:get_first_radio(),
	RuId = proplists:get_value(ruId,Radio1),
	RuLnhPath = proplists:get_value(ruLnhPath, Radio1),
	Radio1new = (Radio1 -- [{ruId,RuId}]) ++ [{ruId, 0}],
	Radio1new2 = (Radio1 -- [{ruId,RuId}]) ++ [{ruId, 16#ffff}],

	ok = nci_dci_actions:start_cpri_link(Radio1new2),

	ok = nci_dci_actions:cpri_link_ind(Radio1new2 ++ [
										{typeOfUnit, '_'},
										{availStatus, 1}]),
	%% Add Radio Control with invalid ruId
	nci_dci_actions:add_radio_control(Radio1new ++ [
										{expectedSigNo, ?RICM_ADD_RADIO_CTL_REJ},
										{errorCode, 1},
										{errorDescription, {regexp, "Invalid ruId*"}}]),

	%% Add Radio Control with max value of ruId
	nci_dci_actions:add_radio_control(Radio1new2 ++ [
				   {expectedSigNo, ?RICM_ADD_RADIO_CTL_CFM}]),

	nci_dci_actions:radio_control_ind(Radio1new2 ++ [
					{connStatus, 1}]),

	nci_common_utils:coli_cmd("lhsh " ++ RuLnhPath ++ " lmclist", "SlotProt State"),

	%% Reset CPRI Link
	ok = nci_dci_actions:reset_cpri_link(Radio1new2),

	ok = nci_dci_actions:reset_cpri_link_ind(Radio1new2),

	nci_common_utils:clean_signal_queue(), % sometimes there is a Not in operation fault / fault cease

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id DCI_ARC10
%%
%% $Header
%%  No RU then connect/disconnect RU
%%
%% $Description
%%  Add Radio Control, No RU then connect/disconnect RU
%%
%% $Requirements
%%  CBD_RICM_DCI-ADD-RADIO-CTL_FU:1:C
%%
%%  CBD_RICM_EL1CI-REG-ESTABLISH_FU:1:C
%%
%%  CBD_RICM_EL1CI-LTE-ECP_X_FU:1:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state starting
%%
%%  CPRI link is started with ruId = 1, port 4 and cascade 1, no indication is received
%%
%% $Action
%%  Send a ADD_RADIO_CTL_REQ with parameters:
%%
%%  ruId = 1
%%
%% $Result
%%  A ADD_RADIO_CTL_CFM is received with parameters:
%%
%%  ruId = 1
%%
%% $Action
%%  Sleep for 65 seconds
%%
%% $Result
%%  -
%%
%% $Action
%%  Connect a RU to port 4
%%
%% $Result
%%  A START_CPRI_LINK_IND is received with parameters:
%%
%%  ruId = 1
%%
%%  typeOfUnit = <ignored>
%%
%%  availStatus = 1
%%
%% $Result
%%  A ADD_RADIO_CTL_IND is received with parameters:
%%
%%  ruId = 1
%%
%%  connStatus = 1
%%
%%  huntPath = BXP_3_1
%%
%% $Action
%%  Test the connection with shellcommand "lhsh BXP_3_1 lmclist"
%%
%% $Result
%%  The shellcommand is successful
%%
%% $Action
%%  Disconnect a RU on port 4
%%
%% $Result
%%  A START_CPRI_LINK_IND is received with parameters:
%%
%%  ruId = 1
%%
%%  typeOfUnit = <ignored>
%%
%%  availStatus = 0
%%
%% $Result
%%  A ADD_RADIO_CTL_IND is received with parameters:
%%
%%  ruId = 1
%%
%%  connStatus = 0
%%
%%  huntPath = BXP_3_1
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%    First version
%%
%%------------------------------------------------------------------------------


%%------------------------------------------------------------------------------
%% $Id DCI_ARC11
%%
%% $Header
%%  Disconnect/re-connect RU
%%
%% $Description
%%  Add Radio Control, disconnect/re-connect RU
%%
%% $Requirements
%%  CBD_RICM_DCI-ADD-RADIO-CTL_FU:1:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state starting
%%
%%  CPRI link is up with ruId = 1, port 4 and cascade 1
%%
%% $Action
%%  Send a ADD_RADIO_CTL_REQ with parameters:
%%
%%  ruId = 1
%%
%% $Result
%%  A ADD_RADIO_CTL_CFM is received with parameters:
%%
%%  ruId = 1
%%
%% $Result
%%  A ADD_RADIO_CTL_IND is received with parameters:
%%
%%  ruId = 1
%%
%%  connStatus = 1
%%
%%  huntPath = BXP_3_1
%%
%% $Action
%%  Test the connection with shellcommand "lhsh BXP_3_1 lmclist"
%%
%% $Result
%%  The shellcommand is successful
%%
%% $Action
%%  Disconnect a RU on port 4
%%
%% $Result
%%  A START_CPRI_LINK_IND is received with parameters:
%%
%%  ruId = 1
%%
%%  typeOfUnit = <ignored>
%%
%%  availStatus = 0
%%
%% $Result
%%  A ADD_RADIO_CTL_IND is received with parameters:
%%
%%  ruId = 1
%%
%%  connStatus = 0
%%
%%  huntPath = BXP_3_1
%%
%% $Action
%%  Sleep for 65 seconds
%%
%% $Result
%%  -
%%
%% $Action
%%  Connect a RU to port 4
%%
%% $Result
%%  A START_CPRI_LINK_IND is received with parameters:
%%
%%  ruId = 1
%%
%%  typeOfUnit = <ignored>
%%
%%  availStatus = 1
%%
%% $Result
%%  A ADD_RADIO_CTL_IND is received with parameters:
%%
%%  ruId = 1
%%
%%  connStatus = 1
%%
%%  huntPath = BXP_3_1
%%
%% $Action
%%  Test the connection with shellcommand "lhsh BXP_3_1 lmclist"
%%
%% $Result
%%  The shellcommand is successful
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%    First version
%%
%%------------------------------------------------------------------------------



%%------------------------------------------------------------------------------
%% $Id DCI_ARC12
%%
%% $Header
%%  Connect to a non existing radio.
%%
%% $Description
%%    Start CPRI link and Add radio control to a non existing radio,
%%
%% $Requirements
%%  CBD_RICM_DCI-ADD-RADIO-CTL_FU:1:C
%%
%% $External References
%%  -
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state starting.
%%
%% $Action 1
%%  Send a RICM_START_CPRI_LINK_REQ with parameters:
%%
%%  PortNo = unused port
%%
%% $Result 1
%%  recevie RICM_START_CPRI_LINK_CFM signal
%%
%% $Action 2
%%  Send a RICM_START_CPRI_LINK_REQ with parameters:
%%
%%  PortNo = unused port
%%
%% $Result 2
%%  recevie RICM_START_CPRI_LINK_CFM signal again
%%
%% $Action 3
%%  waitting for nci_dci fault indication
%%
%% $Result 3
%%  receive ELIB_CONST_FH_FAULT_ID_LINK_FAILURE signal,that means no SFP plugged in
%%
%% $Action 4
%%  Send a ADD_RADIO_CTL_REQ with parameters:
%%
%% $Result 4
%%  receive RICM_ADD_RADIO_CTL_CFM signal
%%
%% $Action 5
%%  Repeat 1-4 for all unused ports
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  2013-01-15, ejonuna 
%%
%% Revision history:
%%  2012-12-20, (EGUOREN)
%%    First version
%%  2013-02-01, EYANWZH
%%    Update for comments.
%%  2013-09-06, ejonuna
%%    Merged dci_arc12 and DCI_SCL11.
%%    Removed requrement that dci_arc12 needs a configuration
%%  2013-09-23, ejonuna
%%    Updated to test on all unused ports
%%  2013-10-17, ebacemi
%%    Updated with new hwConfig
%%------------------------------------------------------------------------------
dci_arc12() ->
	[{userdata,[{wp, ""},
				{requirement, "CBD_RICM_DCI-ADD-RADIO-CTL_FU:1:C"},
				{slogan, "Connect to a non existing radio"},
				{hwConfig, hwConfigI}]}].
dci_arc12(_config) ->
	ct:pal("dci_arc12"),

	PortsNotUsed = nci_ricm_utils:get_all_unused_ports(),

	ct:pal("Unused ports: ~p~n", [PortsNotUsed]),

	% Set state, make audit, establish BCI and DCI connections, subscribe faults
	set_state_and_connect( starting_lmc_loaded ),

	%% Subscribe Faults DCI
	ok = nci_dci_actions:subscribe_faults([]),

	lists:foldl(
		fun({portNo,PortNumberNotUsed}, RuId) ->
				%% Start CPRI link
				ct:pal("Action 1"),
				ok = nci_dci_actions:start_cpri_link([{ruId, RuId},
													  {portNo, PortNumberNotUsed},
													  {expectedSigNo, ?RICM_START_CPRI_LINK_CFM}]),

				ct:pal("Action 2"),
				ok = nci_dci_actions:start_cpri_link([{ruId, RuId},
													  {portNo, PortNumberNotUsed},
													  {expectedSigNo, ?RICM_START_CPRI_LINK_CFM}]),

				ct:pal("Action 3"),
				FaultId = nci_dci_actions:fault_ind([{oseGwDeamon,?OSE_GW_DEAMON_1},
													 {faultId, ?ELIB_CONST_FH_FAULT_ID_LINK_FAILURE},
													 {faultDescription, {regexp, "No SFP plugged in*"}}]),

				%% add_radio_control here
				ct:pal("Action 4"),
				nci_dci_actions:add_radio_control([{ruId, RuId},
												   {expectedSigNo, ?RICM_ADD_RADIO_CTL_CFM}]),

				%% Reset CPRI Link
				ok = nci_dci_actions:reset_cpri_link([{ruId, RuId}]),
				ok = nci_dci_actions:reset_cpri_link_ind([{ruId, RuId}]),
				ok = nci_dci_actions:fault_cease_ind([{faultId, FaultId}]),

				RuId + 1
		end,
		1,
		PortsNotUsed),
	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id DCI_START_OAM1
%%
%% $Header
%%  Start O&M link to all RU, in state: Starting
%%
%% $Description
%%  Verify that RICM can start O&M link to all connected RUs.
%%
%% $Requirements
%% CBD_RICM_DCI-START-CPRI-LINK_FU:1:C
%% CBD_RICM_DCI-START-CPRI-LINK_FU:2:C
%% CBD_RICM_DCI-ADD-RADIO-CTL_FU:1:C
%% TODO: update requirements for START_CPRI_LINK3 & ADD_CPRI_LINK_CTL
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  At least 1 RU on any port
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state starting.
%%  DP is loaded.
%%  Subscribe BCI/DCI faults.
%%
%% $Action_1
%%  Send a RICM_START_CPRI_LINK3_REQ for 1st RU to DcServer with parameters:
%%  * masterUnitId = <read from config file>
%%  * masterUnitPort = <read from config file>
%%  * assignLinkId = <read from config file>
%%  * assignSlaveUnitId = <read from config file>
%%
%% $Result_1a
%%  Receive a RICM_START_CPRI_LINK3_CFM from DcServer with parameters:
%%  * linkId = <read from config file>
%%
%% $Result_1b
%%  Receive a RICM_START_CPRI_LINK3_IND from DcServer with parameters:
%% * linkId = <read from config file>
%% * typeOfUnit = <read from config file>
%% * linkSpeed = <read from config file>
%% * availStatus = 1
%%
%% $Action_2
%%  Check CPRI FPGA registers to verify that they are configured correctly
%%
%% $Result_2
%%  FPGA registers have correct values
%%
%% $Action_3
%% Send a RICM_ADD_CPRI_LINK_CTL_REQ for 1st RU to DcServer with parameters:
%% * linkId = <read from config file>
%%
%% $Result_3a
%% Receive a RICM_ADD_CPRI_LINK_CTL_CFM with parameters:
%% * linkId = <read from config file>
%%
%% $Result_3b
%% Receive a RICM_ADD_CPRI_LINK_CTL_IND with parameters:
%% * linkId = <read from config file>
%% * connStatus = 1
%% * huntPath = <read from config file>
%%
%% $Action_4
%% Repeat Action_1 and Action_3 to rest RUs
%%
%% $Result_4
%% Same as Result_1 and Result_3.
%%
%% $Postcondition
%%  Stop CPRI link on each connected RI port.
%%
%% $End
%%
%% Revision history:
%%  2014-05-20, ehuayya
%%    First version
%%  2014-05-27, ehuayya
%%    Updated according to review comments
%%
%%------------------------------------------------------------------------------
dci_start_oam1() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_RICM_DCI-START-CPRI-LINK_FU:1:C, CBD_RICM_DCI-START-CPRI-LINK_FU:2:C, CBD_RICM_DCI-ADD-RADIO-CTL_FU:1:C, TODO: update requirements for START_CPRI_LINK3 & ADD_CPRI_LINK_CTL"},
				{slogan, "Start O&M link to all RU, in state: Starting"},
				{hwConfig, hwConfigA}]}].

dci_start_oam1(_Config) ->
	dci_start_oam("dci_arc1", starting_lmc_loaded).

dci_start_oam(Name, State) ->
	ct:pal(Name),

	set_state_and_connect(State),
	ok = nci_dci_actions:subscribe_faults([]),
	
	Radios = nci_ricm_utils:get_all_radios(),

	lists:foreach(
		fun(Radio) ->
				ct:pal("Action_1 & Result_1"),
				start_cpri_link(Radio),

				%% register check for directly connected RUs
				case proplists:get_value(masterUnitId, Radio) of
					?UNIT_ID_DU1 ->
						ct:pal("Action_2 & Result_2"),
						nci_ricm_utils:verify_cpri_link_up(Radio);
					_ ->
						ok
				end,
				ct:pal("Action_3 & Result_3"),
				start_oam_link(Radio),

				ct:pal("Action_4")
		end,
		Radios),

	%% Stop CPRI links
	ok = stop_cpri_links(Radios),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id DCI_START_OAM2
%%
%% $Header
%%  Start O&M link to all RU, in state: Operational
%%
%% $Description
%%  Verify that RICM can start O&M link to all connected RUs.
%%
%% $Requirements
%% CBD_RICM_DCI-START-CPRI-LINK_FU:1:C
%% CBD_RICM_DCI-START-CPRI-LINK_FU:2:C
%% CBD_RICM_DCI-ADD-RADIO-CTL_FU:1:C
%% TODO: update requirements for START_CPRI_LINK3 & ADD_CPRI_LINK_CTL
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  At least 1 RU on any port
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state operational.
%%  Subscribe BCI/DCI faults.
%%  DU unitId is set.
%%
%% $Action_1
%%  Send a RICM_START_CPRI_LINK3_REQ for 1st RU to DcServer with parameters:
%%  * masterUnitId = <read from config file>
%%  * masterUnitPort = <read from config file>
%%  * assignLinkId = <read from config file>
%%  * assignSlaveUnitId = <read from config file>
%%
%% $Result_1a
%%  Receive a RICM_START_CPRI_LINK3_CFM from DcServer with parameters:
%%  * linkId = <read from config file>
%%
%% $Result_1b
%%  Receive a RICM_START_CPRI_LINK3_IND from DcServer with parameters:
%% * linkId = <read from config file>
%% * typeOfUnit = <read from config file>
%% * linkSpeed = <read from config file>
%% * availStatus = RICM_LINK_READY
%%
%% $Action_2
%%  Check CPRI FPGA registers to verify that they are configured correctly
%%
%% $Result_2
%%  FPGA registers have correct values
%%
%% $Action_3
%% Send a RICM_ADD_CPRI_LINK_CTL_REQ for 1st RU to DcServer with parameters:
%% * linkId = <read from config file>
%%
%% $Result_3a
%% Receive a RICM_ADD_CPRI_LINK_CTL_CFM with parameters:
%% * linkId = <read from config file>
%%
%% $Result_3b
%% Receive a RICM_ADD_CPRI_LINK_CTL_IND with parameters:
%% * linkId = <read from config file>
%% * connStatus = 1
%% * huntPath = <read from config file>
%%
%% $Action_4
%% Repeat Action_1 and Action_3 to rest RUs
%%
%% $Result_4
%% Same as Result_1 and Result_3.
%%
%% $Postcondition
%%  For all RUs, from furthest RU to nearest:
%%  Stop CPRI link to RU
%%
%% $End
%%
%% Revision history:
%%  2014-05-20, ehuayya
%%    First version
%%
%%------------------------------------------------------------------------------
dci_start_oam2() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_RICM_DCI-START-CPRI-LINK_FU:1:C, CBD_RICM_DCI-START-CPRI-LINK_FU:2:C, CBD_RICM_DCI-ADD-RADIO-CTL_FU:1:C, TODO: update requirements for START_CPRI_LINK3 & ADD_CPRI_LINK_CTL"},
				{slogan, "Start O&M link to all RU, in state: Operational"},
				{hwConfig, hwConfigA}]}].

dci_start_oam2(_Config) ->
	dci_start_oam("dci_start_oam2", operational).

%%------------------------------------------------------------------------------
%% $Id DCI_START_OAM3
%%
%% $Header
%%  Start O&M link to RU, in state: Disabled
%%
%% $Description
%%  Verify that RICM properly respond to O&M link start requests in state: Disabled.
%%
%% $Requirements
%% CBD_RICM_DCI-START-CPRI-LINK_FU:1:C
%% CBD_RICM_DCI-START-CPRI-LINK_FU:2:C
%% CBD_RICM_DCI-ADD-RADIO-CTL_FU:1:C
%% TODO: update requirements for START_CPRI_LINK3 & ADD_CPRI_LINK_CTL
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state disabled, DP loaded.
%%
%% $Action_1
%%  Send a RICM_START_CPRI_LINK3_REQ to DcServer with parameters:
%%  * masterUnitId = UNID_ID_DU1
%%  * masterUnitPort = 3
%%  * assignLinkId = 10
%%  * assignSlaveUnitId = 1024
%%
%% $Result_1
%%  Receive an START_CPRI_LINK3_REJ is received with parameters
%%  * linkId = 10
%%  * errorCode = UNSUCCESSFUL
%%  * errorDescription = Invalid O&M state
%%
%% $Action_2
%% Send a RICM_ADD_CPRI_LINK_CTL_REQ to DcServer with parameters:
%% * linkId = 10
%%
%% $Result_2
%% Receive a RICM_ADD_CPRI_LINK_CTL_REJ with parameters:
%%  * linkId = 10
%%  * errorCode = UNSUCCESSFUL
%%  * errorDescription = Invalid O&M state
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Revision history:
%%  2014-05-20, ehuayya
%%    First version.
%%
%%------------------------------------------------------------------------------
dci_start_oam3() ->
	[{userdata,[{wp, ""},
				{requirement, "CBD_RICM_DCI-START-CPRI-LINK_FU:1:C, CBD_RICM_DCI-START-CPRI-LINK_FU:2:C, CBD_RICM_DCI-ADD-RADIO-CTL_FU:1:C, TODO: update requirements for START_CPRI_LINK3 & ADD_CPRI_LINK_CTL"},
				{slogan, "Start O&M link to RU, in state: Disabled"}]}].

dci_start_oam3(_Config) ->
	ct:pal("dci_start_oam3"),

	set_state_and_connect(starting_lmc_loaded),
	set_state_and_connect(disabled),

	ct:pal("Action_1 & Result_1"),
	ok = nci_dci_actions:start_cpri_link3([{masterUnitId, ?UNIT_ID_DU1},
										   {masterUnitPort, 3},
										   {assignLinkId, 10},
										   {assignSlaveUnitId, 1024},
										   {expectedSigNo, ?RICM_START_CPRI_LINK3_REJ},
										   {errorCode, ?ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL},
										   {errorDescription, {regexp, "Invalid O&M state*"}}]),

	ct:pal("Action_2 & Result_2"),
	ok = nci_dci_actions:add_cpri_link_ctl([{linkId, 10},
											{expectedSigNo, ?RICM_ADD_CPRI_LINK_CTL_REJ},
											{errorCode, ?ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL},
											{errorDescription, {regexp, "Invalid O&M state*"}}]),

	%% Check that no unexpected signal is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id DCI_START_OAM4
%%
%% $Header
%%  Start O&M link to RU, in state: DP not loaded
%%
%% $Description
%%  Verify that RICM properly respond to O&M link start requests in state: DP not loaded.
%%
%% $Requirements
%% CBD_RICM_DCI-START-CPRI-LINK_FU:1:C
%% CBD_RICM_DCI-START-CPRI-LINK_FU:2:C
%% CBD_RICM_DCI-ADD-RADIO-CTL_FU:1:C
%% TODO: update requirements for START_CPRI_LINK3 & ADD_CPRI_LINK_CTL
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state: Starting DP not loaded.
%%
%% $Action_1
%%  Send a RICM_START_CPRI_LINK3_REQ to DcServer with parameters:
%%  * masterUnitId = UNIT_ID_DU1
%%  * masterUnitPort = 3
%%  * assignLinkId = 10
%%  * assignSlaveUnitId = 1024
%%
%% $Result_1
%%  Receive an START_CPRI_LINK3_REJ is received with parameters
%%  * linkId = 10
%%  * errorCode = UNSUCCESSFUL
%%  * errorDescription = DP not loaded
%%
%% $Action_2
%% Send a RICM_ADD_CPRI_LINK_CTL_REQ to DcServer with parameters:
%% * linkId = 10
%%
%% $Result_2
%% Receive a RICM_ADD_CPRI_LINK_CTL_REJ with parameters:
%%  * linkId = 10
%%  * errorCode = UNSUCCESSFUL
%%  * errorDescription = DP not loaded
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Revision history:
%%  2014-05-20, ehuayya
%%    First version.
%%
%%------------------------------------------------------------------------------
dci_start_oam4() ->
	[{userdata,[{wp, ""},
				{requirement, "CBD_RICM_DCI-START-CPRI-LINK_FU:1:C, CBD_RICM_DCI-START-CPRI-LINK_FU:2:C, CBD_RICM_DCI-ADD-RADIO-CTL_FU:1:C, TODO: update requirements for START_CPRI_LINK3 & ADD_CPRI_LINK_CTL"},
				{slogan, "Start O&M link to RU, in state: DP not loaded"}]}].

dci_start_oam4(_Config) ->
	ct:pal("dci_start_oam4"),

	set_state_and_connect(starting_lmc_not_loaded),

	ct:pal("Action_1 & Result_1"),
	ok = nci_dci_actions:start_cpri_link3([{masterUnitId, ?UNIT_ID_DU1},
										   {masterUnitPort, 3},
										   {assignLinkId, 10},
										   {assignSlaveUnitId, 1024},
										   {expectedSigNo, ?RICM_START_CPRI_LINK3_REJ},
										   {errorCode, ?ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL},
										   {errorDescription, {regexp, "DP not loaded*"}}]),

	ct:pal("Action_2 & Result_2"),
	ok = nci_dci_actions:add_cpri_link_ctl([{linkId, 10},
											{expectedSigNo, ?RICM_ADD_CPRI_LINK_CTL_REJ},
											{errorCode, ?ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL},
											{errorDescription, {regexp, "DP not loaded*"}}]),

	%% Check that no unexpected signal is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id DCI_START_OAM5
%%
%% $Header
%%  Start O&M link to RU, error cases.
%%
%% $Description
%%  Verify that RICM properly respond to illegal O&M link start requests.
%%
%% $Requirements
%% CBD_RICM_DCI-START-CPRI-LINK_FU:1:C
%% CBD_RICM_DCI-START-CPRI-LINK_FU:2:C
%% CBD_RICM_DCI-ADD-RADIO-CTL_FU:1:C
%% TODO: update requirements for START_CPRI_LINK3 & ADD_CPRI_LINK_CTL
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any.
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  Restart RICM to ensure no DU unit ID is set.
%%  The DU BC is in state: Operational.
%%  Subscribe BCI/DCI faults.
%%
%% $Action_1
%%  Send a RICM_START_CPRI_LINK3_REQ to DcServer with parameters:
%%  * masterUnitId = UNIT_ID_DU1
%%  * masterUnitPort = 3
%%  * assignLinkId = 1
%%  * assignSlaveUnitId = 2049
%%
%% $Result_1
%% Receive a RICM_START_CPRI_LINK3_REJ with parameters:
%% * linkId = 1
%% * errorCode = UNSUCCESSFUL
%% * errorDescription = "Invalid masterUnitId"
%% 
%% $Action_2
%%  Send a RICM_SET_DU_UNID_ID_REQ to DcServer with parameters:
%%  * unitId = <read from config file>
%%
%% $Result_2
%%  Receive a RICM_SET_DU_UNIT_ID_CFM
%%
%% $Action_3
%%  Send a RICM_START_CPRI_LINK3_REQ to DcServer with parameters:
%%  * masterUnitId = 65535
%%  * masterUnitPort = 4
%%  * assignLinkId = 1
%%  * assignSlaveUnitId = 2049
%%
%% $Result_3
%%  Receive an RICM_START_CPRI_LINK3_REJ with parameters:
%%  * linkId = 1
%%  * errorCode = UNSUCCESSFUL
%%  * errorDescription = "Invalid masterUnitId"
%%
%% $Action_4
%%  Send a RICM_START_CPRI_LINK3_REQ to DcServer with parameters:
%%  * masterUnitId = <read from config file>
%%  * masterUnitPort = 4
%%  * assignLinkId = 1
%%  * assignSlaveUnitId = <masterUnitId from config file>
%%
%% $Result_4
%%  Receive an RICM_START_CPRI_LINK3_REJ with parameters:
%%  * linkId = 1
%%  * errorCode = UNSUCCESSFUL
%%  * errorDescription = "Invalid masterUnitId"
%%
%% $Action_5
%%  Send a RICM_START_CPRI_LINK3_REQ to DcServer with parameters:
%%  * masterUnitId = <read from config file>
%%  * masterUnitPort = 7
%%  * assignLinkId = 1
%%  * assignSlaveUnitId = 2049
%%
%% $Result_5
%%  Receive an RICM_START_CPRI_LINK3_REJ with parameters:
%%  * linkId = <read from config file>
%%  * errorCode = UNSUCCESSFUL
%%  * errorDescription = "Invalid master portNo"
%%
%% $Action_6
%%  Send a RICM_START_CPRI_LINK3_REQ to DcServer with parameters:
%%  * masterUnitId = <read from config file>
%%  * masterUnitPort = 4
%%  * assignLinkId = 0
%%  * assignSlaveUnitId = 2049
%%
%% $Result_6
%%  Receive an RICM_START_CPRI_LINK3_REJ with parameters:
%%  * linkId = 0
%%  * errorCode = UNSUCCESSFUL
%%  * errorDescription = "Invalid assignLinkId"
%%
%% $Action_7
%%  Send a RICM_START_CPRI_LINK3_REQ to DcServer with parameters:
%%  * masterUnitId = <read from config file>
%%  * masterUnitPort = 4
%%  * assignLinkId = 1
%%  * assignSlaveUnitId = 0
%%
%% $Result_7
%%  Receive an RICM_START_CPRI_LINK3_REJ with parameters:
%%  * linkId = 1
%%  * errorCode = UNSUCCESSFUL
%%  * errorDescription = "Invalid assignSlaveUnitId"
%%
%% $Action_8
%% Send a RICM_ADD_CPRI_LINK_CTL_REQ to DcServer with parameters:
%% * linkId = 1
%%
%% $Result_8
%% Receive a RICM_ADD_CPRI_LINK_CTL_REJ with parameters:
%% * linkId = 1
%%  * errorCode = UNSUCCESSFUL
%%  * errorDescription = "linkId not in use"
%%
%% $Action_9
%% Send a RICM_ADD_CPRI_LINK_CTL_REQ to DcServer with parameters:
%% * linkId = 0
%%
%% $Result_9
%% Receive a RICM_ADD_CPRI_LINK_CTL_REJ with parameters:
%% * linkId = 0
%%  * errorCode = UNSUCCESSFUL
%%  * errorDescription = "Invalid linkId"
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Revision history:
%%  2014-05-20, ehuayya
%%    First version.
%%  2014-05-27, ehuayya
%%    Updated according to review comments.
%%
%%------------------------------------------------------------------------------
dci_start_oam5() ->
	[{userdata,[{wp, ""},
				{requirement, "CBD_RICM_DCI-START-CPRI-LINK_FU:1:C, CBD_RICM_DCI-START-CPRI-LINK_FU:2:C, CBD_RICM_DCI-ADD-RADIO-CTL_FU:1:C, TODO: update requirements for START_CPRI_LINK3 & ADD_CPRI_LINK_CTL"},
				{slogan, "Start O&M link to RU, error cases"}]}].

dci_start_oam5(_Config) ->
	ct:pal("dci_start_oam5"),

	%% restart RICM to ensure no DU unit ID is set.
	nci_bci_states:restart_board("TC: dci_start_oam5"),
	set_state_and_connect(operational),
	Radio = [{masterUnitId, ?UNIT_ID_DU1},
			 {masterUnitPort, 4},
			 {assignLinkId, 1},
			 {assignSlaveUnitId, 2049}
			],

	ct:pal("Action_1 & Result_1: DU unitId not set"),
	ok = nci_dci_actions:start_cpri_link3(Radio ++ [{expectedSigNo, ?RICM_START_CPRI_LINK3_REJ},
													{errorCode, ?ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL},
													{errorDescription, {regexp, "Invalid masterUnitId*"}}]),
	ct:pal("Action_2 & Result_2"),
	nci_dci_actions:set_du_unit_id([{unitId, ?UNIT_ID_DU1}]),

	InvalidParameters = [{3, "Unknown masterUnitId", {masterUnitId, 65535}, "Invalid masterUnitId*"},
						 {4, "Same masterUnitId and assignSlaveUnitId", {assignSlaveUnitId, ?UNIT_ID_DU1}, "Invalid assignSlaveUnitId*"},
						 {5, "Invalid masterUnitPort", {masterUnitPort, 7}, "Invalid MasterUnitPort*"},
						 {6, "Invalid assignLinkId", {assignLinkId, 0}, "Invalid assignLinkId*"},
						 {7, "Invalid assignSlaveUnitId", {assignSlaveUnitId, 0}, "Invalid assignSlaveUnitId*"}],
	lists:foreach(
		fun({ActionNo, Slogan, {Key, InvalidValue}, ErrorDescription}) ->
				ct:pal("Action_~p & Result_~p: " ++ Slogan, [ActionNo, ActionNo]),
				ok = nci_dci_actions:start_cpri_link3(lists:keyreplace(Key, 1, Radio, {Key, InvalidValue})
													  ++[{expectedSigNo, ?RICM_START_CPRI_LINK3_REJ},
														 {errorCode, ?ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL},
														 {errorDescription, {regexp, ErrorDescription}}])
		end,
		InvalidParameters),

	ct:pal("Action_8 & Result_8: linkId not in use"),
	ok = nci_dci_actions:add_cpri_link_ctl([{linkId, 10},
											{expectedSigNo, ?RICM_ADD_CPRI_LINK_CTL_REJ},
											{errorCode, ?ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL},
											{errorDescription, {regexp, "linkId not in use*"}}]),

	ct:pal("Action_9 & Result_9: Invalid linkId"),
	ok = nci_dci_actions:add_cpri_link_ctl([{linkId, 0},
											{expectedSigNo, ?RICM_ADD_CPRI_LINK_CTL_REJ},
											{errorCode, ?ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL},
											{errorDescription, {regexp, "Invalid linkId*"}}]),
	
	%% Check no unexpected signal is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id DCI_STOP_CL1
%%
%% $Header
%%  Stop CPRI link, in state: Starting
%%
%% $Description
%%  Verify stop CPRI link in state starting
%%
%% $Requirements
%%  TBD
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  At least one radio on any port
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state starting.
%%  Subscribe BCI/DCI faults.
%%  O&M link is set up all RUs.
%%
%% $Action_1
%%  From furthest to nearest, repeat Action_2 to Action_ for all RUs
%%
%% $Result_1
%%  CPRI links are verified to be stopped.
%%
%% $Action_2
%%  Send a RICM_STOP_CPRI_LINK_REQ to DcServer with parameters:
%%  * linkId = <read from config>
%%
%% $Result_2a
%%  A RICM_STOP_CPRI_LINK_CFM is received with parameters:
%%  * linkId = <read from config>
%%
%% $Result_2b
%%  A RICM_STOP_CPRI_LINK_IND is received with parameters:
%%  * linkId = <read from config>
%%
%% $Action_3
%%  For directly connected RU:
%%  Check FPGA registers to verify they are configured correctly
%%  For cascaded RU:
%%  Check preceding RU's connection status by "ricr -s"
%%
%% $Result_3
%%  For directly connected RU:
%%  FPGA registers have correct values
%%  For cascaded RU:
%%  Preceding RU indicates the cascading connection is down
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Revision history:
%%  2014-05-28, EHUAYYA
%%    First version
%%
%%------------------------------------------------------------------------------
dci_stop_cl1() ->
	[{userdata,[{wp, ""}, 
				{requirement, "TBD"},
				{slogan, "Stop CPRI link, in state: Starting"},
				{hwConfig, hwConfigA}]}].

dci_stop_cl1(_Config) ->
	ct:pal("dci_stop_cl1"),
	dci_stop_cl(starting_lmc_loaded).

dci_stop_cl(State) ->
	set_state_and_connect(State),
	ok = nci_dci_actions:subscribe_faults([]),
	
	AllRadios = nci_ricm_utils:get_all_radios(),
	start_cpri_and_oam_links(AllRadios),

	ct:pal("Action_1 & Result_1"),
	lists:foreach(
		fun(Radio) ->
				ct:pal("Action_2 & Result_2a"),
				ok = nci_dci_actions:stop_cpri_link(Radio),
				ct:pal("Result_2b"),
				ok = nci_dci_actions:stop_cpri_link_ind(Radio),
				ct:pal("Action_3 & Result_3"),
				case proplists:get_value(masterUnitId, Radio) of
					?UNIT_ID_DU1 ->
						nci_ricm_utils:verify_cpri_link_down(Radio);
					_ ->
						nci_ricm_utils:verify_cascade_link_down(Radio, AllRadios)
				end
		end,
		lists:reverse(AllRadios)),

	nci_common_utils:check_outstanding_faults(2000).	

%%------------------------------------------------------------------------------
%% $Id DCI_STOP_CL2
%%
%% $Header
%%  Stop CPRI link, in state: Operational
%%
%% $Description
%%  Verify stop CPRI link in state operational
%%
%% $Requirements
%%  TBD
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  At least one radio on any port
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state starting.
%%  Subscribe BCI/DCI faults.
%%  O&M link is set up all RUs.
%%
%% $Action_1
%%  From furthest to nearest, repeat Action_2 to Action_ for all RUs
%%
%% $Result_1
%%  CPRI links are verified to be stopped.
%%
%% $Action_2
%%  Send a RICM_STOP_CPRI_LINK_REQ to DcServer with parameters:
%%  * linkId = <read from config>
%%
%% $Result_2a
%%  A RICM_STOP_CPRI_LINK_CFM is received with parameters:
%%  * linkId = <read from config>
%%
%% $Result_2b
%%  A RICM_STOP_CPRI_LINK_IND is received with parameters:
%%  * linkId = <read from config>
%%
%% $Action_3
%%  For directly connected RU:
%%  Check FPGA registers to verify they are configured correctly
%%  For cascaded RU:
%%  Check preceding RU's connection status by "ricr -s"
%%
%% $Result_3
%%  For directly connected RU:
%%  FPGA registers have correct values
%%  For cascaded RU:
%%  Preceding RU indicates the cascading connection is down
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Revision history:
%%  2014-05-28, EHUAYYA
%%    First version
%%
%%------------------------------------------------------------------------------
dci_stop_cl2() ->
	[{userdata,[{wp, ""}, 
				{requirement, "TBD"},
				{slogan, "Stop CPRI link, in state: Starting"},
				{hwConfig, hwConfigA}]}].

dci_stop_cl2(_Config) ->
	ct:pal("dci_stop_cl2"),
	dci_stop_cl(operational).

%%------------------------------------------------------------------------------
%% $Id DCI_STOP_CL3
%%
%% $Header
%%  Stop CPRI link, in state: Disabled
%%
%% $Description
%%  Verify that RICM properly respond to stop CPRI link request in state: Disabled.
%%
%% $Requirements
%%  TBD
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state disabled, DP loaded.
%%
%% $Action_1
%%  Send a RICM_STOP_CPRI_LINK_REQ to DcServer with parameters:
%%  * linkId = 10
%%
%% $Result_1
%%  Receive an STOP_CPRI_LINK_REJ is received with parameters
%%  * linkId = 10
%%  * errorCode = UNSUCCESSFUL
%%  * errorDescription = Invalid O&M state
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Revision history:
%%  2014-06-02, ehuayya
%%    First version.
%%
%%------------------------------------------------------------------------------
dci_stop_cl3() ->
	[{userdata,[{wp, ""},
				{requirement, "TBD"},
				{slogan, "Stop CPRI link, in state: Disabled"}]}].

dci_stop_cl3(_Config) ->
	ct:pal("dci_stop_cl3"),

	set_state_and_connect(starting_lmc_loaded),
	set_state_and_connect(disabled),

	ct:pal("Action_1 & Result_1"),
	ok = nci_dci_actions:stop_cpri_link([{linkId, 10},
										 {expectedSigNo, ?RICM_STOP_CPRI_LINK_REJ},
										 {errorCode, ?ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL},
										 {errorDescription, {regexp, "Invalid O&M state*"}}]),

	%% Check that no unexpected signal is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id DCI_STOP_CL4
%%
%% $Header
%%  Stop CPRI link, in state: DP not loaded
%%
%% $Description
%%  Verify that RICM properly respond to stop CPRI link request in state: DP not loaded.
%%
%% $Requirements
%%  TBD
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state starting, DP not loaded.
%%
%% $Action_1
%%  Send a RICM_STOP_CPRI_LINK_REQ to DcServer with parameters:
%%  * linkId = 10
%%
%% $Result_1
%%  Receive an STOP_CPRI_LINK_REJ is received with parameters
%%  * linkId = 10
%%  * errorCode = UNSUCCESSFUL
%%  * errorDescription = DP not loaded
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Revision history:
%%  2014-06-02, ehuayya
%%    First version.
%%
%%------------------------------------------------------------------------------
dci_stop_cl4() ->
	[{userdata,[{wp, ""},
				{requirement, "TBD"},
				{slogan, "Stop CPRI link, in state: DP not loaded"}]}].

dci_stop_cl4(_Config) ->
	ct:pal("dci_stop_cl4"),

	set_state_and_connect(starting_lmc_not_loaded),

	ct:pal("Action_1 & Result_1"),
	ok = nci_dci_actions:stop_cpri_link([{linkId, 10},
										 {expectedSigNo, ?RICM_STOP_CPRI_LINK_REJ},
										 {errorCode, ?ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL},
										 {errorDescription, {regexp, "DP not loaded*"}}]),

	%% Check that no unexpected signal is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id DCI_STOP_CL5
%%
%% $Header
%%  Stop CPRI link, error cases.
%%
%% $Description
%%  Verify that RICM properly respond to illegal stop CPRI link requests.
%%
%% $Requirements
%%  TBD
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state: Operational.
%%  Subscribe BCI/DCI faults.
%%
%% $Action_1
%%  Send a RICM_STOP_CPRI_LINK_REQ to DcServer with parameters:
%%  * linkId = 0
%%
%% $Result_1
%%  Receive an STOP_CPRI_LINK_REJ is received with parameters
%%  * linkId = 0
%%  * errorCode = UNSUCCESSFUL
%%  * errorDescription = Invalid linkId
%%
%% $Action_2
%%  Send a RICM_STOP_CPRI_LINK_REQ to DcServer with parameters:
%%  * linkId = 10
%%
%% $Result_2
%%  Receive an STOP_CPRI_LINK_REJ is received with parameters
%%  * linkId = 10
%%  * errorCode = UNSUCCESSFUL
%%  * errorDescription = linkId not in use
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Revision history:
%%  2014-06-02, ehuayya
%%    First version.
%%
%%------------------------------------------------------------------------------
dci_stop_cl5() ->
	[{userdata,[{wp, ""},
				{requirement, "TBD"},
				{slogan, "Stop CPRI link, error cases."}]}].

dci_stop_cl5(_Config) ->
	ct:pal("dci_stop_cl5"),

	set_state_and_connect(operational),

	ct:pal("Action_1 & Result_1"),
	ok = nci_dci_actions:stop_cpri_link([{linkId, 0},
										 {expectedSigNo, ?RICM_STOP_CPRI_LINK_REJ},
										 {errorCode, ?ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL},
										 {errorDescription, {regexp, "Invalid linkId*"}}]),

	ct:pal("Action_2 & Result_2"),
	ok = nci_dci_actions:stop_cpri_link([{linkId, 10},
										 {expectedSigNo, ?RICM_STOP_CPRI_LINK_REJ},
										 {errorCode, ?ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL},
										 {errorDescription, {regexp, "linkId not in use*"}}]),

	%% Check that no unexpected signal is generated.
	nci_common_utils:check_outstanding_faults(2000).   	

%%------------------------------------------------------------------------------
%% $Id DCI_RESET_CL1
%%
%% $Header
%%  Reset CPRI link V2, in state: Starting
%%
%% $Description
%%  Verify reset CPRI link in state starting
%%
%% $Requirements
%%  CBD_RICM_DCI-RESET-CPRI-LINK_FU:1:C
%%  TODO: update requirements when FD is updated for RESET_CPRI_LINK2
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  At least one radio on any port
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state starting.
%%  Subscribe BCI/DCI faults.
%%  O&M link is set up all RUs.
%%
%% $Action_1
%%  From furthest to nearest, repeat Action_2 to Action_ for all RUs
%%
%% $Result_1
%%  CPRI links are verified to be stopped.
%%
%% $Action_2
%%  Send a RICM_RESET_CPRI_LINK2_REQ to DcServer with parameters:
%%  * linkId = <read from config>
%%
%% $Result_2a
%%  A RICM_RESET_CPRI_LINK2_CFM is received with parameters:
%%  * linkId = <read from config>
%%
%% $Result_2b
%%  A RICM_RESET_CPRI_LINK2_IND is received with parameters:
%%  * linkId = <read from config>
%%
%% $Action_3
%%  For directly connected RU:
%%  Check FPGA registers to verify they are configured correctly
%%  For cascaded RU:
%%  Check preceding RU's connection status by "ricr -s"
%%
%% $Result_3
%%  For directly connected RU:
%%  FPGA registers have correct values
%%  For cascaded RU:
%%  Preceding RU indicates the cascading connection is down
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Revision history:
%%  2014-06-04, EHUAYYA
%%    First version
%%
%%------------------------------------------------------------------------------
dci_reset_cl1() ->
	[{userdata,[{wp, ""}, 
				{requirement, "TBD"},
				{slogan, "Reset CPRI link V2, in state: Starting"},
				{hwConfig, hwConfigA}]}].

dci_reset_cl1(_Config) ->
	ct:pal("dci_reset_cl1"),
	dci_reset_cl(starting_lmc_loaded).

dci_reset_cl(State) ->
	set_state_and_connect(State),
	ok = nci_dci_actions:subscribe_faults([]),
	
	AllRadios = nci_ricm_utils:get_all_radios(),
	start_cpri_and_oam_links(AllRadios),

	ct:pal("Action_1 & Result_1"),
	lists:foreach(
		fun(Radio) ->
				ct:pal("Action_2 & Result_2a"),
				ok = nci_dci_actions:reset_cpri_link2(Radio),
				ct:pal("Result_2b"),
				ok = nci_dci_actions:reset_cpri_link2_ind(Radio),
				ct:pal("Action_3 & Result_3"),
				case proplists:get_value(masterUnitId, Radio) of
					?UNIT_ID_DU1 ->
						nci_ricm_utils:verify_cpri_link_down(Radio);
					_ ->
						nci_ricm_utils:verify_cascade_link_down(Radio, AllRadios)
				end
		end,
		lists:reverse(AllRadios)),

	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id DCI_RESET_CL2
%%
%% $Header
%%  Reset CPRI link V2, in state: Operational
%%
%% $Description
%%  Verify reset CPRI link in state starting
%%
%% $Requirements
%%  CBD_RICM_DCI-RESET-CPRI-LINK_FU:1:C
%%  TODO: update requirements when FD is updated for RESET_CPRI_LINK2
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  At least one radio on any port
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state starting.
%%  Subscribe BCI/DCI faults.
%%  O&M link is set up all RUs.
%%
%% $Action_1
%%  From furthest to nearest, repeat Action_2 to Action_ for all RUs
%%
%% $Result_1
%%  CPRI links are verified to be stopped.
%%
%% $Action_2
%%  Send a RICM_RESET_CPRI_LINK2_REQ to DcServer with parameters:
%%  * linkId = <read from config>
%%
%% $Result_2a
%%  A RICM_RESET_CPRI_LINK2_CFM is received with parameters:
%%  * linkId = <read from config>
%%
%% $Result_2b
%%  A RICM_RESET_CPRI_LINK2_IND is received with parameters:
%%  * linkId = <read from config>
%%
%% $Action_3
%%  For directly connected RU:
%%  Check FPGA registers to verify they are configured correctly
%%  For cascaded RU:
%%  Check preceding RU's connection status by "ricr -s"
%%
%% $Result_3
%%  For directly connected RU:
%%  FPGA registers have correct values
%%  For cascaded RU:
%%  Preceding RU indicates the cascading connection is down
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Revision history:
%%  2014-06-04, EHUAYYA
%%    First version
%%
%%------------------------------------------------------------------------------
dci_reset_cl2() ->
	[{userdata,[{wp, ""}, 
				{requirement, "TBD"},
				{slogan, "Reset CPRI link V2, in state: Operational"},
				{hwConfig, hwConfigA}]}].

dci_reset_cl2(_Config) ->
	ct:pal("dci_reset_cl2"),
	dci_reset_cl(operational).

%%------------------------------------------------------------------------------
%% $Id DCI_RESET_CL3
%%
%% $Header
%%  Reset CPRI link V2, in state: Disabled
%%
%% $Description
%%  Verify that RICM properly respond to reset CPRI link request in state: Disabled.
%%
%% $Requirements
%%  TBD
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state disabled, DP loaded.
%%
%% $Action_1
%%  Send a RICM_RESET_CPRI_LINK2_REQ to DcServer with parameters:
%%  * linkId = 10
%%
%% $Result_1
%%  Receive an RESET_CPRI_LINK2_REJ is received with parameters
%%  * linkId = 10
%%  * errorCode = UNSUCCESSFUL
%%  * errorDescription = Invalid O&M state
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Revision history:
%%  2014-06-04, ehuayya
%%    First version.
%%
%%------------------------------------------------------------------------------
dci_reset_cl3() ->
	[{userdata,[{wp, ""},
				{requirement, "TBD"},
				{slogan, "Reset CPRI link V2, in state: Disabled"}]}].

dci_reset_cl3(_Config) ->
	ct:pal("dci_reset_cl3"),

	set_state_and_connect(starting_lmc_loaded),
	set_state_and_connect(disabled),

	ct:pal("Action_1 & Result_1"),
	ok = nci_dci_actions:reset_cpri_link2([{linkId, 10},
										   {expectedSigNo, ?RICM_RESET_CPRI_LINK2_REJ},
										   {errorCode, ?ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL},
										   {errorDescription, {regexp, "Invalid O&M state*"}}]),

	%% Check that no unexpected signal is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id DCI_RESET_CL4
%%
%% $Header
%%  Reset CPRI link V2, in state: DP not loaded
%%
%% $Description
%%  Verify that RICM properly respond to reset CPRI link request in state: DP not loaded.
%%
%% $Requirements
%%  TBD
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state starting, DP not loaded.
%%
%% $Action_1
%%  Send a RICM_RESET_CPRI_LINK2_REQ to DcServer with parameters:
%%  * linkId = 10
%%
%% $Result_1
%%  Receive an RESET_CPRI_LINK2_REJ is received with parameters
%%  * linkId = 10
%%  * errorCode = UNSUCCESSFUL
%%  * errorDescription = DP not loaded
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Revision history:
%%  2014-06-04, ehuayya
%%    First version.
%%
%%------------------------------------------------------------------------------
dci_reset_cl4() ->
	[{userdata,[{wp, ""},
				{requirement, "TBD"},
				{slogan, "Reset CPRI link V2, in state: DP not loaded"}]}].

dci_reset_cl4(_Config) ->
	ct:pal("dci_reset_cl4"),

	set_state_and_connect(starting_lmc_not_loaded),

	ct:pal("Action_1 & Result_1"),
	ok = nci_dci_actions:reset_cpri_link2([{linkId, 10},
										   {expectedSigNo, ?RICM_RESET_CPRI_LINK2_REJ},
										   {errorCode, ?ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL},
										   {errorDescription, {regexp, "DP not loaded*"}}]),

	%% Check that no unexpected signal is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id DCI_RESET_CL5
%%
%% $Header
%%  Reset CPRI link V2, error cases.
%%
%% $Description
%%  Verify that RICM properly respond to illegal reset CPRI link requests.
%%
%% $Requirements
%%  TBD
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state: Operational.
%%  Subscribe BCI/DCI faults.
%%
%% $Action_1
%%  Send a RICM_RESET_CPRI_LINK2_REQ to DcServer with parameters:
%%  * linkId = 0
%%
%% $Result_1
%%  Receive an RESET_CPRI_LINK2_REJ is received with parameters
%%  * linkId = 0
%%  * errorCode = UNSUCCESSFUL
%%  * errorDescription = Invalid linkId
%%
%% $Action_2
%%  Send a RICM_RESET_CPRI_LINK2_REQ to DcServer with parameters:
%%  * linkId = 10
%%
%% $Result_2
%%  Receive an RESET_CPRI_LINK2_REJ is received with parameters
%%  * linkId = 10
%%  * errorCode = UNSUCCESSFUL
%%  * errorDescription = linkId not in use
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Revision history:
%%  2014-06-04, ehuayya
%%    First version.
%%
%%------------------------------------------------------------------------------
dci_reset_cl5() ->
	[{userdata,[{wp, ""},
				{requirement, "TBD"},
				{slogan, "Reset CPRI link V2, error cases."}]}].

dci_reset_cl5(_Config) ->
	ct:pal("dci_reset_cl5"),

	set_state_and_connect(operational),
	ok = nci_dci_actions:subscribe_faults([]),

	ct:pal("Action_1 & Result_1"),
	ok = nci_dci_actions:reset_cpri_link2([{linkId, 0},
										   {expectedSigNo, ?RICM_RESET_CPRI_LINK2_REJ},
										   {errorCode, ?ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL},
										   {errorDescription, {regexp, "Invalid linkId*"}}]),
	
	ct:pal("Action_2 & Result_2"),
	ok = nci_dci_actions:reset_cpri_link2([{linkId, 10},
										   {expectedSigNo, ?RICM_RESET_CPRI_LINK2_REJ},
										   {errorCode, ?ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL},
										   {errorDescription, {regexp, "linkId not in use*"}}]),

	%% Check that no unexpected signal is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%##############################################################################
%% $ChapterH2 Protocol Version Negotiation
%%
%%
%% $End
%%##############################################################################

%%------------------------------------------------------------------------------
%% $Id DCI_CE1
%%
%% $Header
%%  Normal Case
%%
%% $Description
%%  To verify that version negotiation works when the requested version exactly matches the version of the SUT.
%%
%% $Requirements
%%  CBD_RICM_DCI-CONN-EST_FU:1:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  No connection establish procedure has been performed since last restart.
%%
%% $Action
%%  Send a DC_CONN_ESTABLISH_REQ, with parameters:
%%
%%  protocolRevBasic = DC_BASIC_REV
%%
%%  protocolRevSpecific = RICM_DCI_SPECIFIC_REV
%%
%% $Result
%%  A DC_CONN_ESTABLISH_CFM is received.
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-05-30, QMAGSED
%%    First version
%%
%%------------------------------------------------------------------------------
dci_ce1() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_RICM_DCI-CONN-EST_FU:1:C"},
				{slogan, "Normal Case"}]}].

dci_ce1(_Config) ->
	ct:pal("dci_ce1"),

	{ok, session_up} = coli:subscribe_state(?SHELL_COMMAND),
	{ok, session_up} = osegw:subscribe_state(?OSE_GW_DEAMON_1),

	%% Restart Board
	ok = nci_bci_actions:conn_establish([]),
	LogString = string:concat("Test case ", string:to_upper("dci_ce1")),
	nci_bci_states:restart_board( LogString ),

	%% Connect to DCI interface
	ok = nci_dci_actions:conn_establish([{expectedSigNo, ?ELIB_DC_CONN_ESTABLISH_CFM}]),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id DCI_CE2
%%
%% $Header
%%  Protocol Too High
%%
%% $Description
%%  To verify that version negotiation handles the case of the requested protocol version being too high.
%%
%% $Requirements
%%  CBD_RICM_DCI-CONN-EST_FU:1:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  No connection establish procedure has been performed since last restart.
%%
%% $Action
%%  Send a DC_CONN_ESTABLISH_REQ, with parameters:
%%
%%  protocolRevBasic = DC_BASIC_REV + 1
%%
%%  protocolRevSpecific = RICM_DCI_SPECIFIC_REV
%%
%% $Result
%%  A DC_CONN_ESTABLISH_REJ is received, with
%%
%%  errorCode = UNSUCCESSFUL
%%
%%  errorDescription = "Invalid protocol revision"
%%
%% $Action
%%  Send a DC_CONN_ESTABLISH_REQ, with parameters:
%%
%%  protocolRevBasic = DC_BASIC_REV
%%
%%  protocolRevSpecific = RICM_DCI_SPECIFIC_REV + 1
%%
%% $Result
%%  A DC_CONN_ESTABLISH_REJ is received, with
%%
%%  errorCode = UNSUCCESSFUL
%%
%%  errorDescription = "Invalid protocol revision"
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-05-30, QMAGSED
%%    First version
%%
%%------------------------------------------------------------------------------
dci_ce2() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_RICM_DCI-CONN-EST_FU:1:C"},
				{slogan, "Protocol Too High"}]}].

dci_ce2(_Config) ->
	ct:pal("dci_ce2"),

	{ok, session_up} = coli:subscribe_state(?SHELL_COMMAND),
	{ok, session_up} = osegw:subscribe_state(?OSE_GW_DEAMON_1),

	%% Restart Board
	ok = nci_bci_actions:conn_establish([]),
	LogString = string:concat("Test case ", string:to_upper("dci_ce2")),
	nci_bci_states:restart_board( LogString ),

	%% Connect to DCI interface with ELIB_DC_BASIC_REV + 1
	ok = nci_dci_actions:conn_establish([{expectedSigNo, ?ELIB_DC_CONN_ESTABLISH_REJ},
						 {protocolRevBasic, ?ELIB_DC_BASIC_REV + 1},
						 {protocolRevSpecific, ?RICM_DCI_SPECIFIC_REV},
						 {errorCode, 1},
						 {errorDescription, {regexp, "Invalid protocol revision*"}}]),

	%% Connect to DCI interface with RICM_DCI_SPECIFIC_REV + 1
	ok = nci_dci_actions:conn_establish([{expectedSigNo, ?ELIB_DC_CONN_ESTABLISH_REJ},
						 {protocolRevBasic, ?ELIB_DC_BASIC_REV},
						 {protocolRevSpecific, ?RICM_DCI_SPECIFIC_REV + 1},
						 {errorCode, 1},
						 {errorDescription, {regexp, "Invalid protocol revision*"}}]),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id DCI_CE3
%%
%% $Header
%%  Max No Of Clients
%%
%% $Description
%%  To verify that a maximum of 3 clients can be in state connected simultaneously
%%
%% $Requirements
%%  CBD_RICM_DCI-CONN-EST_CA:1:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  No connection establish procedure has been performed since last restart.
%%
%% $Action
%%  Client A sends a DC_CONN_ESTABLISH_REQ, with parameters:
%%
%%  protocolRevBasic = DC_BASIC_REV
%%
%%  protocolRevSpecific = RICM_DCI_SPECIFIC_REV
%%
%% $Result
%%  Client A receives a DC_CONN_ESTABLISH_CFM
%%
%% $Action
%%  Client B sends a DC_CONN_ESTABLISH_REQ, with parameters:
%%
%%  protocolRevBasic = DC_BASIC_REV
%%
%%  protocolRevSpecific = RICM_DCI_SPECIFIC_REV
%%
%% $Result
%%  Client B receives a DC_CONN_ESTABLISH_CFM
%%
%% $Action
%%  Client C sends a DC_CONN_ESTABLISH_REQ, with parameters:
%%
%%  protocolRevBasic = DC_BASIC_REV
%%
%%  protocolRevSpecific = RICM_DC_SPECIFIC_REV
%%
%% $Result
%%  Client C receives a DC_CONN_ESTABLISH_CFM
%%
%% $Action
%%  Client D sends a DC_CONN_ESTABLISH_REQ, with parameters:
%%
%%  protocolRevBasic = DC_BASIC_REV
%%
%%  protocolRevSpecific = RICM_DCI_SPECIFIC_REV
%%
%% $Result
%%  Client D receives a DC_CONN_ESTABLISH_REJ, with parameters:
%%
%%  errorCode = UNSUCCESSFUL
%%
%%  errorDescription = "Too many clients already connected"
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-05-30, QMAGSED
%%    First version
%%
%%------------------------------------------------------------------------------
dci_ce3() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_RICM_DCI-CONN-EST_CA:1:C"},
				{slogan, "Max No Of Clients"}]}].

dci_ce3(_Config) ->
	ct:pal("dci_ce3"),

	{ok, session_up} = coli:subscribe_state(?SHELL_COMMAND),
	{ok, session_up} = osegw:subscribe_state(?OSE_GW_DEAMON_1),

	%% Restart Board
	ok = nci_bci_actions:conn_establish([]),
	LogString = string:concat("Test case ", string:to_upper("dci_ce3")),
	nci_bci_states:restart_board( LogString ),

	%% Create 3 more GWs
	ok = osegw:create(#osegw{name = ?OSE_GW_DEAMON_2, 
				 iap = osegw, 
				 opt = [{ping_timeout, 6000}, 
					{codec_config, 
					{?SIG_MODS, 
					 sizeof, 
						 osegw_ose,big}}]}),
	ok = osegw:create(#osegw{name = ?OSE_GW_DEAMON_3, 
				 iap = osegw, 
				 opt = [{ping_timeout, 6000}, 
					{codec_config, 
					{?SIG_MODS, 
					 sizeof, 
						 osegw_ose,big}}]}),
	ok = osegw:create(#osegw{name = ?OSE_GW_DEAMON_4, 
				 iap = osegw, 
				 opt = [{ping_timeout, 6000}, 
					{codec_config, 
					{?SIG_MODS, 
					 sizeof, 
						 osegw_ose,big}}]}),

	%% Connect A, B & C to DCI interface
	ok = nci_dci_actions:conn_establish([{oseGwDeamon, ?OSE_GW_DEAMON_2},
										{expectedSigNo, ?ELIB_DC_CONN_ESTABLISH_CFM}]),
	ok = nci_dci_actions:conn_establish([{oseGwDeamon, ?OSE_GW_DEAMON_3},
										{expectedSigNo, ?ELIB_DC_CONN_ESTABLISH_CFM}]),
	ok = nci_dci_actions:conn_establish([{oseGwDeamon, ?OSE_GW_DEAMON_4},
										{expectedSigNo, ?ELIB_DC_CONN_ESTABLISH_CFM}]),

	%% Connect D to DCI
	ok = nci_dci_actions:conn_establish([{expectedSigNo, ?ELIB_DC_CONN_ESTABLISH_REJ},
						 {errorCode, 1},
						 {errorDescription, {regexp, "Too many clients already connected*"}}]),

	%% Kill Client A, B & C
	ok = osegw:delete(?OSE_GW_DEAMON_2),
	ok = osegw:delete(?OSE_GW_DEAMON_3),
	ok = osegw:delete(?OSE_GW_DEAMON_4),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id DCI_CE4
%%
%% $Header
%%  State Not Connected
%%
%% $Description
%%  Test sending a signal in state not connected. No answer should be sent back from the SUT.
%%
%% $Requirements
%%  CBD_RICM_DCI-CONN-EST_FU:1:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  No connection establish procedure has been performed.
%%
%% $Action
%%  Send a DC_SUBSCRIBE_FAULTS_REQ,
%%
%% $Result
%%  No DC_SUBSCRIBE_FAULTS_CFM is received
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-05-30, QMAGSED
%%    First version
%%
%%------------------------------------------------------------------------------
dci_ce4() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_RICM_DCI-CONN-EST_FU:1:C"},
				{slogan, "State Not Connected"}]}].

dci_ce4(_Config) ->
	ct:pal("dci_ce4"),

	{ok, session_up} = coli:subscribe_state(?SHELL_COMMAND),
	{ok, session_up} = osegw:subscribe_state(?OSE_GW_DEAMON_1),

	%% Restart Board
	ok = nci_bci_actions:conn_establish([]),
	LogString = string:concat("Test case ", string:to_upper("dci_ce4")),
	nci_bci_states:restart_board( LogString ),

	%% Connect to DCI interface
	ok = nci_dci_actions:subscribe_faults_send([]),
	{error,timeout} = osegw:recv(?OSE_GW_DEAMON_1, [], 20*1000),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id DCI_CE5
%%
%% $Header
%%  State Operational
%%
%% $Description
%%  To verify the version negotiation in state operational.
%%
%% $Requirements
%%  CBD_RICM_DCI-CONN-EST_FU:1:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  DU BC is in state operational
%%
%% $Action
%%  Send a DC_CONN_ESTABLISH_REQ, with parameters:
%%
%%  protocolRevBasic = DC_BASIC_REV
%%
%%%protocolRevSpecific = RICM_DCI_SPECIFIC_REV
%%
%% $Result
%%  A DC_CONN_ESTABLISH_CFM is received
%%
%% $Action
%%  Send a BC_AUDIT_REQ.
%%
%% $Result
%%  A BC_AUDIT_CFM is received with parameters:
%%
%%  mainState = BC_MAIN_STATE_OPERATIONAL
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-05-30, QMAGSED
%%    First version
%%
%%------------------------------------------------------------------------------
dci_ce5() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_RICM_DCI-CONN-EST_FU:1:C"},
				{slogan, " State Operational"}]}].

dci_ce5(_Config) ->
	ct:pal("dci_ce5"),

	{ok, session_up} = coli:subscribe_state(?SHELL_COMMAND),
	{ok, session_up} = osegw:subscribe_state(?OSE_GW_DEAMON_1),

	nci_bci_states:set_state([{state, operational}]),

	%% Connect to BCI interface
	ok = nci_bci_actions:conn_establish([]),

	%% Connect to DCI interface
	ok = nci_dci_actions:conn_establish([{expectedSigNo, ?ELIB_DC_CONN_ESTABLISH_CFM}]),

	%% Audit 
	ok = nci_bci_actions:audit([{expectedSigNo, ?ELIB_BC_AUDIT_CFM},
					{expectedMainState, ?ELIB_BC_MAIN_STATE_OPERATIONAL}]),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id DCI_CE6
%%
%% $Header
%%  State Disabled
%%
%% $Description
%%  To verify the version negotiation in state disabled.
%%
%% $Requirements
%%  CBD_RICM_DCI-CONN-EST_FU:1:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  DU BC is in state disabled
%%
%% $Action
%%  Send a DC_CONN_ESTABLISH_REQ, with parameters:
%%
%%  protocolRevBasic = DC_BASIC_REV
%%
%%  protocolRevSpecific = RICM_DCI_SPECIFIC_REV
%%
%% $Result
%%  A DC_CONN_ESTABLISH_CFM is received.
%%
%% $Action
%%  Send a BC_AUDIT_REQ.
%%
%% $Result
%%  A BC_AUDIT_CFM is received with parameters:
%%
%%  mainState = BC_MAIN_STATE_DISABLED
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-05-30, QMAGSED
%%    First version
%%
%%------------------------------------------------------------------------------
dci_ce6() ->
	[{userdata,[{wp, ""},
				{requirement, "CBD_RICM_DCI-CONN-EST_FU:1:C"},
				{slogan, "State Disabled"}]}].

dci_ce6(_Config) ->
	ct:pal("dci_ce6"),

	{ok, session_up} = coli:subscribe_state(?SHELL_COMMAND),
	{ok, session_up} = osegw:subscribe_state(?OSE_GW_DEAMON_1),

	nci_bci_states:set_state([{state, disabled}]),

	%% Connect to BCI interface
	ok = nci_bci_actions:conn_establish([]),

	%% Connect to DCI interface
	ok = nci_dci_actions:conn_establish([{expectedSigNo, ?ELIB_DC_CONN_ESTABLISH_CFM}]),

	%% Audit 
	ok = nci_bci_actions:audit([{expectedSigNo, ?ELIB_BC_AUDIT_CFM},
					{expectedMainState, ?ELIB_BC_MAIN_STATE_DISABLED}]),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id DCI_CE7
%%
%% $Header
%%  Protocol Too Low
%%
%% $Description
%%  To verify that version negotiation handles the case of the requested protocol version being too low
%%
%% $Requirements
%%  CBD_RICM_DCI-CONN-EST_FU:1:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  No connection establish procedure has been performed since last restart
%%
%% $Action
%%  Send a DC_CONN_ESTABLISH_REQ, with parameters:
%%
%%  protocolRevBasic = DC_BASIC_REV -1
%%
%%  protocolRevSpecific = RICM_DCI_SPECIFIC_REV
%%
%% $Result
%%  A DC_CONN_ESTABLISH_REJ is received, with
%%
%%  errorCode = UNSUCCESSFUL
%%
%%  errorDescription = "Invalid protocol revision"
%%
%% $Action
%%  Send a DC_CONN_ESTABLISH_REQ, with parameters:
%%
%%  protocolRevBasic = DC_BASIC_REV
%%
%%  protocolRevSpecific = RICM_DCI_SPECIFIC_REV - 1
%%
%% $Result
%%  A DC_CONN_ESTABLISH_REJ is received, with
%%
%%  errorCode = UNSUCCESSFUL
%%
%%  errorDescription = "Invalid protocol revision"
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-05-30, QMAGSED
%%    First version
%%
%%------------------------------------------------------------------------------
dci_ce7() ->
	[{userdata,[{wp, ""},
				{requirement, "CBD_RICM_DCI-CONN-EST_FU:1:C"},
				{slogan, "Protocol Too Low"}]}].

dci_ce7(_Config) ->
	ct:pal("dci_ce7"),

	{ok, session_up} = coli:subscribe_state(?SHELL_COMMAND),
	{ok, session_up} = osegw:subscribe_state(?OSE_GW_DEAMON_1),

	%% Restart Board
	ok = nci_bci_actions:conn_establish([]),
	LogString = string:concat("Test case ", string:to_upper("dci_ce7")),
	nci_bci_states:restart_board( LogString ),

	%% Connect to DCI interface with ELIB_DC_BASIC_REV - 1
	ok = nci_dci_actions:conn_establish([{expectedSigNo, ?ELIB_DC_CONN_ESTABLISH_REJ},
						 {protocolRevBasic, ?ELIB_DC_BASIC_REV - 1},
						 {protocolRevSpecific, ?RICM_DCI_SPECIFIC_REV},
						 {errorCode, 1},
						 {errorDescription, {regexp, "Invalid protocol revision*"}}]),

	%% Connect to DCI interface with RICM_DCI_SPECIFIC_REV - 1
	ok = nci_dci_actions:conn_establish([{expectedSigNo, ?ELIB_DC_CONN_ESTABLISH_REJ},
						 {protocolRevBasic, ?ELIB_DC_BASIC_REV},
						 {protocolRevSpecific, ?RICM_DCI_SPECIFIC_REV - 1},
						 {errorCode, 1},
						 {errorDescription, {regexp, "Invalid protocol revision*"}}]),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%##############################################################################
%% $ChapterH2 Carrier Release
%%
%%
%% $End
%%##############################################################################

%%------------------------------------------------------------------------------
%% $Id DCI_CR1
%%
%% $Header
%%  State Starting
%%
%% $Description
%%  Verify carrier release in state starting
%%
%% $Requirements
%%  CBD_RICM_DCI-IQ_FU:2:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state starting.
%%
%%  Carriers with CarrierId 1-6 setup
%%
%% $Action
%%  Send a CARRIER_RELEASE_REQ with parameters:
%%
%%  carrierId = 1
%%
%% $Result
%%  A CARRIER_RELEASE_CFM is received with parameters:
%%
%%  carrierId = 1
%%
%% $Action
%%  Repeat A1 for carrierId 2 - 6
%%
%% $Result
%%  Same as in A1 but with carrierId 2 - 6
%%
%% $Action
%%  Send a CARRIER_SETUP_REQ with parameters:
%%
%%  carrierId = 1, direction = DL, bandwidth = 1.6 MHz, bbModule = 1
%%
%% $Result
%%  A CARRIER_SETUP_CFM is received with parameters:
%%
%%  carrierId = 1
%%
%% $Action
%%  Repeat A1 for carrierId 2 - 6
%%
%% $Result
%%  Same as in A1 but with carrierId 2 - 6
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  2012-11-05, EEDAJA
%%
%% Revision history:
%%  2012-05-30, QMAGSED
%%    First version
%%
%%------------------------------------------------------------------------------
dci_cr1() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_RICM_DCI-IQ_FU:2:C"},
				{slogan, "State Starting"},
				{hwConfig, hwConfigA}]}].

dci_cr1(_Config) ->
		dci_cr("dci_cr1", starting_lmc_loaded).

dci_cr(Name, State) ->
	ct:pal(Name),

	% Set state, make audit, establish BCI and DCI connections, subscribe faults
	set_state_and_connect( State ),

	%% Subscribe Faults DCI
	ok = nci_dci_actions:subscribe_faults([]),

	Radio1 = nci_ricm_utils:get_first_radio(),

	%% Start CPRI
	ok = nci_dci_actions:start_cpri_link(Radio1),

	ok = nci_dci_actions:cpri_link_ind(Radio1 ++ [{typeOfUnit, '_'},{availStatus, 1}]),

	%% Add Carriers UL
	ok = nci_dci_actions:carrier_setup3(Radio1 ++ [
						 {xioPort, 0},
						 {direction, ?RICM_CARRIER_DIRECTION_UL},
						 {carrierId, 0},
						 {posA, 0},
						 {noOfSamples, 2},
						 {isSubBand, ?ELIB_CONST_HWU_YES}]),

	%% Add Carriers DL
	XioPortDL = case nci_common_utils:get_du() of
		dul -> 2;
		dus -> 6;
		mRBS_lte -> 6;
		_ -> 2
	end,
	ok = nci_dci_actions:carrier_setup3(Radio1 ++ [
						 {xioPort, XioPortDL},
						 {direction, ?RICM_CARRIER_DIRECTION_DL},
						 {carrierId, 1},
						 {posA, 0},
						 {noOfSamples, 2},
						 {isSubBand, ?ELIB_CONST_HWU_YES}]),

	case Name of
		"dci_cr3" ->
			nci_bci_states:set_state([{state, disabled}]),

			%% Release Carrier DL
			ok = nci_dci_actions:carrier_release(Radio1 ++ [{carrierId, 1},
															{expectedSigNo, ?RICM_CARRIER_RELEASE_REJ},
															{errorCode, 1},
															{errorDescription, {regexp, "Invalid O&M state*"}}]),
			%% Release Carrier UL
			ok = nci_dci_actions:carrier_release(Radio1 ++ [{carrierId, 0},
															{expectedSigNo, ?RICM_CARRIER_RELEASE_REJ},
															{errorCode, 1},
															{errorDescription, {regexp, "Invalid O&M state*"}}]),
			timer:sleep(5*1000);
		_ ->
			%% Release Carrier DL
			ok = nci_dci_actions:carrier_release(Radio1 ++ [{carrierId, 1}]),

			%% Release Carrier UL
			ok = nci_dci_actions:carrier_release(Radio1 ++ [{carrierId, 0}]),

			%% Add Carriers UL
			ok = nci_dci_actions:carrier_setup3(Radio1 ++ [
						 {xioPort, 0},
						 {direction, ?RICM_CARRIER_DIRECTION_UL},
						 {carrierId, 0},
						 {posA, 0},
						 {noOfSamples, 2},
						 {isSubBand, ?ELIB_CONST_HWU_YES}]),

			%% Add Carriers DL
			ok = nci_dci_actions:carrier_setup3(Radio1 ++ [
						 {xioPort, XioPortDL},
						 {direction, ?RICM_CARRIER_DIRECTION_DL},
						 {carrierId, 1},
						 {posA, 0},
						 {noOfSamples, 2},
						 {isSubBand, ?ELIB_CONST_HWU_YES}]),

			%% Release Carrier DL
			ok = nci_dci_actions:carrier_release(Radio1 ++ [{carrierId, 1}]),

			%% Release Carrier UL
			ok = nci_dci_actions:carrier_release(Radio1 ++ [{carrierId, 0}]),

			%% Reset CPRI Link
			ok = nci_dci_actions:reset_cpri_link(Radio1),

			ok = nci_dci_actions:reset_cpri_link_ind(Radio1)
	end,

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id DCI_CR2
%%
%% $Header
%%  State Operational
%%
%% $Description
%%  Verify carrier release in state operational.
%%
%% $Requirements
%%  CBD_RICM_DCI-IQ_FU:2:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  The DU BC is in state operational.
%%
%%  Carriers with CarrierId 1-6 setup
%%
%% $Action
%%  Send a CARRIER_RELEASE_REQ with parameters:
%%
%%  carrierId = 1
%%
%% $Result
%%  A CARRIER_RELEASE_CFM is received with parameters:
%%
%%  carrierId = 1
%%
%% $Action
%%  Repeat A1 for carrierId 2 - 6
%%
%% $Result
%%  Same as in A1 but with carrierId 2 - 6
%%
%% $Action
%%  Send a CARRIER_SETUP_REQ with parameters:
%%
%%  carrierId = 1, direction = DL, bandwidth = 1.6 MHz, bbModule = 1
%%
%% $Result
%%  A CARRIER_SETUP_CFM is received with parameters:
%%
%%  carrierId = 1
%%
%% $Action
%%  Repeat A1 for carrierId 2 - 6
%%
%% $Result
%%  Same as in A1 but with carrierId 2 - 6
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  2012-11-05, EEDAJA
%%
%% Revision history:
%%  2012-05-30, QMAGSED
%%    First version
%%
%%------------------------------------------------------------------------------
dci_cr2() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_RICM_DCI-IQ_FU:2:C"},
				{slogan, "Verify carrier release in state operational"},
				{hwConfig, hwConfigA}]}].

dci_cr2(_Config) ->
		dci_cr("dci_cr2", operational).

%%------------------------------------------------------------------------------
%% $Id DCI_CR3
%%
%% $Header
%%  State Disabled
%%
%% $Description
%%  Verify carrier release in state disabled
%%
%% $Requirements
%%  CBD_RICM_DCI-IQ_FU:2:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state disabled.
%%
%%  Carriers with CarrierId 1- 6 setup
%%
%% $Action
%%  Send a CARRIER_RELEASE_REQ with parameters:
%%
%%  carrierId = 1
%%
%% $Result
%%  A CARRIER_RELEASE_CFM is received with parameters:
%%
%%  carrierId = 1
%%
%% $Action
%%  Repeat A1 for carrierId 2 - 6
%%
%% $Result
%%  Same as in A1 but with carrierId 2 - 6
%%
%% $Action
%%  Send a CARRIER_SETUP_REQ with parameters:
%%
%%  carrierId = 1, direction = DL, bandwidth = 1.6 MHz, bbModule = 1
%%
%% $Result
%%  A CARRIER_SETUP_CFM is received with parameters:
%%
%%  carrierId = 1
%%
%% $Action
%%  Repeat A1 for carrierId 2 - 6
%%
%% $Result
%%  Same as in A1 but with carrierId 2 - 6
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-10-17, EEDAJA
%%    First version
%%
%%------------------------------------------------------------------------------
dci_cr3() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_RICM_DCI-IQ_FU:2:C"},
				{slogan, "Verify carrier release in state disabled"},
				{hwConfig, hwConfigA}]}].

dci_cr3(_Config) ->
		dci_cr("dci_cr3", operational).


%%------------------------------------------------------------------------------
%% $Id DCI_CR4
%%
%% $Header
%%  Carrier not setup
%%
%% $Description
%%  Verify carrier release, without setting up a Carrier
%%
%% $Requirements
%%  CBD_RICM_DCI-IQ_FU:2:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  A connection establish procedure has been performed.
%%
%%  The DU BC is in state starting.
%%
%%  Carrier with CarrierId 1 not setup
%%
%% $Action
%%  Send a CARRIER_RELEASE_REQ with parameters:
%%
%%  carrierId = 1, direction = DL, bandwidth 1.6 MHz, bbModule = 1
%%
%% $Result
%%  A CARRIER_RELEASE_REJ is received with parameters:
%%
%%  carrierId = 1
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-10-01, EEDAJA
%%    First version
%%
%%------------------------------------------------------------------------------
dci_cr4() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_RICM_DCI-IQ_FU:2:C"},
				{slogan, "State Operational"}]}].

dci_cr4(_Config) ->
	ct:pal("dci_cr4"),

	% Set state, make audit, establish BCI and DCI connections, subscribe faults
	set_state_and_connect( operational ),

	%% Subscribe Faults DCI
	ok = nci_dci_actions:subscribe_faults([]),

	%% Release Carrier DL
	ok = nci_dci_actions:carrier_release([{carrierId, 1}]),
	
	%% Release Carrier DL
	ok = nci_dci_actions:carrier_release([{carrierId, 1}]),
	
	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%##############################################################################
%% $ChapterH2 Carrier Setup
%%
%%
%% $End
%%##############################################################################

%%------------------------------------------------------------------------------
%% $Id DCI_CS1
%%
%% $Header
%%  State Starting
%%
%% $Description
%%  Verify carrier setup in state starting.
%%
%% $Requirements
%%  CBD_RICM_DCI-IQ_FU:1:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state starting.
%%
%%  CPRI links are not started
%%
%%  No carrier setup
%%
%% $Action_1
%%  Send a RICM_START_CPRI_LINK_REQ
%%
%% $Result_1
%%  RICM_START_CPRI_LINK_CFM is received
%%
%%  $Action_2
%%  Send a CARRIER_SETUP_REQ
%%
%% $Result_2
%%  A CARRIER_SETUP_CFM is received
%%
%% $Action_3
%%  Send a CARRIER_SETUP_REQ
%%
%% $Result_3
%%  A CARRIER_SETUP_CFM is received
%%
%%  carrierId = 2 x portNo -1
%%
%% $Action_4
%%  Repeat Action_1, Action_2 and Action_3 for all the connected radios
%%
%% $Result_5
%%  The same results for all the connected radios
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  2012-10-15, EJOJUNA
%%
%% Revision history:
%%  2012-09-24, EEDAJA
%%    First version
%%
%%  2012-09-24, EEDAJA
%%    The test case handles RUs according to configuration file.
%%    Some other minor changes.
%%
%%------------------------------------------------------------------------------
dci_cs1() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_RICM_DCI-IQ_FU:1:C"},
				{slogan, "Verify carrier setup in state starting"},
				{hwConfig, hwConfigA}]}].

dci_cs1(_Config) ->
	dci_cs("dci_cs1", starting_lmc_loaded).

dci_cs(Name, State) ->
	ct:pal(Name),

	% Set state, make audit, establish BCI and DCI connections, subscribe faults
	set_state_and_connect( State ),

	%% Subscribe Faults DCI
	ok = nci_dci_actions:subscribe_faults([]),

	XioPortDL = case nci_common_utils:get_du() of
		dul -> 1;
		dus -> 5;
		mRBS_lte -> 5;
		_ -> 1
	end,

	Radios = nci_ricm_utils:get_all_radios(),

	lists:foreach(fun(Radio) ->

		%% Start CPRI
		ok = nci_dci_actions:start_cpri_link(Radio),
		ok = nci_dci_actions:cpri_link_ind(Radio ++ [{typeOfUnit, '_'},{availStatus, 1}]),

		%% Add Radio Control
		nci_dci_actions:add_radio_control(Radio ++ [{expectedSigNo, ?RICM_ADD_RADIO_CTL_CFM}]),
		nci_dci_actions:radio_control_ind(Radio ++ [{connStatus, 1},{radioSoftware, application}])


	end,
	Radios),

	case Name of 
		"dci_cs3" ->
			NoOfSamples = 8,
			% State can not be changed to disabled before starting CPRI link
			nci_bci_states:set_state([{state, disabled}]),

			lists:foreach(fun(Radio) ->

				RuId = proplists:get_value(ruId,Radio),

				%% Add Carriers UL
				ok = nci_dci_actions:carrier_setup3([{ruId, RuId},
													{xioPort, 0},
													{direction, ?RICM_CARRIER_DIRECTION_UL},
													{carrierId, 2*RuId - 2},
													{posA, (2*RuId-2) rem 30},
													{noOfSamples, NoOfSamples},
													{isSubBand, ?ELIB_CONST_HWU_YES},
													{expectedSigNo, ?RICM_CARRIER_SETUP_REJ},
													{errorCode, 1},
													{errorDescription, {regexp, "Invalid O&M state*"}}]),
				%% Add Carriers DL
				ok = nci_dci_actions:carrier_setup3([{ruId, RuId},
													{xioPort, XioPortDL},
													{direction, ?RICM_CARRIER_DIRECTION_DL},
													{carrierId, 2*RuId - 1},
													{posA, (2*RuId-2) rem 30},
													{noOfSamples, NoOfSamples},
													{isSubBand, ?ELIB_CONST_HWU_YES },
													{expectedSigNo, ?RICM_CARRIER_SETUP_REJ},
													{errorCode, 1},
													{errorDescription, {regexp, "Invalid O&M state*"}}])

			end,
			Radios);

		_ ->
			NoOfSamples = 2,

			lists:foreach(fun(Radio) ->

				RuId = proplists:get_value(ruId,Radio),

				%% Add Carriers UL
				ok = nci_dci_actions:carrier_setup3([{ruId, RuId},
												{xioPort, 0},
												{direction, ?RICM_CARRIER_DIRECTION_UL},
												{carrierId, 2*RuId - 2},
												{posA, (2*RuId-2) rem 30},
												{noOfSamples, NoOfSamples},
												{isSubBand, ?ELIB_CONST_HWU_YES}]),
				%% Add Carriers DL
				ok = nci_dci_actions:carrier_setup3([{ruId, RuId},
												{xioPort, XioPortDL},
												{direction, ?RICM_CARRIER_DIRECTION_DL},
												{carrierId, 2*RuId - 1},
												{posA, (2*RuId-2) rem 30},
												{noOfSamples, NoOfSamples},
												{isSubBand, ?ELIB_CONST_HWU_YES}])

			end,
			Radios),

			lists:foreach(fun(Radio) ->

				RuId = proplists:get_value(ruId,Radio),

				%% Release Carriers
				ok = nci_dci_actions:carrier_release([{carrierId, 2*RuId - 2}]),

				%% Release Carriers
				ok = nci_dci_actions:carrier_release([{carrierId, 2*RuId - 1}])


			end,
			Radios),

			reset_all_cpri_links(Radios)

	end,

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id DCI_CS2
%%
%% $Header
%%  State Operational
%%
%% $Description
%%  Verify carrier setup in state operational.
%%
%% $Requirements
%%  CBD_RICM_DCI-IQ_FU:1:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state operational.
%%
%%  CPRI links is started with ruId = 1 - 6
%%
%%  No carrier setup
%%
%%  CPRI links are not started
%%
%%  No carrier setup
%%
%% $Action_1
%%  Send a RICM_START_CPRI_LINK_REQ
%%
%% $Result_1
%%  RICM_START_CPRI_LINK_CFM is received
%%
%%  $Action_2
%%  Send a CARRIER_SETUP_REQ
%%
%% $Result_2
%%  A CARRIER_SETUP_CFM is received
%%
%% $Action_3
%%  Send a CARRIER_SETUP_REQ
%%
%% $Result_3
%%  A CARRIER_SETUP_CFM is received
%%
%% $Action_4
%%  Repeat Action_1, Action_2 and Action_3 for all the connected radios
%%
%% $Result_5
%%  The same results for all the connected radios

%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  2012-10-15, EJOJUNA
%%
%% Revision history:
%%  2012-09-24, EEDAJA
%%    First version
%%
%%  2012-09-24, EEDAJA
%%    The test case handles RUs according to configuration file.
%%    Some other minor changes.
%%
%%------------------------------------------------------------------------------
dci_cs2() ->
	[{userdata,[ {wp, ""}, 
				{requirement, "CBD_RICM_DCI-IQ_FU:1:C"},
				{slogan, "Verify carrier setup in state operational"},
				{hwConfig, hwConfigA}]}].

dci_cs2(_Config) ->
	dci_cs("dci_cs2", operational).

%%------------------------------------------------------------------------------
%% $Id DCI_CS3
%%
%% $Header
%%  State Disabled
%%
%% $Description
%%  Verify carrier setup in state disabled.
%%
%% $Requirements
%%  CBD_RICM_DCI-IQ_FU:1:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state starting.
%%
%%  CPRI links are not started
%%
%%  No carrier setup
%%
%% $Action_1
%%  Send a RICM_START_CPRI_LINK_REQ
%%
%% $Result_1
%%  RICM_START_CPRI_LINK_CFM is received
%%
%%  $Action_2
%%  Send a CARRIER_SETUP_REQ
%%
%% $Result_2
%%  A CARRIER_SETUP_CFM is received
%%
%% $Action_3
%%  Send a CARRIER_SETUP_REQ
%%
%% $Result_3
%%  A CARRIER_SETUP_REJ is received
%%
%% $Action_4
%%  Repeat Action_1, Action_2 and Action_3 for all the connected radios
%%
%% $Result_4
%%  The same results for all the connected radios
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  2012-11-13, EBACEMI
%%
%% Revision history:
%%  2012-11-05, EEDAJA
%%    First version
%%
%%  2012-11-13, EEDAJA
%%    Updated according to review comments
%%
%%  2013-07-02, EBACEMI
%%    Removed code that expects RICM_ADD_RADIO_CTL_IND after entering disabled state
%%
%%------------------------------------------------------------------------------
dci_cs3() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_RICM_DCI-IQ_FU:1:C"},
				{slogan, "Verify carrier setup in state disabled"},
				{hwConfig, hwConfigA}]}].

dci_cs3(_Config) ->
	dci_cs("dci_cs3", starting_lmc_loaded).

%%------------------------------------------------------------------------------
%% $Id DCI_CS4
%%
%% $Header
%%  Unused address
%%
%% $Description
%%  Verify carrier setup unused address
%%
%% $Requirements
%%  CBD_RICM_DCI-IQ_FU:1:C
%%
%%  CBD_RICM_LTE-IQ_FU:3:C
%%
%%  CBD_RICM_LTE-IQ_FU:4:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%% $Precondition
%%  The DU BC is in state starting.
%%
%%  CPRI links is not started with ruId = 1
%%
%%  No carrier setup
%%
%% $Action1
%%  Send a CARRIER_SETUP_REQ with parameters:
%%
%%  ruId = 1, carrierId = 0, direction = UL , xioPort = 0 , noOfSamples = 1, isSubBand = 1
%%
%% $Result1
%%  A CARRIER_SETUP_REJ is received with parameters:
%%
%%  carrierId = 0
%%
%%  errorCode = UNSUCCESSFUL
%%
%%  carrierErrorCode = CARRIER_NO_ERROR
%%
%%  errorDescription = "ruId not in use"
%%
%% $Action2
%%  Repeat A1 for carrierId = 1 and direction = DL
%%
%% $Result2
%%  Same as in E1
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  2012-10-31, EJONUNA
%%
%% Revision history:
%%  2012-10-30, EYANWZH
%%    First version
%%
%%------------------------------------------------------------------------------
dci_cs4() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_RICM_DCI-IQ_FU:1:C,CBD_RICM_LTE-IQ_FU:3:C,CBD_RICM_LTE-IQ_FU:3:C"},
				{slogan, "Unused address"},
				{hwConfig, hwConfigA}]}].

dci_cs4(_Config) ->
	ct:pal("dci_cs4"),
	
	% Set state, make audit, establish BCI and DCI connections, subscribe faults
	set_state_and_connect(starting_lmc_loaded),
	
	%% Subscribe Faults DCI
	ok = nci_dci_actions:subscribe_faults([]),
	
	XioPortDL = case nci_common_utils:get_du() of
		dul -> 1;
		dus -> 6;
		mRBS_lte -> 6;
		_ -> 1
	end,

	Radio1 = nci_ricm_utils:get_first_radio(),

	ct:pal("Action1"),			
	%% Add Carriers UL
	ok = nci_dci_actions:carrier_setup3(Radio1 ++ [
										{xioPort, 0},
										{direction, ?RICM_CARRIER_DIRECTION_UL},
										{carrierId, 1},
										{posA, 0},
										{noOfSamples, 2},
										{isSubBand, ?ELIB_CONST_HWU_YES},
										{expectedSigNo, ?RICM_CARRIER_SETUP_REJ},
										{errorCode, 1},
										{errorDescription, {regexp, "ruId not in use*"}}]),
												
	ct:pal("Action2"),
	%% Add Carriers DL
	ok = nci_dci_actions:carrier_setup3(Radio1 ++ [
										{xioPort, XioPortDL},
										{direction, ?RICM_CARRIER_DIRECTION_DL},
										{carrierId, 2},
										{posA, 0},
										{noOfSamples, 2},
										{isSubBand, ?ELIB_CONST_HWU_YES},
										{expectedSigNo, ?RICM_CARRIER_SETUP_REJ},
										{errorCode, 1},
										{errorDescription, {regexp, "ruId not in use*"}}]),
	
	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).	
	
%%------------------------------------------------------------------------------
%% $Id DCI_CS5
%%
%% $Header
%%  Invalid direction
%%
%% $Description
%%  Verify carrier setup, invalid direction
%%
%% $Requirements
%%  CBD_RICM_DCI-IQ_FU:1:C
%%
%%  CBD_RICM_LTE-IQ_FU:3:C
%%
%%  CBD_RICM_LTE-IQ_FU:4:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%% $Precondition
%%  The DU BC is in state starting.
%%
%%  CPRI links are not started
%%
%%  No carrier setup
%%
%% $Action_1
%%  Send a RICM_START_CPRI_LINK_REQ
%%
%% $Result_1
%%  RICM_START_CPRI_LINK_CFM is received
%%
%%% $Action_2
%%  Send a CARRIER_SETUP_REQ with parameters :
%%
%%  ruId = 1, carrierId = 0, direction = 2 , xioPort = 0 , noOfSamples = 1, isSubBand = 1
%%
%% $Result_2
%%  A CARRIER_SETUP_REJ is received with parameters:
%%
%%  carrierId = 0
%%
%%  errorCode = UNSUCCESSFUL
%%
%%  carrierErrorCode = CARRIER_NO_ERROR
%%
%%  errorDescription = "invalid direction"
%%
%% $Action_3
%%  Send a CARRIER_SETUP_REQ with parameters :
%%
%%  ruId = 1, carrierId = 1, direction = 10 , xioPort = 1 , noOfSamples = 1, isSubBand = 1
%%
%% $Result_3
%%  A CARRIER_SETUP_REJ is received with parameters:
%%
%%  carrierId = 0
%%
%%  errorCode = UNSUCCESSFUL
%%
%%  carrierErrorCode = CARRIER_NO_ERROR
%%
%%  errorDescription = "invalid direction"
%%
%% $Action_4
%%  Repeat Action_1, Action_2 and Action_3 for all the connected radios
%%
%% $Result_5
%%  The same results for all the connected radios
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  2012-10-31, EJONUNA
%%
%% Revision history:
%%  2012-10-30, EYANWZH
%%    First version
%%
%%------------------------------------------------------------------------------
dci_cs5() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_RICM_DCI-IQ_FU:1:C,CBD_RICM_LTE-IQ_FU:3:C,CBD_RICM_LTE-IQ_FU:3:C"},
				{slogan, "Invalid direction"},
				{hwConfig, hwConfigA}]}].

dci_cs5(_Config) ->
	ct:pal("dci_cs5"),
	
	% Set state, make audit, establish BCI and DCI connections, subscribe faults
	set_state_and_connect(starting_lmc_loaded),
	
	%% Subscribe Faults DCI
	ok = nci_dci_actions:subscribe_faults([]),
	
	XioPortDL = case nci_common_utils:get_du() of
		dul -> 1;
		dus -> 6;
		mRBS_lte -> 6;
		_ -> 1
	end,

	Radios = nci_ricm_utils:get_all_radios(),
	
	lists:foreach(fun(Radio) ->

		RuId = proplists:get_value(ruId,Radio),
		PortNo = proplists:get_value(portNo,Radio),

		%ct:pal("RuId ~p PortNo ~p~n", [RuId, PortNo]),

		%% Start CPRI
		ok = nci_dci_actions:start_cpri_link(Radio),
		ok = nci_dci_actions:cpri_link_ind(Radio ++ [{typeOfUnit, '_'},{availStatus, 1}]),

		%% Add Radio Control
		nci_dci_actions:add_radio_control(Radio ++ [{expectedSigNo, ?RICM_ADD_RADIO_CTL_CFM}]),
		nci_dci_actions:radio_control_ind(Radio ++ [{connStatus, 1},{radioSoftware, application}]),

		%% Add Carriers UL
		ok = nci_dci_actions:carrier_setup3([{ruId, RuId},
											{xioPort, 0},
											{direction, 2},
											{carrierId, 2*PortNo-2},
											{posA, 2*PortNo-2},
											{noOfSamples, 2},
											{isSubBand, ?ELIB_CONST_HWU_YES},
											{expectedSigNo, ?RICM_CARRIER_SETUP_REJ},
											{errorCode, 1},
											{errorDescription, {regexp, "Invalid direction*"}}]),
		%% Add Carriers DL
		ok = nci_dci_actions:carrier_setup3([{ruId, RuId},
											{xioPort, XioPortDL},
											{direction, 10},
											{carrierId, 2*PortNo-1},
											{posA, 2*PortNo-2},
											{noOfSamples, 2},
											{isSubBand, ?ELIB_CONST_HWU_YES},
											{expectedSigNo, ?RICM_CARRIER_SETUP_REJ},
											{errorCode, 1},
											{errorDescription, {regexp, "Invalid direction*"}}])

	end,
	Radios),
			
	reset_all_cpri_links(Radios),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id DCI_CS8
%%
%% $Header
%%  Max Allocation
%%
%% $Description
%%  Verify carrier setup, Max Allocation, Allocates all slots. using all supported BW
%%
%% $Requirements
%%  CBD_RICM_DCI-IQ_FU:1:C
%%  CBD_RICM_LTE-IQ_FU:3:C
%%  CBD_RICM_LTE-IQ_FU:4:C
%%  CBD_RICM_LTE-IQ_FU:7:E
%%
%% $External References
%%  -
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%% $Precondition
%%  CPRI links is started according to configuration
%%
%%  No carrier setup
%%
%% $Action_1
%%  Setup max carriers according to configuration
%%
%%  See Appendix for max carrier setup
%%
%% $Result_1
%%  Carriers setup successfully
%%  Check that the following registers are setup
%%  For DUL-20
%%  * Common Configuration register in XIO_I block (addr: 0x3f2)
%%  * Egress link configuration registers for UL (addr: 0x4c0-0x4c8) and DL (addr: 0x440-0x454) in IQ_X block
%%  * Ingress link configuration registers for UL (addr: 0x480-0x494) and DL (addr: 0x400-0x408) in IQ_X block
%%  * Configuration word in control memory for UL (addr: 0x600-0x5e) and DL (addr: 0x540-0x5fe) in IQ_X block
%%  For DUS-41 (DUXI)
%%  * Egress link configuration registers for UL (addr: 0x68c0-0x6910) and DL (addr: 0x6800-0x68af) in IQ_X block
%%  * Ingress link configuration registers for UL (addr: 0x6050-0x610f) and DL (addr: 0x6000-0x606f) in IQ_X block
%%  * Configuration word in control memory for UL (addr: 0x7600-0x7880) and DL (addr: 0x7000-0x75ff) in IQ_X block
%%
%% $Action_2
%%  Send a CARRIER_SETUP_REQ with parameters:
%%
%%  ruId = ruid which have maxed cpri link, carrierId = carrierId which is free, direction = UL
%%
%% $Result_2
%%  A CARRIER_SETUP_REJ is received with parameters:
%%
%%  carrierId = Corresponding ruId
%%
%%  errorCode = ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL
%%
%%  carrierErrorCode = RICM_CARRIER_RESOURCE_SHORTAGE_CPRI
%%
%% $Action_3
%%  Send a CARRIER_SETUP_REQ with parameters:
%%
%%  ruId = ruid which have maxed cpri link, carrierId = carrierId which is free, direction = DL
%%
%% $Result_3
%%  A CARRIER_SETUP_REJ is received with parameters:
%%
%%  carrierId = Corresponding ruId
%%
%%  errorCode = ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL
%%
%%  carrierErrorCode = RICM_CARRIER_RESOURCE_SHORTAGE_CPRI
%%
%% $Action_4
%%  Release all carriers
%%
%% $Result_4
%%  Carriers released successfully
%%
%% $Action_5
%%  Release cpri links
%%
%% $Result_5
%%  Cpri links released successfully
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  2012-10-30, EBACEMI
%%
%% Revision history:
%%  2012-10-30, EJONUNA
%%    First version
%%  2013-10-30, ehuayya
%%    corrected usage of ruPortNo for nci_rici_actions:get_current_port
%%
%%------------------------------------------------------------------------------
dci_cs8() ->
	[{userdata,[{wp, ""},
				{requirement, "CBD_RICM_DCI-IQ_FU:1:C, CBD_RICM_LTE-IQ_FU:3:C, CBD_RICM_LTE-IQ_FU:4:C, CBD_RICM_LTE-IQ_FU:7:E"},
				{slogan, "Verify carrier setup, Max Allocation, Allocates all slots. using all supported BW"},
				{hwConfig, hwConfigA}]}].

dci_cs8(_Config) ->
	dci_cs8("dci_cs8",[{}]).

dci_cs8_slave_du() ->
	[{userdata,[{wp, ""},
				{requirement, "CBD_RICM_DCI-IQ_FU:1:C, CBD_RICM_LTE-IQ_FU:3:C, CBD_RICM_LTE-IQ_FU:4:C, CBD_RICM_LTE-IQ_FU:7:E"},
				{slogan, "Verify carrier setup, Max Allocation, Allocates all slots. using all supported BW"},
				{nodeConfig, nodeConfigA},
				{hwConfigDu0, hwConfigA},
				{hwConfigDu1, hwConfigA}]}].

dci_cs8_slave_du(_Config) ->
	dci_cs8("dci_cs8",[{duRole,slave}]).

dci_cs8(Name,Parameters) ->
	ct:pal(Name),

	Band = proplists:get_value(bandtype,Parameters,subband),

	{Radios,DcServer,MaxCarriers,RadioConfigurationResult,CapabilitiesResult} = max_allocation_pre(Parameters),

	case Band of
		fullband ->
			IsSubBand = ?ELIB_CONST_HWU_NO;
		_->
			IsSubBand = ?ELIB_CONST_HWU_YES
	end,

	ct:pal("Action_1"),

	lists:foreach(
		fun({_CarrierSetupItemName,CarrierSetupItem}) ->
				ok = nci_dci_actions:carrier_setup3(CarrierSetupItem ++ [{dcServer,DcServer},{isSubBand,IsSubBand}])
		end,
		MaxCarriers),
	
	ct:pal("Result_1"),
	
	MaxCarrierId = 
		lists:foldl(
			fun({_CarrierSetupItemName,CarrierSetupItem},MaxCarrierIdCurrent) ->
					CarrierId = proplists:get_value(carrierId,CarrierSetupItem),
					if MaxCarrierIdCurrent < CarrierId ->
							CarrierId;
					   true ->
							MaxCarrierIdCurrent
					end
			end,
			-1,
			MaxCarriers),
	
	ct:pal("Action_2"),
	%%Test cpri link shortage reject on uplink 
	MaxedCpriLinkUplink = nci_dci_actions:get_carrier_setup_with_maxed_cpri_link(RadioConfigurationResult,CapabilitiesResult,uplink),

	if MaxedCpriLinkUplink == undefined ->
			ct:pal("XioPortLimited: No more testing possible to do with current configuration: ~p~n",[Radios]),
			ok;
	   true ->
			MaxedCpriLinkUplinkResult = MaxedCpriLinkUplink ++ [{carrierId, MaxCarrierId+1},
																{expectedSigNo,?RICM_CARRIER_SETUP_REJ},
																{errorCode,?ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL},
																{carrierErrorCode,?RICM_CARRIER_RESOURCE_SHORTAGE_CPRI}], 
			
			ok = nci_dci_actions:carrier_setup3(MaxedCpriLinkUplinkResult ++ [{dcServer,DcServer},{isSubBand,IsSubBand}])
	end,
	ct:pal("Result_2"),

	ct:pal("Action_3"),

	%%Test cpri link shortage reject on downlink
	MaxedCpriLinkDownlink = nci_dci_actions:get_carrier_setup_with_maxed_cpri_link(RadioConfigurationResult,CapabilitiesResult,downlink),

	if MaxedCpriLinkDownlink == undefined ->
			ct:pal("XioPortLimited: No more testing possible to do with current configuration: ~p~n",[Radios]),
			ok;
	   true ->
			MaxedCpriLinkDownlinkResult = MaxedCpriLinkDownlink ++ [{carrierId, MaxCarrierId+2},
																	{expectedSigNo,?RICM_CARRIER_SETUP_REJ},
																	{errorCode,?ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL},
																	{carrierErrorCode,?RICM_CARRIER_RESOURCE_SHORTAGE_CPRI}],
			ok = nci_dci_actions:carrier_setup3(MaxedCpriLinkDownlinkResult ++ [{dcServer,DcServer},{isSubBand,IsSubBand}])
	end,

	ct:pal("Result_3"),

	ct:pal("Action_4"),

	lists:foreach(
		fun({_CarrierSetupItemName,CarrierSetupItem}) ->
				ok = nci_dci_actions:carrier_release(CarrierSetupItem ++ [{dcServer,DcServer}])
		end,
		MaxCarriers),
	
	ct:pal("Result_4"),

	ct:pal("Action_5"),

	reset_all_cpri_links(Radios),

	ct:pal("Result_5"),

	nci_common_utils:check_outstanding_faults(2000).


max_allocation_pre(Parameters) ->

	DuRole = proplists:get_value(duRole,Parameters,master),
	Slotlist = proplists:get_value(slotlist,Parameters,"_"),
	case DuRole of
		slave ->
			Radios = nci_ricm_utils:get_all_radios([{du, du1}]),
			ct:pal("The slave DU has radios: ~p~n",[Radios]),

			BcServer = "000200/BcServer",
			DcServer = "000200/BcServer",
			%% Wait for the slave to load all loadmodules
			ct:pal("Waiting for slave..."),
			cpp_lib:poll_load_start(?SHELL_COMMAND, "000200", 120*1000),
			ct:pal("Slave is up");
		_ ->
			Radios = nci_ricm_utils:get_all_radios(),
			ct:pal("The master DU has radios: ~p~n",[Radios]),

			BcServer = ?BC_SERVER,
			DcServer = ?DC_SERVER
	end,

	% Set state, make audit, establish BCI and DCI connections, bci subscribe faults
	set_state_and_connect( operational, BcServer, DcServer ),

	ok = nci_dci_actions:subscribe_faults([{dcServer,DcServer}]),

	%% Start CPRI
	lists:foreach(fun(Radio) ->
		%% Start CPRI
		ok = nci_dci_actions:start_cpri_link(Radio ++ [{dcServer,DcServer}]),
		ok = nci_dci_actions:cpri_link_ind(Radio ++ [{dcServer,DcServer}]),

		%% Add Radio Control
		nci_dci_actions:add_radio_control(Radio ++ [{expectedSigNo, ?RICM_ADD_RADIO_CTL_CFM}]),
		nci_dci_actions:radio_control_ind(Radio ++ [{connStatus, 1},{radioSoftware, application}])

	end,
	Radios),

	Radio1 = nci_ricm_utils:get_first_radio(),
	RuLnhPath = proplists:get_value(ruLnhPath,Radio1),

	nci_rici_actions:conn_establish(Radio1 ++ [{ruLnhPath,RuLnhPath}]),
	nci_rici_actions:get_current_port(Radio1 ++ [{ruLnhPath,RuLnhPath},{timeoutOk,true}]),

	RadiosRaw = nci_ricm_utils:get_radios_raw(),
	case Slotlist of
		[8] ->
			{MaxCarriers,RadioConfigurationResult,CapabilitiesResult} = nci_dci_actions:carrier_setup3_max([{dcServer,DcServer},{slotSizeList, [8]} ],RadiosRaw);
		_ ->
			{MaxCarriers,RadioConfigurationResult,CapabilitiesResult} = nci_dci_actions:carrier_setup3_max([{dcServer,DcServer}],RadiosRaw)
	end,
	{Radios,DcServer,MaxCarriers,RadioConfigurationResult,CapabilitiesResult}.
%%------------------------------------------------------------------------------
%% $Id DCI_CS8_FULLBAND
%%
%% $Header
%%  Max Allocation
%%
%% $Description
%%  Carrier Setup, Max Allocation with isSubBand set to NO (fullband).
%%
%% $Requirements
%%  CBD_RICM_DCI-IQ_FU:1:C
%%  CBD_RICM_LTE-IQ_FU:3:C
%%  CBD_RICM_LTE-IQ_FU:4:C
%%  CBD_RICM_LTE-IQ_FU:7:E
%%
%% $External References
%%  -
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%% $Precondition
%%  CPRI links is started according to configuration
%%
%%  No carrier setup
%%
%% $Action_1
%%  Setup max carriers according to configuration with fullband
%%
%%  See Appendix for max carrier setup
%%
%% $Result_1
%%  Carriers setup successfully
%%  Check that the following registers are setup
%%  For DUL-20
%%  * Common Configuration register in XIO_I block (addr: 0x3f2)
%%  * Egress link configuration registers for UL (addr: 0x4c0-0x4c8) and DL (addr: 0x440-0x454) in IQ_X block
%%  * Ingress link configuration registers for UL (addr: 0x480-0x494) and DL (addr: 0x400-0x408) in IQ_X block
%%  * Configuration word in control memory for UL (addr: 0x600-0x5e) and DL (addr: 0x540-0x5fe) in IQ_X block
%%  For DUS-41 (DUXI)
%%  * Egress link configuration registers for UL (addr: 0x68c0-0x6910) and DL (addr: 0x6800-0x68af) in IQ_X block
%%  * Ingress link configuration registers for UL (addr: 0x6050-0x610f) and DL (addr: 0x6000-0x606f) in IQ_X block
%%  * Configuration word in control memory for UL (addr: 0x7600-0x7880) and DL (addr: 0x7000-0x75ff) in IQ_X block
%%
%% $Action_2
%%  Send a CARRIER_SETUP_REQ with parameters:
%%
%%  ruId = ruid which have maxed cpri link, carrierId = carrierId which is free, direction = UL
%%
%% $Result_2
%%  A CARRIER_SETUP_REJ is received with parameters:
%%
%%  carrierId = Corresponding ruId
%%
%%  errorCode = ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL
%%
%%  carrierErrorCode = RICM_CARRIER_RESOURCE_SHORTAGE_CPRI
%%
%% $Action_3
%%  Send a CARRIER_SETUP_REQ with parameters:
%%
%%  ruId = ruid which have maxed cpri link, carrierId = carrierId which is free, direction = DL
%%
%% $Result_3
%%  A CARRIER_SETUP_REJ is received with parameters:
%%
%%  carrierId = Corresponding ruId
%%
%%  errorCode = ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL
%%
%%  carrierErrorCode = RICM_CARRIER_RESOURCE_SHORTAGE_CPRI
%%
%% $Action_4
%%  Release all carriers
%%
%% $Result_4
%%  Carriers released successfully
%%
%% $Action_5
%%  Release cpri links
%%
%% $Result_5
%%  Cpri links released successfully
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%
%%
%% Revision history:
%%  2013-08-26, Eyanwzh
%%    First version
%%
%%------------------------------------------------------------------------------
dci_cs8_fullband() ->
	[{userdata,[ {wp, ""},
				{requirement, "CBD_RICM_DCI-IQ_FU:1:C, CBD_RICM_LTE-IQ_FU:3:C, CBD_RICM_LTE-IQ_FU:4:C, CBD_RICM_LTE-IQ_FU:7:E"},
				{slogan, "Carrier Setup, Max Allocation with isSubBand set to NO (fullband)"},
				{hwConfig, hwConfigA}]}].

dci_cs8_fullband(_Config) ->
	dci_cs8("dci_cs8_fullband",[{bandtype,fullband}]).

%%------------------------------------------------------------------------------
%% $Id DCI_CS9
%%
%% $Header
%%  Re-use allocations
%%
%% $Description
%% Verify carrier setup, Max Allocation, Allocates all slots. using all supported BW
%% Also checks allocation algorithm and configuration of registers in GIC. Relase and reuse allocations
%%
%% $Requirements
%%  CBD_RICM_DCI-IQ_FU:1:C
%%
%% $Type
%%  regression
%%
%% $History
%%  -
%%
%% $Precondition
%%  CPRI links is started according to configuration
%%
%%  No carrier setup
%%
%% $Action_1
%%  Setup max carriers according to configuration
%%
%% $Result_1
%%  Carriers setup successfully
%%
%% $Action_2
%%  Send a CARRIER_SETUP_REQ with parameters:
%%
%%  ruId = ruid which have maxed cpri link, carrierId = carrierId which is free, direction = UL
%%
%% $Result_2
%%  A CARRIER_SETUP_REJ is received with parameters:
%%
%%  carrierId = Corresponding ruId
%%
%%  errorCode = ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL
%%
%%  carrierErrorCode = RICM_CARRIER_RESOURCE_SHORTAGE_CPRI
%%
%% $Action_3
%%  Send a CARRIER_SETUP_REQ with parameters:
%%
%%  ruId = ruid which have maxed cpri link, carrierId = carrierId which is free, direction = DL
%%
%% $Result_3
%%  A CARRIER_SETUP_REJ is received with parameters:
%%
%%  carrierId = Corresponding ruId
%%
%%  errorCode = ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL
%%
%%  carrierErrorCode = RICM_CARRIER_RESOURCE_SHORTAGE_CPRI
%%
%% $Action_4
%%  Release UL carriers in order to have more capacity on xio link then exists on cpri link to a single RU
%%
%% $Result_4
%%  Carriers released successfully
%%
%% Some xio capacity is now available in UL . Try to setup with the now free number of slots on the xio link to a RU with limited cpri capacity.
%%
%% $Action_5
%%  CARRIER_SETUP_REQ
%%
%%  ruId = ruid that before release had no free slots, carrierId = carrierId which is free, direction = UL, slots = number of free slots on xio link
%%
%% $Result_5
%%  A CARRIER_SETUP_REJ is received with parameters:
%%
%%  carrierId = Corresponding ruId
%%
%%  errorCode = ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL
%%
%%  carrierErrorCode = RICM_CARRIER_RESOURCE_SHORTAGE_CPRI
%%
%% $Action_6
%%  Re-allocate those two carriers that previously was released
%%
%% $Result_6
%%  Carriers successfully allocated.
%%
%% $Action_7
%%  Send a CARRIER_SETUP_REQ with parameters:
%%
%%  ruId = ruid which have maxed cpri link, carrierId = carrierId which is free, direction = DL
%%
%% $Result_7
%%  A CARRIER_SETUP_REJ is received with parameters:
%%
%%  carrierId = Corresponding ruId
%%
%%  errorCode = ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL
%%
%%  carrierErrorCode = RICM_CARRIER_RESOURCE_SHORTAGE_CPRI
%%
%% $Action_8
%%  Release DL carriers in order to have more capacity on xio link then exists on cpri link to a single RU
%%
%% $Result_8
%%  Carriers released successfully
%%
%% Some xio capacity is now available in UL . Try to setup with the now free number of slots on the xio link to a RU with limited cpri capacity.
%%
%% $Action_9
%%  CARRIER_SETUP_REQ
%%
%%  ruId = ruid that before release had no free slots, carrierId = carrierId which is free, direction = DL, slots = number of free slots on xio link
%%
%% $Result_9
%%  A CARRIER_SETUP_REJ is received with parameters:
%%
%%  carrierId = Corresponding ruId
%%
%%  errorCode = ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL
%%
%%  carrierErrorCode = RICM_CARRIER_RESOURCE_SHORTAGE_CPRI
%%
%% $Action_10
%%  Re-allocate those two carriers that previously was released
%%
%% $Result_10
%%  Carriers successfully allocated.
%%
%% $Action_11
%%  Send a CARRIER_SETUP_REQ with parameters:
%%
%%  ruId = ruid which have maxed cpri link, carrierId = carrierId which is free, direction = UL
%%
%% $Result_11
%%  A CARRIER_SETUP_REJ is received with parameters:
%%
%%  carrierId = Corresponding ruId
%%
%%  errorCode = ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL
%%
%%  carrierErrorCode = RICM_CARRIER_RESOURCE_SHORTAGE_CPRI
%%
%% $Action_12
%%  Release all carriers
%%
%% $Result_12
%%  Carriers released successfully
%%
%% $Action_13
%%  Release cpri links
%%
%% $Result_13
%%  Cpri links released successfully
%%
%% Review:
%%  2012-11-18, EEDAJA
%%
%% Revision history:
%%  2012-10-30, EJONUNA
%%    First version
%%  2013-10-30, ehuayya
%%    corrected usage of ruPortNo for nci_rici_actions:get_current_port
%%
%%------------------------------------------------------------------------------

dci_cs9() ->
	[{userdata,[{wp, ""},
				{requirement, "CBD_RICM_DCI-IQ_FU:1:C"},
				{slogan, "Re-use allocations"},
				{hwConfig, hwConfigA}]}].

dci_cs9(_Config) ->
	dci_cs9("dci_cs9",master).

dci_cs9_slave_du() ->
	[{userdata,[{wp, ""},
				{requirement, "CBD_RICM_DCI-IQ_FU:1:C"},
				{slogan, "Re-use allocations"},
				{nodeConfig, nodeConfigA},
				{hwConfigDu0, hwConfigA},
				{hwConfigDu1, hwConfigA}]}].

dci_cs9_slave_du(_Config) ->
	dci_cs9("dci_cs9",slave).

dci_cs9(Name,DuRole) ->
	ct:pal(Name),
	
	case DuRole of
		slave ->
			Radios = nci_ricm_utils:get_all_radios([{du, du1}]),
			ct:pal("The slave DU has radios: ~p~n",[Radios]),

			BcServer = "000200/BcServer",
			DcServer = "000200/BcServer",
			%% Wait for the slave to load all loadmodules
			ct:pal("Waiting for slave..."),
			cpp_lib:poll_load_start(?SHELL_COMMAND, "000200", 120*1000),
			ct:pal("Slave is up");
		_ ->
			Radios = nci_ricm_utils:get_all_radios(),
			ct:pal("The master DU has radios: ~p~n",[Radios]),

			BcServer = ?BC_SERVER,
			DcServer = ?DC_SERVER
	end,

	% Set state, make audit, establish BCI and DCI connections, bci subscribe faults
	set_state_and_connect( operational, BcServer, DcServer),

	ok = nci_dci_actions:subscribe_faults([{dcServer,DcServer}]),

	%% Start CPRI	
	lists:foreach(fun(Radio) ->

		%% Start CPRI
		ok = nci_dci_actions:start_cpri_link(Radio ++ [{dcServer,DcServer}]),
		ok = nci_dci_actions:cpri_link_ind(Radio ++ [{dcServer,DcServer}]),

		%% Add Radio Control
		nci_dci_actions:add_radio_control(Radio ++ [{expectedSigNo, ?RICM_ADD_RADIO_CTL_CFM}]),
		nci_dci_actions:radio_control_ind(Radio ++ [{connStatus, 1},{radioSoftware, application}])
	
	end,
	Radios),

	Radio1 = nci_ricm_utils:get_first_radio(),
	RuLnhPath = proplists:get_value(ruLnhPath,Radio1),

	nci_rici_actions:conn_establish(Radio1 ++ [{ruLnhPath,RuLnhPath}]),
	nci_rici_actions:get_current_port(Radio1 ++ [{ruLnhPath,RuLnhPath},{timeoutOk,true}]),

	ct:pal("Action_1"),
	
	RadiosRaw = nci_ricm_utils:get_radios_raw(),
	{MaxCarriers,RadioConfigurationResult,CapabilitiesResult} = nci_dci_actions:carrier_setup3_max([{dcServer,DcServer}],RadiosRaw),
	lists:foreach(fun({_CarrierSetupItemName,CarrierSetupItem}) ->
		ok = nci_dci_actions:carrier_setup3(CarrierSetupItem ++ [{dcServer,DcServer}])
	end,
	MaxCarriers),
	
	MaxCarrierId = lists:foldl(fun({_CarrierSetupItemName,CarrierSetupItem},MaxCarrierIdCurrent) ->
		CarrierId = proplists:get_value(carrierId,CarrierSetupItem),
		if MaxCarrierIdCurrent < CarrierId ->
			CarrierId;
		true ->
			MaxCarrierIdCurrent
		end
	end,
	-1,
	MaxCarriers),
	
	ct:pal("Result_1"),
	
	ct:pal("Action_2"),

	%%Test cpri link shortage reject on uplink 
	MaxedCpriLinkUplink = nci_dci_actions:get_carrier_setup_with_maxed_cpri_link(RadioConfigurationResult,CapabilitiesResult,uplink),
	
	if MaxedCpriLinkUplink == undefined ->
		ct:pal("XioPortLimited: No more testing possible to do with current configuration: ~p~n",[MaxedCpriLinkUplink]),
		ok;
	true ->
		MaxedCpriLinkUplinkResult = MaxedCpriLinkUplink ++ [{carrierId, MaxCarrierId+1},{expectedSigNo,?RICM_CARRIER_SETUP_REJ},{errorCode,?ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL},{carrierErrorCode,?RICM_CARRIER_RESOURCE_SHORTAGE_CPRI}], 		
		ok = nci_dci_actions:carrier_setup3(MaxedCpriLinkUplinkResult ++ [{dcServer,DcServer}])
	end,
	
	ct:pal("Result_2"),

	ct:pal("Action_3"),
	%%Test cpri link shortage reject on downlink
	MaxedCpriLinkDownlink = nci_dci_actions:get_carrier_setup_with_maxed_cpri_link(RadioConfigurationResult,CapabilitiesResult,downlink),
	
	if MaxedCpriLinkDownlink == undefined ->
		ct:pal("XioPortLimited: No more testing possible to do with current configuration: ~p~n",[MaxedCpriLinkDownlink]),
		ok;
	true ->
		MaxedCpriLinkDownlinkResult = MaxedCpriLinkDownlink ++ [{carrierId, MaxCarrierId+2},{expectedSigNo,?RICM_CARRIER_SETUP_REJ},{errorCode,?ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL},{carrierErrorCode,?RICM_CARRIER_RESOURCE_SHORTAGE_CPRI}], 		
		ok = nci_dci_actions:carrier_setup3(MaxedCpriLinkDownlinkResult ++ [{dcServer,DcServer}])
	end,
	
	ct:pal("Result_3"),
	
	ActionNumberBaseUL = 4,
	dci_cs9_test_over_allocation(MaxCarriers,RadioConfigurationResult,CapabilitiesResult,uplink,MaxCarrierId+3,ActionNumberBaseUL,
DcServer),
	ct:pal("Action_7"),

	if MaxedCpriLinkUplink == undefined ->
		ct:pal("XioPortLimited: No more testing possible to do with current configuration: ~p~n",[MaxedCpriLinkUplink]),
		ok;
	true ->
		MaxedCpriLinkUplinkResult2 = MaxedCpriLinkUplink ++ [{carrierId, MaxCarrierId+1},{expectedSigNo,?RICM_CARRIER_SETUP_REJ},{errorCode,?ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL},{carrierErrorCode,?RICM_CARRIER_RESOURCE_SHORTAGE_CPRI}], 		
		ok = nci_dci_actions:carrier_setup3(MaxedCpriLinkUplinkResult2 ++ [{dcServer,DcServer}])
	end,
	ct:pal("Result_7"),

	ActionNumberBaseDL = 8,

	dci_cs9_test_over_allocation(MaxCarriers,RadioConfigurationResult,CapabilitiesResult,downlink,MaxCarrierId+4,ActionNumberBaseDL,DcServer),

	ct:pal("Action_11"),

	if MaxedCpriLinkDownlink == undefined ->
		ct:pal("XioPortLimited: No more testing possible to do with current configuration: ~p~n",[MaxedCpriLinkUplink]),
		ok;
	true ->
		MaxedCpriLinkDownlinkResult2 = MaxedCpriLinkDownlink ++ [{carrierId, MaxCarrierId+1},{expectedSigNo,?RICM_CARRIER_SETUP_REJ},{errorCode,?ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL},{carrierErrorCode,?RICM_CARRIER_RESOURCE_SHORTAGE_CPRI}], 		
		ok = nci_dci_actions:carrier_setup3(MaxedCpriLinkDownlinkResult2 ++ [{dcServer,DcServer}])
	end,
	ct:pal("Result_11"),


	ct:pal("Action_12"),
	
	lists:foreach(fun({_CarrierSetupItemName,CarrierSetupItem}) ->
		ok = nci_dci_actions:carrier_release(CarrierSetupItem ++ [{dcServer,DcServer}])
	end,
	MaxCarriers),
	ct:pal("Result_12"),
	
	ct:pal("Action_13"),
	reset_all_cpri_links(Radios),

	ct:pal("Result_13"),
	
	nci_common_utils:check_outstanding_faults(2000).

dci_cs9_test_over_allocation(MaxCarriers,RadioConfigurationResult,CapabilitiesResult,LinkDirection,MaxCarrierId,ActionNumberBase,DcServer) ->
	{CarrierSetupToReleaseFirst,CarrierSetupToReleaseSecond, CarrierSetupDownlinkRequest} = nci_dci_actions:get_carrier_setup_with_maxed_cpri_link2(MaxCarriers,RadioConfigurationResult,CapabilitiesResult,LinkDirection),
	
	if CarrierSetupDownlinkRequest /= undefined ->
		ct:pal("Action_~p",[ActionNumberBase]),
		ok = nci_dci_actions:carrier_release(CarrierSetupToReleaseFirst ++ [{dcServer,DcServer}]),
		if CarrierSetupToReleaseSecond /= undefined -> 
			ok = nci_dci_actions:carrier_release(CarrierSetupToReleaseSecond ++ [{dcServer,DcServer}]);
		true ->
			ok
		end,
		ct:pal("Result_~p",[ActionNumberBase]),
		ct:pal("Action_~p",[ActionNumberBase+1]),
		OverAllocationCpriLinkDownlinkResult = CarrierSetupDownlinkRequest ++ [{carrierId, MaxCarrierId},{expectedSigNo,?RICM_CARRIER_SETUP_REJ},{errorCode,?ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL},{carrierErrorCode,?RICM_CARRIER_RESOURCE_SHORTAGE_CPRI}], 		
		ok = nci_dci_actions:carrier_setup3(OverAllocationCpriLinkDownlinkResult ++ [{dcServer,DcServer}]),
		ct:pal("Result_~p",[ActionNumberBase+1]),

		ct:pal("Action_~p",[ActionNumberBase+2]),
	
		ok = nci_dci_actions:carrier_setup3(CarrierSetupToReleaseFirst ++ [{dcServer,DcServer}]),
		if CarrierSetupToReleaseSecond /= undefined -> 
			ok = nci_dci_actions:carrier_setup3(CarrierSetupToReleaseSecond ++ [{dcServer,DcServer}]);
		true ->
			ok
		end,
		ct:pal("Result_~p",[ActionNumberBase+2]);
	true ->
		ct:fail("No carrier setup found to continue this test case")
	end.

%%------------------------------------------------------------------------------
%% $Id DCI_CS10
%%
%% $Header
%%  Carrier in use
%%
%% $Description
%%  Carrier Setup, Carrier in use
%%
%% $Requirements
%%  CBD_RICM_DCI-IQ_FU:1:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  CPRI links is started according to configuration
%%
%%  Setup one carrier on each radio for uplink and downlink
%%
%% $Action_1
%%  Send a CARRIER_SETUP_REQ with parameters:
%%
%%  ruId = 1, carrierId = 0, direction = UL, xioPort = 0 , noOfSamples = 2, isSubBand = 1
%%
%% $Result_1
%%  A CARRIER_SETUP_REJ is received with parameters:
%%
%%  carrierId = 0
%%
%%  errorCode = UNSUCCESSFUL
%%
%%  carrierErrorCode = CARRIER_NO_ERROR
%%
%%  errorDescription = "carrierId already in use"
%%
%% $Action_2
%%  Send a CARRIER_SETUP_REQ with parameters:
%%
%%  ruId = 1, carrierId = 1, direction = DL, xioPort = 1(6 for dus41) , noOfSamples = 2, isSubBand = 1
%%
%% $Result_2
%%  A CARRIER_SETUP_REJ is received with parameters:
%%
%%  carrierId = 1
%%
%%  errorCode = UNSUCCESSFUL
%%
%%  carrierErrorCode = CARRIER_NO_ERROR
%%
%%  errorDescription = "carrierId already in use"
%%
%% $Action_3
%%  Repeat A1 and A2 for all the configured radios 
%%
%% $Result_4
%%  Same as in E1 and E2
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  2012-11-30, EEDAJA
%%
%% Revision history:
%%  2012-11-20, EYANWZH 
%%    First version
%%
%%------------------------------------------------------------------------------
dci_cs10() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_RICM_DCI-IQ_FU:1:C,"},
				{slogan, "Carrier in use"},
				{hwConfig, hwConfigA}]}].

dci_cs10(_Config) ->
	ct:pal("dci_cs10"),
	
	% Set state, make audit, establish BCI and DCI connections, subscribe faults
	set_state_and_connect(starting_lmc_loaded),
	
	%% Subscribe Faults DCI
	ok = nci_dci_actions:subscribe_faults([]),
	
	XioPortDL = case nci_common_utils:get_du() of
		dul -> 1;
		dus -> 5;
		mRBS_lte -> 5;
		_ -> 1
	end,
	
	NoOfSamples = 2,
	Radios = nci_ricm_utils:get_all_radios(),
	
	lists:foreach(fun(Radio) ->

		%% Start CPRI
		ok = nci_dci_actions:start_cpri_link(Radio),
		ok = nci_dci_actions:cpri_link_ind(Radio),

		%% Add Radio Control
		nci_dci_actions:add_radio_control(Radio ++ [{expectedSigNo, ?RICM_ADD_RADIO_CTL_CFM}]),
		nci_dci_actions:radio_control_ind(Radio ++ [{connStatus, 1},{radioSoftware, application}])

	end,
	Radios),
	
	lists:foreach(fun(Radio) ->

		RuId = proplists:get_value(ruId,Radio),

		%% Add Carriers UL
		ok = nci_dci_actions:carrier_setup3([{ruId, RuId},
											{xioPort, 0},
											{direction, ?RICM_CARRIER_DIRECTION_UL},
											{carrierId, 2*RuId - 2},
											{posA, (2*RuId-2) rem 30},
											{noOfSamples, NoOfSamples},
											{isSubBand, ?ELIB_CONST_HWU_YES}]),
		%% Add Carriers DL
		ok = nci_dci_actions:carrier_setup3([{ruId, RuId},
											{xioPort, XioPortDL},
											{direction, ?RICM_CARRIER_DIRECTION_DL},
											{carrierId, 2*RuId - 1},
											{posA, (2*RuId-2) rem 30},
											{noOfSamples, NoOfSamples},
											{isSubBand, ?ELIB_CONST_HWU_YES}])

	end,
	Radios),
	
	lists:foreach(fun(Radio) ->

		RuId = proplists:get_value(ruId,Radio),

		%% Add Carriers UL
		ok = nci_dci_actions:carrier_setup3([{ruId, RuId},
											{xioPort, 0},
											{direction, ?RICM_CARRIER_DIRECTION_UL},
											{carrierId, 2*RuId - 2},
											{posA, (2*RuId-2) rem 30},
											{noOfSamples, NoOfSamples},
											{isSubBand, ?ELIB_CONST_HWU_YES},
											{expectedSigNo, ?RICM_CARRIER_SETUP_REJ},
											{errorCode, 1},
											{errorDescription, {regexp, "carrierId already in use*"}}]),
		%% Add Carriers DL
		ok = nci_dci_actions:carrier_setup3([{ruId, RuId},
											{xioPort, XioPortDL},
											{direction, ?RICM_CARRIER_DIRECTION_DL},
											{carrierId, 2*RuId - 1},
											{posA, (2*RuId-2) rem 30},
											{noOfSamples, NoOfSamples},
											{isSubBand, ?ELIB_CONST_HWU_YES},
											{expectedSigNo, ?RICM_CARRIER_SETUP_REJ},
											{errorCode, 1},
											{errorDescription, {regexp, "carrierId already in use*"}}])

	end,
	Radios),	

	reset_all_cpri_links(Radios),

	%% Check that NO BC/DC_FAULT_IND is generated
	nci_common_utils:check_outstanding_faults(2000).	

%%------------------------------------------------------------------------------
%% $Id DCI_CS13
%%
%% $Header
%%  carrierId out of range and max value
%%
%% $Description
%%  Carrier Setup, Check when Carrier Id value is out of range, and max value. Range is 0-255.
%%
%% $Requirements
%%  CBD_RICM_DCI-IQ_FU:1:C
%%
%%  CBD_RICM_LTE-IQ_FU:3:C
%%
%%  CBD_RICM_LTE-IQ_FU:4:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  CPRI links is started with ruId = 1 - 6
%%
%%  No carriers setup
%%
%% $Action
%%  Send a CARRIER_SETUP_REQ with parameters:
%%
%%  ruId = 1, carrierId = 256, direction = UL, bandwidth = 10 MHz, bbModule = 1
%%
%% $Result
%%  A CARRIER_SETUP_REJ is received with parameters:
%%
%%  carrierId = 256
%%
%%  errorCode = UNSUCCESSFUL
%%
%%  carrierErrorCode = CARRIER_NO_ERROR
%%
%%  errorDescription = "Invalid carrierId"
%%
%% $Action
%%  Send a CARRIER_SETUP_REQ with parameters:
%%
%%  ruId = 1, carrierId = 256, direction = DL, bandwidth = 10 MHz, bbModule = 1
%%
%% $Result
%%  A CARRIER_SETUP_REJ is received with parameters:
%%
%%  carrierId = 256
%%
%%  errorCode = UNSUCCESSFUL
%%
%%  carrierErrorCode = CARRIER_NO_ERROR
%%
%%  errorDescription = "Invalid carrierId"
%%
%% $Action
%%  Repeat A1 - A2 for ruId = 2 - 6
%%
%% $Result
%%  Same as in E1 - E2
%%
%% $Action
%%  Send a CARRIER_SETUP_REQ with parameters:
%%
%%  ruId = 1, carrierId = 255, direction = UL, bandwidth = 10 MHz, bbModule = 1
%%
%% $Result
%%  A CARRIER_SETUP_CFM is received with parameters:
%%
%%  carrierId = 255
%%
%% $Action
%%  Send a CARRIER_SETUP_REQ with parameters:
%%
%%  ruId = 1, carrierId = 255, direction = DL, bandwidth = 10 MHz, bbModule = 1
%%
%% $Result
%%  A CARRIER_SETUP_CFM is received with parameters:
%%
%%  carrierId = 255
%%
%% $Action
%%  Repeat A5 - A6 for ruId = 2 - 6
%%
%% $Result
%%  Same as in E5 - E26
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  2012-12-17, EEDAJA
%%
%% Revision history:
%%  2012-12-10, EXIOLUO
%%    First version
%%  2012-12-19, EXIOLUO
%%    Update according to review comments
%%------------------------------------------------------------------------------
dci_cs13() ->
	[{userdata,[{wp, ""},
				{requirement, "CBD_RICM_DCI-IQ_FU:1:C"},
				{slogan, "carrierId out of range and max value"}]}].
dci_cs13(_Config) ->
	% Set state, make audit, establish BCI and DCI connections, bci subscribe faults
	set_state_and_connect( operational),
	ok = nci_dci_actions:subscribe_faults([]),
	
	%% Start CPRI	
	Radios = nci_ricm_utils:get_all_radios(),
	lists:foreach(fun(Radio) ->
		%% Start CPRI
		ok = nci_dci_actions:start_cpri_link(Radio),
		ok = nci_dci_actions:cpri_link_ind(Radio),

		%% Add Radio Control
		nci_dci_actions:add_radio_control(Radio ++ [{expectedSigNo, ?RICM_ADD_RADIO_CTL_CFM}]),
		nci_dci_actions:radio_control_ind(Radio ++ [{connStatus, 1},{radioSoftware, application}])

	end,
	Radios),	
	
	XioPortDL = case nci_common_utils:get_du() of
		dul -> 1;
		dus -> 5;
		mRBS_lte -> 5;
		_ -> 1
	end,
	
	lists:foreach(fun(Radio) ->

		ok = nci_dci_actions:carrier_setup3(Radio ++ [{xioPort, 0},
										{direction, ?RICM_CARRIER_DIRECTION_UL},
										{carrierId, 256},
										{posA, 0},
										{noOfSamples, 2},
										{isSubBand, ?ELIB_CONST_HWU_YES},
										{expectedSigNo, ?RICM_CARRIER_SETUP_REJ},
										{errorCode, ?RICM_CARRIER_RESOURCE_SHORTAGE_CPRI},
										{errorDescription, {regexp, "Invalid carrierId*"}}])

	end,
	Radios),
	
	
	lists:foreach(fun(Radio) ->

		ok = nci_dci_actions:carrier_setup3(Radio ++ [{xioPort, XioPortDL},
										{direction, ?RICM_CARRIER_DIRECTION_DL},
										{carrierId, 256},
										{posA, 0},
										{noOfSamples, 2},
										{isSubBand, ?ELIB_CONST_HWU_YES},
										{expectedSigNo, ?RICM_CARRIER_SETUP_REJ},
										{errorCode, ?RICM_CARRIER_RESOURCE_SHORTAGE_CPRI},
										{errorDescription, {regexp, "Invalid carrierId*"}}])

	end,
	Radios),
	
	lists:foreach(fun(Radio) ->

		%% Setup Carrier UL
		ok = nci_dci_actions:carrier_setup3(Radio ++ [{xioPort, 0},
											{direction, ?RICM_CARRIER_DIRECTION_UL},
											{carrierId, 255},
											{posA, 0},
											{noOfSamples, 2},
											{isSubBand, ?ELIB_CONST_HWU_YES}]),
		%% Release Carrier UL
		ok = nci_dci_actions:carrier_release([{carrierId, 255},
											{expectedSigNo, ?RICM_CARRIER_RELEASE_CFM}])

	end,
	Radios),
	
	lists:foreach(fun(Radio) ->


		%% Setup Carrier DL
		ok = nci_dci_actions:carrier_setup3(Radio ++ [{xioPort, XioPortDL},
											{direction, ?RICM_CARRIER_DIRECTION_DL},
											{carrierId, 255},
											{posA, 0},
											{noOfSamples, 2},
											{isSubBand, ?ELIB_CONST_HWU_YES}]),
		%% Release Carrier DL
		ok = nci_dci_actions:carrier_release([{carrierId, 255},
											{expectedSigNo, ?RICM_CARRIER_RELEASE_CFM}])

	end,
	Radios),
	
	reset_all_cpri_links(Radios),

	%% Check that NO BC/DC_FAULT_IND is generated
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id DCI_CS14
%%
%% $Header
%%  DP not loaded
%%
%% $Description
%%  Carrier Setup, DP not loaded.
%%
%% $Requirements
%%  CBD_RICM_DCI-IQ_FU:1:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  The LMC is NOT loaded.
%%
%% $Action_1
%%  Send a CARRIER_SETUP_REQ with parameters:
%%
%%  ruId = 1, carrierId = 0, direction = UL, xioPort = 0 , noOfSamples = 2, isSubBand = 1
%%
%% $Result_1
%%  A CARRIER_SETUP_REJ is received with parameters:
%%
%%  carrierId = 0
%%
%%  errorCode = UNSUCCESSFUL
%%
%%  carrierErrorCode = CARRIER_NO_ERROR
%%
%%  errorDescription = "DP not loaded"
%%
%% $Action_2
%%  Send a CARRIER_SETUP_REQ with parameters:
%%
%%  ruId = 1, carrierId = 1, direction = DL, xioPort = 1(6 for dus41) , noOfSamples = 2, isSubBand = 1
%%
%% $Result_2
%%  A CARRIER_SETUP_REJ is received with parameters:
%%
%%  carrierId = 0
%%
%%  errorCode = UNSUCCESSFUL
%%
%%  carrierErrorCode = CARRIER_NO_ERROR
%%
%%  errorDescription = "DP not loaded"
%%
%% $Action_3
%%  Repeat A1 and A2 for all the configured radios
%%
%% $Result_3
%%  Same as in E1 - E2
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  2012-11-30, EEDAJA
%%
%% Revision history:
%%  2012-11-20, EYANWZH 
%%    First version
%%
%%------------------------------------------------------------------------------
dci_cs14() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_RICM_DCI-IQ_FU:1:C,"},
				{slogan, "Dp not loaded"},
				{hwConfig, hwConfigA}]}].

dci_cs14(_Config) ->
	ct:pal("dci_cs14"),
	
	% Set state, make audit, establish BCI and DCI connections, subscribe faults
	set_state_and_connect(starting_lmc_not_loaded),
	
	%% Subscribe Faults DCI
	ok = nci_dci_actions:subscribe_faults([]),
	
	XioPortDL = case nci_common_utils:get_du() of
		dul -> 1;
		dus -> 6;
		mRBS_lte -> 6;
		_ -> 1
	end,
	
	NoOfSamples = 2,
	Radios = nci_ricm_utils:get_all_radios(),
	 	
	lists:foreach(fun(Radio) ->

		PortNo = proplists:get_value(portNo,Radio),

		%% Start CPRI
		ok = nci_dci_actions:start_cpri_link(Radio ++ [{expectedSigNo, ?RICM_START_CPRI_LINK_REJ}]),

		%% Add Carriers UL
		ok = nci_dci_actions:carrier_setup3(Radio ++ [
											{xioPort, 0},
											{direction, ?RICM_CARRIER_DIRECTION_UL},
											{carrierId, 2*PortNo-2},
											{posA, 2*PortNo-2},
											{noOfSamples, NoOfSamples},
											{isSubBand, ?ELIB_CONST_HWU_YES},
											{expectedSigNo, ?RICM_CARRIER_SETUP_REJ},
											{errorCode, 1},
											{errorDescription, {regexp, "DP not loaded*"}}]),
		%% Add Carriers DL
		ok = nci_dci_actions:carrier_setup3(Radio ++ [
											{xioPort, XioPortDL},
											{direction, ?RICM_CARRIER_DIRECTION_DL},
											{carrierId, 2*PortNo-1},
											{posA, 2*PortNo-2},
											{noOfSamples, NoOfSamples},
											{isSubBand, ?ELIB_CONST_HWU_YES},
											{expectedSigNo, ?RICM_CARRIER_SETUP_REJ},
											{errorCode, 1},
											{errorDescription, {regexp, "DP not loaded*"}}])

	end,
	Radios),
	

	%% Check that NO BC/DC_FAULT_IND is generated
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id DCI_CS15
%%
%% $Header
%%  ruId out of range and max value
%%
%% $Description
%%  Carrier Setup, Invalid ruId. Suported range is 1-65535. And check that max value is OK to use.
%%
%% $Requirements
%%  CBD_RICM_DCI-IQ_FU:1:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  CPRI links is started with ruId 65535
%%
%%  No carriers setup
%%
%% $Action_1
%%  Send a CARRIER_SETUP_REQ with parameters:
%%
%%  ruId = 0, carrierId = 0, direction = UL
%%
%% $Result_1
%%  A CARRIER_SETUP_REJ is received with parameters:
%%
%%  carrierId = 0
%%
%%  errorCode = UNSUCCESSFUL
%%
%%  carrierErrorCode = CARRIER_NO_ERROR
%%
%%  errorDescription = "Invalid ruId"
%%
%% $Action_2
%%  Send a CARRIER_SETUP_REQ with parameters:
%%
%%  ruId = 0, carrierId = 0 direction = DL
%%
%% $Result_2
%%  A CARRIER_SETUP_REJ is received with parameters:
%%
%%  carrierId = 0
%%
%%  errorCode = UNSUCCESSFUL
%%
%%  carrierErrorCode = CARRIER_NO_ERROR
%%
%%  errorDescription = "Invalid ruId"
%%
%% $Action_3
%%  Send a CARRIER_SETUP_REQ with parameters:
%%
%%  ruId = 65535, carrierId = 0, direction = UL
%%
%% $Result_3
%%  A CARRIER_SETUP_CFM is received with parameters:
%%
%%  carrierId = 0
%%
%% $Action_4
%%  Send a CARRIER_SETUP_REQ with parameters:
%%
%%  ruId = 65535, carrierId = 0, direction = DL
%%
%% $Result_4
%%  A CARRIER_SETUP_CFM is received with parameters:
%%
%%  carrierId = 0
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  2012-12-17, EEDAJA
%%
%% Revision history:
%%  2012-12-05, EJONUNA
%%    First version
%%
%%------------------------------------------------------------------------------
dci_cs15() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_RICM_DCI-IQ_FU:1:C"},
				{slogan, "Carrier Setup, Invalid ruId. Suported range is 1-65535. And check that max value is OK to use"},
				{hwConfig, hwConfigA}]}].

dci_cs15(_Config) ->
	ct:pal("dci_cs15"),

	% Set state, make audit, establish BCI and DCI connections, subscribe faults
	set_state_and_connect( starting_lmc_loaded ),

	%% Subscribe Faults DCI
	ok = nci_dci_actions:subscribe_faults([]),
	
	XioPortDL = case nci_common_utils:get_du() of
		dul -> 1;
		dus -> 6;
		mRBS_lte -> 6;
		_ -> 1
	end,

	Radio = nci_ricm_utils:get_first_radio(),

	RadioMaxRuId = proplists:delete(ruId,Radio) ++ [{ruId,65535}],
	RadioRuId0 = proplists:delete(ruId,Radio) ++ [{ruId,0}],
	
	%% Start CPRI
	ok = nci_dci_actions:start_cpri_link(RadioMaxRuId),

	ok = nci_dci_actions:cpri_link_ind(RadioMaxRuId),

	NoOfSamples = 2,

	ct:pal("Action_1"),			

	%% Add Carriers UL
	ok = nci_dci_actions:carrier_setup3(RadioRuId0 ++ [{xioPort, 0},
								{direction, ?RICM_CARRIER_DIRECTION_UL},
								{carrierId, 0},
								{posA, 0},
								{noOfSamples, NoOfSamples},
								{isSubBand, ?ELIB_CONST_HWU_YES},
								{expectedSigNo,?RICM_CARRIER_SETUP_REJ},
								{errorCode, 1},
								{errorDescription, {regexp, "Invalid ruId*"}}]),

	ct:pal("Action_2"),			

	%% Add Carriers DL
	ok = nci_dci_actions:carrier_setup3(RadioRuId0 ++ [{xioPort, XioPortDL},
								{direction, ?RICM_CARRIER_DIRECTION_DL},
								{carrierId, 1},
								{posA, 0},
								{noOfSamples, NoOfSamples},
								{isSubBand, ?ELIB_CONST_HWU_YES},
								{expectedSigNo,?RICM_CARRIER_SETUP_REJ},
								{errorCode, 1},
								{errorDescription, {regexp, "Invalid ruId*"}}]),

	ct:pal("Action_3"),

	%% Add Carriers UL
	ok = nci_dci_actions:carrier_setup3(RadioMaxRuId ++ [{xioPort, 0},
								{direction, ?RICM_CARRIER_DIRECTION_UL},
								{carrierId, 2},
								{posA, 0},
								{noOfSamples, NoOfSamples},
								{isSubBand, ?ELIB_CONST_HWU_YES}]),
	ok = nci_dci_actions:carrier_release([{carrierId, 2}]),

	ct:pal("Action_4"),			

	%% Add Carriers DL
	ok = nci_dci_actions:carrier_setup3(RadioMaxRuId ++ [{xioPort, XioPortDL},
								{direction, ?RICM_CARRIER_DIRECTION_DL},
								{carrierId, 2},
								{posA, 0},
								{noOfSamples, NoOfSamples},
								{isSubBand, ?ELIB_CONST_HWU_YES}]),
	ok = nci_dci_actions:carrier_release([{carrierId, 2}]),

	ok = nci_dci_actions:reset_cpri_link(RadioMaxRuId),
	ok = nci_dci_actions:reset_cpri_link_ind(RadioMaxRuId),

	%% Check that NO BC/DC_FAULT_IND is generated
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id DCI_CS17
%%
%% $Header
%%  L1CB and XIO registers
%%
%% $Description
%%  Carrier Setup, Check registers for L1CB, XIO and full band.
%%
%% $Requirements
%%  CBD_RICM_DCI-IQ_FU:1:C
%%
%%  CBD_RICM_LTE-IQ_FU:6:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  CPRI link is started
%%
%%  No carriers setup
%%
%% $Action_1
%%  Send a CARRIER_SETUP_REQ with
%% RICM_CARRIER_DIRECTION_DL, isSubBand = NO (fullBand)
%%
%% $Result_1
%%  A CARRIER_SETUP_CFM is received
%%
%% $Action_2
%%  Check that the registers 0x5a0 to 0x5a6 are set correctly for full band
%%  This check covers the Ruby test case HL70519
%%
%% $Action_3
%%  Send a CARRIER_SETUP_REQ
%%
%% $Result_3
%%  A CARRIER_SETUP_CFM is received
%%
%% $Action_4
%%  Send a CARRIER_SETUP_REQ
%%
%% $Result_4
%%  A CARRIER_SETUP_CFM is received
%%
%% $Action_5, for DUL21 only
%%  Check L1CB_X_UL_LINK[3]_ADDR[2] with shellcommand "rdfpga 0x1184"
%%
%% $Result_5
%%  The value is "008f" on DUL Step2 and "0007" on DUL Step3
%%
%% $Action_6, for DUL21 only
%%  Check L1CB_X_DL_CARRIER_ID[6] with shellcommand "rdfpga 0x130c"
%%
%% $Result_6
%%  The value is "0200"
%%
%% $Action_7, for DUL21 only
%%  Check L1CB_X_DL_CARRIER_ID[6] with shellcommand "rdfpga 0x130e"
%%
%% $Result_7
%%  The value is "1201"
%%
%% $Action_8, for DUL21 only
%%  Check L1CB_CONFIG_CONTROL with shellcommand "rdfpga 0x1500"
%%
%% $Result_8
%%  The value is "0001"
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  2012-10-16, EJONUNA
%%
%% Revision history:
%%  2012-09-27, EEDAJA
%%    First version
%%
%%  2012-11-06, EEDAJA
%%    List of requirements corrected, description improved.
%%
%%------------------------------------------------------------------------------

dci_cs17() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_RICM_DCI-IQ_FU:1:C"},
				{slogan, "State operational"},
				{hwConfig, hwConfigA}]}].

dci_cs17(_Config) ->
	ct:pal("dci_cs17"),

	{ok, session_up} = coli:subscribe_state(?SHELL_COMMAND),
	{ok, session_up} = osegw:subscribe_state(?OSE_GW_DEAMON_1),

	nci_bci_states:set_state([{state, operational}]),

	%% Connect to BCI interface
	ok = nci_bci_actions:conn_establish([]),

	case nci_common_utils:get_du() of
		dus ->
			ok;
		mRBS_lte ->
			ok;
		_ ->
			ct:pal("Wait 5 seconds for BB CLK", []),
			timer:sleep(5*1000)
	end,

	%% Audit 
	ok = nci_bci_actions:audit([{expectedSigNo, ?ELIB_BC_AUDIT_CFM},
				{expectedMainState, ?ELIB_BC_MAIN_STATE_OPERATIONAL}]),

	%% Enable BB CLK
	nci_common_utils:coli_cmd("tu c e", ""),

	case nci_common_utils:get_du() of
		dul ->
			%% Check that register 0x1500 is set to zero (L1CB_CONFIG_CONTROL)
			nci_common_utils:coli_cmd("rdfpga 0x1500", "0000");
		_ -> ok
	end,

	%% Connect to DCI interface
	ok = nci_dci_actions:conn_establish([]),

	%% Subscribe Faults DCI
	ok = nci_dci_actions:subscribe_faults([]),

	Radio1 = nci_ricm_utils:get_first_radio(),

	%% Start CPRI
	ok = nci_dci_actions:start_cpri_link(Radio1),

	ok = nci_dci_actions:cpri_link_ind(Radio1 ++ [
										{typeOfUnit, '_'},
										{availStatus, 1}]),

	%% Add Carriers DL
	XioPortDL = case nci_common_utils:get_du() of
		dul -> 1;
		dus -> 6;
		mRBS_lte -> 6;
		_ -> 1
	end,

	ct:pal("Action_1"),
	ok = nci_dci_actions:carrier_setup3(Radio1 ++ [
										{xioPort, XioPortDL},
										{direction, ?RICM_CARRIER_DIRECTION_DL},
										{carrierId, 6},
										{posA, 0},
										{noOfSamples, 1},
										{isSubBand, ?ELIB_CONST_HWU_NO}]),

	%% Check registers as HL70519 (TR and Ruby test case name)
	%% L1CB_X_UL_LINK[3]_ADDR[13]
	ct:pal("Action_2"),
	nci_common_utils:coli_cmd("rdfpga 5a0", ""),  %% "0100  0101  0102  0103"
	nci_common_utils:coli_cmd("rdfpga 5a4", ""),
	ct:pal("###### Registers 0x5a0 to 0x5a6 are set correctly for full band ######"),

	%% Add Carriers DL
	ct:pal("Action_3"),
	ok = nci_dci_actions:carrier_setup3(Radio1 ++ [
										{xioPort, XioPortDL},
										{direction, ?RICM_CARRIER_DIRECTION_DL},
										{carrierId, 7},
										{posA, 8},
										{noOfSamples, 8},
										{isSubBand, ?ELIB_CONST_HWU_NO}]),

	%% Add Carriers UL
	ct:pal("Action_4"),
	ok = nci_dci_actions:carrier_setup3(Radio1 ++ [
										{xioPort, 0},
										{direction, ?RICM_CARRIER_DIRECTION_UL},
										{carrierId, 8},
										{posA, 0},
										{noOfSamples, 4},
										{isSubBand, ?ELIB_CONST_HWU_NO}]),

%	case nci_common_cfg:get_board_prodnr(?SHELL_COMMAND) of
%
%		"KDU 137 834/1" ->  %% DUL21
%
%			%% L1CB_X_UL_LINK[3]_ADDR[13]
%			ct:pal("Action_5"),
%			nci_common_utils:coli_cmd("rdfpga 0x119a", "0007"),
%			ct:pal("###### Register 0x119a is set correctly ######"),
%
%			%% L1CB_X_DL_CARRIER_ID[6]
%			ct:pal("Action_6"),
%			nci_common_utils:coli_cmd("rdfpga 0x130c", "1201"),
%			ct:pal("###### Register 0x130c is set correctly ######"),
%
%			%% L1CB_X_DL_CARRIER_ID[7]
%			ct:pal("Action_7"),
%			nci_common_utils:coli_cmd("rdfpga 0x130e", "1201"),
%			ct:pal("###### Register 0x130e is set correctly ######"),
%
%			%% L1CB_CONFIG_CONTROL
%			ct:pal("Action_8"),
%			nci_common_utils:coli_cmd("rdfpga 0x1500", "0001"),
%			ct:pal("###### Register 0x1500 is set correctly ######");
%
%		_ -> 
%			ok
%	end,

	%% Release Carrier DL
	ok = nci_dci_actions:carrier_release(Radio1 ++ [{carrierId, 6}]),
	ok = nci_dci_actions:carrier_release(Radio1 ++ [{carrierId, 7}]),
	
	%% Release Carrier UL
	ok = nci_dci_actions:carrier_release(Radio1 ++ [{carrierId, 8}]),

	%% Reset CPRI Link
	ok = nci_dci_actions:reset_cpri_link(Radio1),

	ok = nci_dci_actions:reset_cpri_link_ind(Radio1),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).



%%------------------------------------------------------------------------------
%% $Id DCI_CS18
%%
%% $Header
%%  Carrier setup - reordering
%%
%% $Description
%%  Verify carrier setup, different reordering on two carriers. 
%%  Note that DUL20 doesn't support different subband but DUS41 does support it.
%%
%% $Requirements
%%  CBD_RICM_DCI-IQ_FU:1:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%% CPRI links is started with one ru
%% No carrier setup
%%
%% $Action_1
%%  carrierId = 0, direction = DL, posA = 0, no_of_samples = 2, isSubBand = 1
%%
%% $Result_1
%%  A CARRIER_SETUP_CFM is received with parameters:
%%  carrierId = 0
%%
%% $Action_2
%%  Send the CARRIER_SETUP_REQ with parameters
%%  carrierId = 1, direction = DL, posA = 3, no_of_samples = 2, isSubBand = 0
%%
%% $Result_2
%%  For DUL20 A CARRIER_SETUP_REJ is received with parameters:
%%  errorDescription = Invalid mix of subBand
%%  For DUS41 A CARRIER_SETUP_CFM is received with parameters:
%%  carrierId = 1
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  2012-12-17, EEDAJA
%%
%% Revision history:
%%  2012-05-06, EJONUNA
%%    First version
%%
%%------------------------------------------------------------------------------
dci_cs18() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_RICM_DCI-IQ_FU:1:C"},
				{slogan, "Verify carrier setup, different reordering on two carriers"},
				{hwConfig, hwConfigA}]}].

dci_cs18(_Config) ->
	ct:pal("dci_cs18"),

	% Set state, make audit, establish BCI and DCI connections, subscribe faults
	set_state_and_connect( starting_lmc_loaded ),

	%% Subscribe Faults DCI
	ok = nci_dci_actions:subscribe_faults([]),
	
	XioPortDL = case nci_common_utils:get_du() of
		dul -> 1;
		dus -> 6;
		mRBS_lte -> 6;
		_ -> 1
	end,

	Radio = nci_ricm_utils:get_first_radio(),

	ok = nci_dci_actions:start_cpri_link(Radio),
	ok = nci_dci_actions:cpri_link_ind(Radio),
	
	NoOfSamples = 2,

	ct:pal("Action_1"),			

	ok = nci_dci_actions:carrier_setup3(Radio ++ [{xioPort, XioPortDL},
								{direction, ?RICM_CARRIER_DIRECTION_DL},
								{carrierId, 0},
								{posA, 0},
								{noOfSamples, NoOfSamples},
								{isSubBand, ?ELIB_CONST_HWU_YES}]),

	ct:pal("Action_2"),
	case nci_common_utils:get_du() of
		dul -> 
			%%DUL20 does not support different sub bands
			ok = nci_dci_actions:carrier_setup3(Radio ++ [{xioPort, XioPortDL},
										{direction, ?RICM_CARRIER_DIRECTION_DL},
										{carrierId, 1},
										{posA, 3},
										{noOfSamples, NoOfSamples},
										{isSubBand, ?ELIB_CONST_HWU_NO},
										{expectedSigNo,?RICM_CARRIER_SETUP_REJ},
										{errorCode, 1},
										{errorDescription, {regexp, "Invalid mix of subBand*"}}]);
			
		dus ->
			%%DUS41 supports different sub band 
			ok = nci_dci_actions:carrier_setup3(Radio ++ [{xioPort, XioPortDL},
										{direction, ?RICM_CARRIER_DIRECTION_DL},
										{carrierId, 1},
										{posA, 3},
										{noOfSamples, NoOfSamples},
										{isSubBand, ?ELIB_CONST_HWU_NO}]),
			ok = nci_dci_actions:carrier_release([{carrierId, 1}]);
		mRBS_lte ->
			%%mRBS supports different sub band 
			ok = nci_dci_actions:carrier_setup3(Radio ++ [{xioPort, XioPortDL},
										{direction, ?RICM_CARRIER_DIRECTION_DL},
										{carrierId, 1},
										{posA, 3},
										{noOfSamples, NoOfSamples},
										{isSubBand, ?ELIB_CONST_HWU_NO}]),
			ok = nci_dci_actions:carrier_release([{carrierId, 1}]);
		_ ->
			ct:fail("DU not supported by test case")
	end,	
	
	ok = nci_dci_actions:carrier_release([{carrierId, 0}]),

	ok = nci_dci_actions:reset_cpri_link(Radio),
	ok = nci_dci_actions:reset_cpri_link_ind(Radio),

	%% Check that NO BC/DC_FAULT_IND is generated
	nci_common_utils:check_outstanding_faults(2000).


%%------------------------------------------------------------------------------
%% $Id HM68079_CS_REUSE_RESOURCE
%%
%% $Header
%%  Re-use allocations
%%
%% $Description
%%  Verify carrier setup, Max Allocation, Allocates all slots. using all supported BW Also checks allocation algorithm and configuration of registers in GIC. Relase and reuse allocations
%%
%% $Requirements
%%  CBD_RICM_DCI-IQ_FU:1:C
%%
%%  CBD_RICM_LTE-IQ_FU:3:C
%%
%%  CBD_RICM_LTE-IQ_FU:4:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  CPRI links is started with ruId = 1 - 6
%%
%%  No carrier setup
%%
%% $Action
%%  Setup max carriers for ruId 4 - 6
%%
%%  See Appendix for max carrier setup
%%
%% $Result
%%  Carriers setup successfully
%%
%% $Action
%%  Check that the registers are setup according to [4]
%%
%% $Result
%%  Registers are setup correct
%%
%% $Action
%%  Send a CARRIER_SETUP_REQ with parameters:
%%
%%  ruId = 4, carrierId = 31, direction = UL, bandwidth = 1.4 MHz, bbModule = 1
%%
%% $Result
%%  A CARRIER_SETUP_REJ is received with parameters:
%%
%%  carrierId = 31
%%
%%  errorCode = UNSUCCESSFUL
%%
%%  carrierErrorCode = CARRIER_NO_ERROR
%%
%%  errorDescription = "Carrier allocation resource shortage CPRI"
%%
%% $Action
%%  Send a CARRIER_SETUP_REQ with parameters:
%%
%%  ruId = 4, carrierId = 31, direction = DL, bandwidth = 1.4 MHz, bbModule = 1
%%
%% $Result
%%  A CARRIER_SETUP_REJ is received with parameters:
%%
%%  carrierId = 31
%%
%%  errorCode = UNSUCCESSFUL
%%
%%  carrierErrorCode = CARRIER_NO_ERROR
%%
%%  errorDescription = "Carrier allocation resource shortage CPRI"
%%
%% $Action
%%  Repeat A1 - A3 for ruId = 5 - 6
%%
%% $Result
%%  Same as in E1 - E3
%%
%% $Action
%%  Release one carrier in UL with carrierId 8
%%
%% $Result
%%  Carrier released successfully
%%
%%  One slot is now available in UL on ruId 6 but max bandwidth is 3 MHz. Try to setup with bandwidth 10 MHz
%%
%% $Action
%%  Send a CARRIER_SETUP_REQ with parameters:
%%
%%  ruId = 6, carrierId = 8, direction = UL, bandwidth = 10 MHz, bbModule = 1
%%
%% $Result
%%  A CARRIER_SETUP_REJ is received with parameters:
%%
%%  carrierId = 8
%%
%%  errorCode = UNSUCCESSFUL
%%
%%  carrierErrorCode = CARRIER_NO_ERROR
%%
%%  errorDescription = "Carrier allocation resource shortage CPRI"
%%
%%  One slot is still free in UL on ruId 6. Try to setup with bandwidth 3 MHz
%%
%% $Action
%%  Send a CARRIER_SETUP_REQ with parameters:
%%
%%  ruId = 6, carrierId = 8, direction = UL, bandwidth = 3 MHz, bbModule = 1
%%
%% $Result
%%  A CARRIER_SETUP_CFM is received with parameters:
%%
%%  carrierId = 8
%%
%%  All slots are now occupied again
%%
%% $Action
%%  Send a CARRIER_SETUP_REQ with parameters:
%%
%%  ruId = 6, carrierId = 31, direction = UL, bandwidth = 1.4 MHz, bbModule = 1
%%
%% $Result
%%  A CARRIER_SETUP_REJ is received with parameters:
%%
%%  carrierId = 31
%%
%%  errorCode = UNSUCCESSFUL
%%
%%  carrierErrorCode = CARRIER_NO_ERROR
%%
%%  errorDescription = "Carrier allocation resource shortage CPRI"
%%
%% $Action
%%  Release one carrier in DL with carrierId 20
%%
%% $Result
%%  Carrier released successfully
%%
%%  One slot is now available in DL on ruId 5 but max bandwidth is 5 MHz. Try to setup with bandwidth 5
%%
%% $Action
%%  Send a CARRIER_SETUP_REQ with parameters:
%%
%%  ruId = 5, carrierId = 20, direction = DL, bandwidth = 10 MHz, bbModule = 1
%%
%% $Result
%%  A CARRIER_SETUP_REJ is received with parameters:
%%
%%  carrierId = 20
%%
%%  errorCode = UNSUCCESSFUL
%%
%%  carrierErrorCode = CARRIER_NO_ERROR
%%
%%  errorDescription = "Carrier allocation resource shortage CPRI"
%%
%%  One slot is still free in DL on ruId 5. Try to setup with bandwidth 5 MHz
%%
%% $Action
%%  Send a CARRIER_SETUP_REQ with parameters:
%%
%%  ruId = 5, carrierId = 20, direction = DL, bandwidth = 5 MHz, bbModule = 1
%%
%% $Result
%%  A CARRIER_SETUP_CFM is received with parameters: 
%%
%%  carrierId = 20
%%
%% $Action
%%  Release all carriers
%%
%% $Result
%%  Carriers released successfully
%%
%% $Action
%%  Repeat A1 - A12 for ruId = 1 - 3
%%
%% $Result
%%  Same as in E1 - E12
%%
%% $Postcondition
%%  -
%%
%% $End
%%------------------------------------------------------------------------------

%%------------------------------------------------------------------------------
%% $Id DCI_CSMAX_RCL_CSMAX_20MHZ
%%
%% $Header
%%  Phase synch
%%
%% $Description
%%  Carrier Setup, Max Allocation using 20MHz - reset CPRI link - start CPRI link again and set up Max Allocation again.
%%
%% $Requirements
%%  CBD_RICM_DCI-RESET-CPRI-LINK_FU:1:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  CPRI links is started according to configuration
%%
%%  No carrier setup
%%
%% $Action_1
%%  Setup max carriers with fix 20MHZ bandwith (noofsample = 8) according to configuration
%%
%%  See Appendix for max carrier setup
%%
%% $Result_1
%%  Carriers setup successfully
%%  Check that the following registers are setup
%%  For DUL-20
%%  * Common Configuration register in XIO_I block (addr: 0x3f2)
%%  * Egress link configuration registers for UL (addr: 0x4c0-0x4c8) and DL (addr: 0x440-0x454) in IQ_X block
%%  * Ingress link configuration registers for UL (addr: 0x480-0x494) and DL (addr: 0x400-0x408) in IQ_X block
%%  * Configuration word in control memory for UL (addr: 0x600-0x5e) and DL (addr: 0x540-0x5fe) in IQ_X block
%%  For DUS-41 (DUXI)
%%  * Egress link configuration registers for UL (addr: 0x68c0-0x6910) and DL (addr: 0x6800-0x68af) in IQ_X block
%%  * Ingress link configuration registers for UL (addr: 0x6050-0x610f) and DL (addr: 0x6000-0x606f) in IQ_X block
%%  * Configuration word in control memory for UL (addr: 0x7600-0x7880) and DL (addr: 0x7000-0x75ff) in IQ_X block
%%
%% $Action_2
%%  Send a RESET_CPRI_LINK_REQ with parameters according to configuration
%%
%% $Result_2
%%  A RESET_CPRI_LINK_CFM is received with parameters according to configuration
%%  A RESET_CPRI_LINK_IND is received with parameters according to configuration
%%
%% $Action_3
%%  Send a START_CPRI_LINK_REQ with parameters according to configuration
%%
%% $Result_3
%%  A START_CPRI_LINK_CFM is received
%%  A START_CPRI_LINK_IND is received with parameters:
%%  availStatus = 1
%%
%% $Action_4
%%  Repeat Action_1
%%
%% $Result_4
%%  Same as in Result_1
%%
%% $Action_5
%%  Release all carriers
%%
%% $Result_5
%%  Carriers released successfully
%%
%% $Action_6
%%  Release cpri links
%%
%% $Result_6
%%  Cpri links released successfully
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2013-09-04, eyanwzh
%%    First version
%%
%%------------------------------------------------------------------------------
dci_csmax_rcl_csmax_20mhz() ->
	[{userdata,[{wp, ""},
				{requirement, "CBD_RICM_DCI-RESET-CPRI-LINK_FU:1:C"},
				{slogan, "Carrier Setup, Max Allocation using 20MHz - reset CPRI link - start CPRI link again and set up Max Allocation again."},
				{hwConfig, hwConfigA}]}].

dci_csmax_rcl_csmax_20mhz(_Config) ->
	dci_csmax_rcl_csmax("dci_csmax_rcl_csmax_20mhz",[{slotlist,[8]}]).

%%------------------------------------------------------------------------------
%% $Id DCI_CS8_20MHZ
%%
%% $Header
%%  Max Allocation with 20MHz BW
%%
%% $Description
%%  Max Allocation with 20MHz BW
%%
%% $Requirements
%%  CBD_RICM_DCI-IQ_FU:1:C
%%  CBD_RICM_LTE-IQ_FU:3:C
%%  CBD_RICM_LTE-IQ_FU:4:C
%%  CBD_RICM_LTE-IQ_FU:7:E
%%
%% $External References
%%  -
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%% $Precondition
%%  CPRI links is started according to configuration
%%
%%  No carrier setup
%%
%% $Action_1
%%  Setup max carriers with fix 20MHZ bandwith (noofsample = 8) according to configuration
%%
%%  See Appendix for max carrier setup
%%
%% $Result_1
%%  Carriers setup successfully
%%  Check that the following registers are setup
%%  For DUL-20
%%  * Common Configuration register in XIO_I block (addr: 0x3f2)
%%  * Egress link configuration registers for UL (addr: 0x4c0-0x4c8) and DL (addr: 0x440-0x454) in IQ_X block
%%  * Ingress link configuration registers for UL (addr: 0x480-0x494) and DL (addr: 0x400-0x408) in IQ_X block
%%  * Configuration word in control memory for UL (addr: 0x600-0x5e) and DL (addr: 0x540-0x5fe) in IQ_X block
%%  For DUS-41 (DUXI)
%%  * Egress link configuration registers for UL (addr: 0x68c0-0x6910) and DL (addr: 0x6800-0x68af) in IQ_X block
%%  * Ingress link configuration registers for UL (addr: 0x6050-0x610f) and DL (addr: 0x6000-0x606f) in IQ_X block
%%  * Configuration word in control memory for UL (addr: 0x7600-0x7880) and DL (addr: 0x7000-0x75ff) in IQ_X block
%%
%% $Action_2
%%  Send a CARRIER_SETUP_REQ with parameters:
%%
%%  ruId = ruid which have maxed cpri link, carrierId = carrierId which is free, direction = UL
%%
%% $Result_2
%%  A CARRIER_SETUP_REJ is received with parameters:
%%
%%  carrierId = Corresponding ruId
%%
%%  errorCode = ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL
%%
%%  carrierErrorCode = RICM_CARRIER_RESOURCE_SHORTAGE_CPRI
%%
%% $Action_3
%%  Send a CARRIER_SETUP_REQ with parameters:
%%
%%  ruId = ruid which have maxed cpri link, carrierId = carrierId which is free, direction = DL
%%
%% $Result_3
%%  A CARRIER_SETUP_REJ is received with parameters:
%%
%%  carrierId = Corresponding ruId
%%
%%  errorCode = ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL
%%
%%  carrierErrorCode = RICM_CARRIER_RESOURCE_SHORTAGE_CPRI
%%
%% $Action_4
%%  Release all carriers
%%
%% $Result_4
%%  Carriers released successfully
%%
%% $Action_5
%%  Release cpri links
%%
%% $Result_5
%%  Cpri links released successfully
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2013-08-28, EYANWZH
%%    First version
%%
%%------------------------------------------------------------------------------
dci_cs8_20mhz() ->
	[{userdata,[{wp, ""},
				{requirement, "CBD_RICM_DCI-IQ_FU:1:C, CBD_RICM_LTE-IQ_FU:3:C, CBD_RICM_LTE-IQ_FU:4:C, CBD_RICM_LTE-IQ_FU:7:E"},
				{slogan, "Max Allocation with 20MHz BW"},
				{hwConfig, hwConfigA}]}].

dci_cs8_20mhz(_Config) ->
	dci_cs8("dci_cs8_20mhz",[{slotlist,[8]}]).

%%##############################################################################
%% $ChapterH2 Get Capabilities
%%
%%
%% $End
%%##############################################################################

%%------------------------------------------------------------------------------
%% $Id DCI_GC1
%%
%% $Header
%%  DCI Get Capabilities - State Starting
%%
%% $Description
%%  Verify DCI get capabilities in state starting.
%%
%% $Requirements
%%  CBD_RICM_DCI_CAPABILITY_FU:1:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  The DU BC is in state starting.
%%  DP LMC is loaded.
%%  Subscribe DCI faults.
%%
%% $Action_1
%%  Send a GET_CAPABILITIES_REQ.
%%
%% $Result_1
%%  A GET_CAPABILITIES_CFM is received.
%%  It has two capabilities of type CARDINALITY and with the following parameter values:
%%  * cardinality.numberOfDevices = 6
%%  DUL20:
%%    * delays.clkDelayTrpBB = <read from GIC register sync_xio_delay in XIO_I block>
%%    * delays.procDelayDl = <read from GIC register xio_cpri_delay in XIO_I block>
%%  DUS41 & mRBS:
%%    * delays.clkDelayTrpBB = 0
%%    * delays.procDelayDl = <read from DUXI register ccr_xio_time_adv_comp in CCR block>
%%
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-05-30, QMAGSED
%%    First version
%%  2013-08-08, ebacemi
%%    Revised the test case
%%
%%------------------------------------------------------------------------------
dci_gc1() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_RICM_DCI_CAPABILITY_FU:1:C"},
				{slogan, "DCI Get Capabilities - State Starting"}]}].

dci_gc1(_Config) ->
		dci_gc("dci_gc1", starting_lmc_loaded ).

dci_gc( Name, State) ->
	ct:pal(Name),

	% Set state, make audit, establish BCI and DCI connections, subscribe faults
	set_state_and_connect( State ),

	ok = nci_dci_actions:subscribe_faults([]),

	case Name of
		"dci_gc3" -> 
			nci_bci_states:set_state([{state, disabled}]),

			ct:pal("Action_1"),
			ok = nci_dci_actions:get_capabilities([{expectedSigNo, ?RICM_GET_CAPABILITIES_REJ},
												   {errorCode, ?ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL},
												   {errorDescription, {regexp, "Invalid O&M state*"}}]);
		"dci_gc4" -> 
			ct:pal("Action_1"),
			ok = nci_dci_actions:get_capabilities([{expectedSigNo, ?RICM_GET_CAPABILITIES_REJ},
												   {errorCode, ?ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL},
												   {errorDescription, {regexp, "DP not loaded*"}}]);
		_ ->
			Board = nci_common_utils:get_du(),
			case Board of
				dul ->
					XIO_I_SYNC_XIO_DELAY_Address = 16#200 + 16#1f4,
					XIO_I_XIO_CPRI_DELAY_Address = 16#200 + 16#1f8,
					
					XIO_I_SYNC_XIO_DELAY_Value = nci_common_utils:rdfpga(XIO_I_SYNC_XIO_DELAY_Address),
					XIO_I_XIO_CPRI_DELAY_Value = nci_common_utils:rdfpga(XIO_I_XIO_CPRI_DELAY_Address),
					
					%% See document Users Reference for the GIC_XIO_I_R2 block, GIC 155 18-CAH 109 1359/4
					%% for information about these registers
					ProcDelayDl = trunc((XIO_I_XIO_CPRI_DELAY_Value * 100000) / 24576),
					ClkDelayTrpBB = trunc((XIO_I_SYNC_XIO_DELAY_Value * 10000) / 24576);
				Board when (Board == dus) or (Board == mRBS_lte) ->
					CCR_XIO_TIME_ADV_COMP_Address = 16#2000 + 16#44,
					
					CCR_XIO_TIME_ADV_COMP_Value = nci_common_utils:rdfpga(CCR_XIO_TIME_ADV_COMP_Address),
										
					%% See document Users Reference for CCR, DUXI (S41 board) 155 18-CAH 109 1956/2
					%% for information about these registers
					ProcDelayDl = trunc((CCR_XIO_TIME_ADV_COMP_Value + 500) / 1000),
					ClkDelayTrpBB = 0;
				_ ->
					ProcDelayDl = 0,
					ClkDelayTrpBB = 0,
					
					ct:fail("Unknown board ~p", [Board])
			end,
			
			RicmCapCardinalityS = #'RicmCapCardinalityS'{numberOfDevices = 6},
			RicmCapDelaysS = #'RicmCapDelaysS'{clkDelayTrpBB = ClkDelayTrpBB,
											   procDelayDl = ProcDelayDl},
			
			RicmCapCapabilityS1 = #'RicmCapCapabilityS'{capabilityIdentity = 1,
														capabilityLength = '_',
														capability = RicmCapCardinalityS},
			RicmCapCapabilityS2 = #'RicmCapCapabilityS'{capabilityIdentity = 2,
														capabilityLength = '_',
														capability = RicmCapDelaysS},
			
			Capabilities = [RicmCapCapabilityS1,RicmCapCapabilityS2],

			ct:pal("Action_1"),
			ok = nci_dci_actions:get_capabilities([{numberOfCapabilities, 2},
												   {capabilities, Capabilities}])
	end,

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id DCI_GC2
%%
%% $Header
%%  DCI Get Capabilities - State Operational
%%
%% $Description
%%  Verify DCI get capabilities in state operational
%%
%% $Requirements
%%  CBD_RICM_DCI_CAPABILITY_FU:1:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state operational
%%  DP LMC is loaded.
%%  Subscribe DCI faults.
%%
%% $Action_1
%%  Send a GET_CAPABILITIES_REQ.
%%
%% $Result_1
%%  A GET_CAPABILITIES_CFM is received.
%%  It has two capabilities of type CARDINALITY and with the following parameter values:
%%  * cardinality.numberOfDevices = 6
%%  DUL20:
%%    * delays.clkDelayTrpBB = <read from GIC register sync_xio_delay in XIO_I block>
%%    * delays.procDelayDl = <read from GIC register xio_cpri_delay in XIO_I block>
%%  DUS41 & mRBS:
%%    * delays.clkDelayTrpBB = 0
%%    * delays.procDelayDl = <read from DUXI register ccr_xio_time_adv_comp in CCR block>
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-10-01, EEDAJA
%%    First version
%%  2013-08-08, ebacemi
%%    Revised the test case
%%
%%------------------------------------------------------------------------------
dci_gc2() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_RICM_DCI_CAPABILITY_FU:1:C"},
				{slogan, "DCI Get Capabilities - State Operational"}]}].

dci_gc2(_Config) ->
		dci_gc("dci_gc2", operational).

%%------------------------------------------------------------------------------
%% $Id DCI_GC3
%%
%% $Header
%%  DCI Get Capabilities - State Disabled
%%
%% $Description
%%  Verify DCI get capabilities in state disabled.
%%
%% $Requirements
%%  CBD_RICM_DCI_CAPABILITY_FU:1:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state disabled
%%  DP LMC is loaded.
%%  Subscribe DCI faults.
%%
%% $Action_1
%%  Send a GET_CAPABILITIES_REQ.
%%
%% $Result_1
%%  A GET_CAPABILITIES_REJ is received with the following parameters:
%%  * errorCode = UNSUCCESSFUL
%%  * errorDescription = "Invalid O&M state"
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-10-01, EEDAJA
%%    First version
%%  2013-08-08, ebacemi
%%    Revised the test case
%%
%%------------------------------------------------------------------------------
dci_gc3() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_RICM_DCI_CAPABILITY_FU:1:C"},
				{slogan, "DCI Get Capabilities - State Disabled"}]}].

dci_gc3(_Config) ->
		dci_gc("dci_gc3", starting_lmc_loaded). %% State is changed later on to disabled, to guarantee correct error code

%%------------------------------------------------------------------------------
%% $Id DCI_GC4
%%
%% $Header
%%  DCI Get Capabilities - DP not Loaded
%%
%% $Description
%%  Verify DCI get capabilities when the LMC is not loaded.
%%
%% $Requirements
%%  CBD_RICM_DCI_CAPABILITY_FU:1:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state starting.
%%  The LMC is not loaded.
%%  Subscribe DCI faults.
%%
%% $Action_1
%%  Send a GET_CAPABILITIES_REQ.
%%
%% $Result_1
%%  A GET_CAPABILITIES_REJ is received with the following parameters:
%%  * errorCode = UNSUCCESSFUL
%%  * errorDescription = "DP not loaded"
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-10-01, EEDAJA
%%    First version
%%  2013-08-08, ebacemi
%%    Revised the test case
%%
%%------------------------------------------------------------------------------
dci_gc4() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_RICM_DCI_CAPABILITY_FU:1:C"},
				{slogan, "DCI Get Capabilities - DP not loaded"}]}].

dci_gc4(_Config) ->
		dci_gc("dci_gc4", starting_lmc_not_loaded ).

%%##############################################################################
%% $ChapterH2 Reset CPRI Link
%%
%%
%% $End
%%##############################################################################

%%------------------------------------------------------------------------------
%% $Id DCI_RCL1
%%
%% $Header
%%  State Starting
%%
%% $Description
%%  Verify reset CPRI link in state starting.
%%
%% $Requirements
%%  CBD_RICM_DCI-RESET-CPRI-LINK_FU:1:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  The DU BC is in state starting.
%%
%%  CPRI Link is up for ruId 1, port 1 and cascade 1
%%
%% $Action
%%  Send a RESET_CPRI_LINK_REQ with parameters:
%%
%%  ruId = 1
%%
%% $Result
%%  A RESET_CPRI_LINK_CFM is received with parameters:
%%
%%  ruId = 1
%% 
%% $Result
%%  A RESET_CPRI_LINK_IND is received with parameters:
%%
%%  ruId = 1
%%  
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-05-30, QMAGSED
%%    First version
%%
%%  2012-12-17, EEDAJA
%%    The common subroutine dci_rcl removed, and ruId is read from the configuration
%%
%%------------------------------------------------------------------------------
dci_rcl1() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_RICM_DCI-RESET-CPRI-LINK_FU:1:C"},
				{slogan, "State Starting"},
				{hwConfig, hwConfigA}]}].

dci_rcl1(_Config) ->
	ct:pal("dci_rcl1"),

	% Set state, make audit, establish BCI and DCI connections, subscribe faults
	set_state_and_connect( starting_lmc_loaded ),

	%% Subscribe Faults DCI
	ok = nci_dci_actions:subscribe_faults([]),

	Radio1 = nci_ricm_utils:get_first_radio(),

	ok = nci_dci_actions:start_cpri_link(Radio1),

	ok = nci_dci_actions:cpri_link_ind(Radio1 ++ [{availStatus, 1}]),
	%% Reset CPRI Link
	ok = nci_dci_actions:reset_cpri_link(Radio1),

	ok = nci_dci_actions:reset_cpri_link_ind(Radio1),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id DCI_RCL2
%%
%% $Header
%%  State Operational
%%
%% $Description
%%  Verify reset CPRI link in state operational.
%%
%% $Requirements
%%  CBD_RICM_DCI-RESET-CPRI-LINK_FU:1:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state operational.
%%
%%  CPRI Link is up for ruId 1, port 1 and cascade 1
%%
%% $Action
%%  Send a RESET_CPRI_LINK_REQ with parameters:
%%
%%  ruId = 1
%%
%% $Result
%%  A RESET_CPRI_LINK_CFM is received with parameters:
%%
%%  ruId = 1
%% 
%% $Result
%%  A RESET_CPRI_LINK_IND is received with parameters:
%%
%%  ruId = 1
%%  
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-10-01, EEDAJA
%%    First version
%%
%%  2012-12-17, EEDAJA
%%    The common subroutine dci_rcl removed, and ruId is read from the configuration
%%
%%------------------------------------------------------------------------------
dci_rcl2() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_RICM_DCI-RESET-CPRI-LINK_FU:1:C"},
				{slogan, "State Operational"},
				{hwConfig, hwConfigA}]}].

dci_rcl2(_Config) ->
	ct:pal("dci_rcl2"),

	% Set state, make audit, establish BCI and DCI connections, subscribe faults
	set_state_and_connect( operational ),

	%% Subscribe Faults DCI
	ok = nci_dci_actions:subscribe_faults([]),

	Radio1 = nci_ricm_utils:get_first_radio(),

	ok = nci_dci_actions:start_cpri_link(Radio1),

	ok = nci_dci_actions:cpri_link_ind(Radio1 ++ [{availStatus, 1}]),
	%% Reset CPRI Link
	ok = nci_dci_actions:reset_cpri_link(Radio1),

	ok = nci_dci_actions:reset_cpri_link_ind(Radio1),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id DCI_RCL3
%%
%% $Header
%%  State Disabled
%%
%% $Description
%%  Verify reset CPRI link in state disabled.
%%
%% $Requirements
%%  CBD_RICM_DCI-RESET-CPRI-LINK_FU:1:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state disabled.
%%
%%  CPRI Link is up for ruId 1, port 1 and cascade 1
%%
%% $Action
%%  Send a RESET_CPRI_LINK_REQ with parameters:
%%
%%  ruId = 1
%%
%% $Result
%%  A RESET_CPRI_LINK_REJ is received with parameters:
%%
%%  ruId = 1
%%
%%  errorCode = UNSUCCESSFUL
%%
%%  errorDescription = "Invalid O&M state"
%%  
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-10-25, EEDAJA
%%    First version
%%
%%  2012-12-17, EEDAJA
%%    The common subroutine dci_rcl removed, and ruId is read from the configuration
%%
%%------------------------------------------------------------------------------
dci_rcl3() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_RICM_DCI-RESET-CPRI-LINK_FU:1:C"},
				{slogan, "State disabled"},
				{hwConfig, hwConfigA}]}].

dci_rcl3(_Config) ->
	ct:pal("dci_rcl1"),

	% Set state, make audit, establish BCI and DCI connections, subscribe faults
	set_state_and_connect( operational ),  %% State is changed later to disabled

	%% Subscribe Faults DCI
	ok = nci_dci_actions:subscribe_faults([]),

	Radio1 = nci_ricm_utils:get_first_radio(),

	ok = nci_dci_actions:start_cpri_link(Radio1),

	ok = nci_dci_actions:cpri_link_ind(Radio1 ++ [{typeOfUnit, '_'},{availStatus, 1}]),
	nci_bci_states:set_state([{state, disabled}]),

	%% Reset CPRI Link
	ok = nci_dci_actions:reset_cpri_link(Radio1 ++ [
										{expectedSigNo, ?RICM_RESET_CPRI_LINK_REJ},
										{errorCode, 1},
										{errorDescription, {regexp, "Invalid O&M state*"}}]),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000),

	LogString = string:concat("Test case ", string:to_upper("dci_rcl3")),
	nci_bci_states:restart_board( LogString ).

%%------------------------------------------------------------------------------
%% $Id DCI_RCL4
%%
%% $Header
%%  Unused Address
%%
%% $Description
%%  Verify reset CPRI link for an unused address
%%
%% $Requirements
%%  CBD_RICM_DCI-RESET-CPRI-LINK_FU:1:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state starting.
%%
%%  CPRI Link is up for ruId 1
%%
%%  CPRI Link is down for ruId 2
%%
%% $Action
%%  Send a RESET_CPRI_LINK_REQ with parameters:
%%
%%  ruId = 2
%%
%% $Result
%%  A RESET_CPRI_LINK_REJ is received with parameters:
%%
%%  ruId = 2
%%
%%  errorCode = UNSUCCESSFUL
%%
%%  errorDescription = "ruId not in use"
%%  
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-12-04, EEDAJA
%%    First version
%%
%%  2012-12-17, EEDAJA
%%    The common subroutine dci_rcl removed, and ruId is read from the configuration
%%
%%------------------------------------------------------------------------------
dci_rcl4() ->
	[{userdata,[{wp, ""},  
				{requirement, "CBD_RICM_DCI-RESET-CPRI-LINK_FU:1:C"},
				{slogan, "Unused ruId"},
				{hwConfig, hwConfigA}]}].

dci_rcl4(_Config) ->
	ct:pal("dci_rcl4"),

	% Set state, make audit, establish BCI and DCI connections, subscribe faults
	set_state_and_connect( starting_lmc_loaded ),

	%% Subscribe Faults DCI
	ok = nci_dci_actions:subscribe_faults([]),

	Radio1 = nci_ricm_utils:get_first_radio(),

	ok = nci_dci_actions:start_cpri_link(Radio1),

	ok = nci_dci_actions:cpri_link_ind(Radio1 ++ [
										{typeOfUnit, '_'},
										{availStatus, 1}]),
	%% Reset CPRI Link with invalid ruId
	ok = nci_dci_actions:reset_cpri_link([{ruId, 99},
										{expectedSigNo, ?RICM_RESET_CPRI_LINK_REJ},
										{errorCode, 1},
										{errorDescription, {regexp, "ruId not in use*"}}]),
	%% Reset CPRI Link
	ok = nci_dci_actions:reset_cpri_link(Radio1),

	ok = nci_dci_actions:reset_cpri_link_ind(Radio1),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id DCI_RCL6
%%
%% $Header
%%  DP not loaded
%%
%% $Description
%%  Verify reset CPRI link , DP not loaded
%%
%% $Requirements
%%  CBD_RICM_DCI-RESET-CPRI-LINK_FU:1:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state starting.
%%
%%  The LMC is not loaded.
%%
%%  CPRI Link is up for ruId 1
%%
%%  CPRI Link is down for ruId 2
%%
%% $Action
%%  Send a RESET_CPRI_LINK_REQ with parameters:
%%
%%  ruId = 2
%%
%% $Result
%%  A RESET_CPRI_LINK_REJ is received with parameters:
%%
%%  ruId = 2
%%
%%  errorCode = UNSUCCESSFUL
%%
%%  errorDescription = "DP not loaded"
%%  
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-10-04, EEDAJA
%%    First version
%%
%%  2012-12-17, EEDAJA
%%    The common subroutine dci_rcl removed, and ruId is read from the configuration
%%
%%------------------------------------------------------------------------------
dci_rcl6() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_RICM_DCI-RESET-CPRI-LINK_FU:1:C"},
				{slogan, "DP not loaded"},
				{hwConfig, hwConfigA}]}].

dci_rcl6(_Config) ->
	ct:pal("dci_rcl6"),

	% Set state, make audit, establish BCI and DCI connections, subscribe faults
	set_state_and_connect( starting_lmc_not_loaded ),

	%% Subscribe Faults DCI
	ok = nci_dci_actions:subscribe_faults([]),

	Radio1 = nci_ricm_utils:get_first_radio(),

	ok = nci_dci_actions:start_cpri_link(Radio1 ++ [
										{expectedSigNo, ?RICM_START_CPRI_LINK_REJ},
										{errorCode, 1},
										{errorDescription, {regexp, "DP not loaded*"}}]),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id DCI_RCL7
%%
%% $Header
%%  ruId out of range and max value
%%
%% $Description
%%  Reset CPRI Link, Invalid ruId. Suported range is 1-65535
%%
%% $Requirements
%%  CBD_RICM_DCI-RESET-CPRI-LINK_FU:1:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state starting.
%%
%%  CPRI Link is up for ruId 65535
%%
%% $Action
%%  Send a RESET_CPRI_LINK_REQ with parameters:
%%
%%  ruId = 0
%%
%% $Result
%%  A RESET_CPRI_LINK_REJ is received with parameters:
%%
%%  ruId = 0
%%
%%  errorCode = UNSUCCESSFUL
%%
%%  errorDescription = "Invalid ruId"
%% 
%% $Action
%%  Send a RESET_CPRI_LINK_REQ with parameters:
%%
%%  ruId = 65535
%%
%% $Result
%%  A RESET_CPRI_LINK_CFM is received with parameters:
%%
%%  ruId = 65535
%%  
%% $Result
%%  A RESET_CPRI_LINK_IND is received with parameters:
%%
%%  ruId = 65535
%%  
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-12-04, EEDAJA
%%    First version
%%
%%  2012-12-17, EEDAJA
%%    The common subroutine dci_rcl removed
%%
%%------------------------------------------------------------------------------
dci_rcl7() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_RICM_DCI-RESET-CPRI-LINK_FU:1:C"},
				{slogan, "ruId out of range and max value"},
				{hwConfig, hwConfigA}]}].

dci_rcl7(_Config) ->
	ct:pal("dci_rcl7"),

	% Set state, make audit, establish BCI and DCI connections, subscribe faults
	set_state_and_connect( starting_lmc_loaded ),

	%% Subscribe Faults DCI
	ok = nci_dci_actions:subscribe_faults([]),

	Radio1 = nci_ricm_utils:get_first_radio(),

	RuId = proplists:get_value(ruId,Radio1),
	Radio1new = (Radio1 -- [{ruId,RuId}]) ++ [{ruId, 16#ffff}],

	ok = nci_dci_actions:start_cpri_link(Radio1new),

	ok = nci_dci_actions:cpri_link_ind(Radio1new ++ [
										{typeOfUnit, '_'},
										{availStatus, 1}]),
	%% Reset CPRI Link with invalid ruId
	Radio1new2 = (Radio1 -- [{ruId,RuId}]) ++ [{ruId, 0}],
	ok = nci_dci_actions:reset_cpri_link(Radio1new2 ++ [
										{expectedSigNo, ?RICM_RESET_CPRI_LINK_REJ},
										{errorCode, 1},
										{errorDescription, {regexp, "Invalid ruId*"}}]),
	%% Reset CPRI Link
	ok = nci_dci_actions:reset_cpri_link(Radio1new),

	ok = nci_dci_actions:reset_cpri_link_ind(Radio1new),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id DCI_RCL9
%%
%% $Header
%%  Check tranceiver
%%
%% $Description
%%  Reset CPRI Link, Turn off tranceiver
%%
%% $Requirements
%%  CBD_RICM_DCI-RESET-CPRI-LINK_FU:1:C
%%
%% $External References
%%  -
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state starting.
%%  CPRI Link is up for ruId 1
%%
%% $Action 1
%%  In DUL, check tranceiver settings with shellcommand "rdfpga $reg" where $reg = 0x1c00 + (0x40 * (portNo - 1)) + 0x016
%%  In DUS, check tranceiver settings with shellcommand "rdfpga $reg" where $reg = 0x4000 + ((portNo-1) * 0x100) + 0x3C
%%
%% $Result 1
%%  The value of DUL is "66bf"
%%  The value of DUS regsiter bit 12 should be "1"
%%
%% $Action 2
%%  Send a RESET_CPRI_LINK_REQ signal
%%
%% $Result 2
%%  A RESET_CPRI_LINK_CFM signal is received.
%%
%% $Result 2
%%  A RESET_CPRI_LINK_IND signal is received.
%%
%% $Action 3
%%  In DUL, Check tranceiver settings with shellcommand "rdfpga $reg" where $reg = 0x1c00 + (0x40 * (portNo - 1)) + 0x016
%%  In DUS, Check tranceiver settings with shellcommand "rdfpga $reg" where $reg = 0x4000 + ((portNo-1) * 0x100) + 0x3c
%%
%% $Result 3
%%  The value of DUL is "641f"
%%  The value of DUS register bit 12 should be "0"
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-12-26, EGUOREN
%%    First version
%%
%%------------------------------------------------------------------------------
dci_rcl9() ->
	[{userdata,[{wp, ""},
				{requirement, "CBD_RICM_DCI-RESET-CPRI-LINK_FU:1:C"},
				{slogan, "Turn off tranceiver"},
				{hwConfig, hwConfigA}]}].

dci_rcl9(_Config) ->
	ct:pal("dci_rcl9"),

	%%Set state, make audit, establish BCI and DCI connections, subscribe faults
	set_state_and_connect( starting_lmc_loaded ),

	%% Subscribe Faults DCI
	ok = nci_dci_actions:subscribe_faults([]),

	Radio1 = nci_ricm_utils:get_first_radio(),
	PortNo = proplists:get_value(portNo, Radio1),

	%% Ricm start cpri link for ruId 1
	ok = nci_dci_actions:start_cpri_link(Radio1),

	ok = nci_dci_actions:cpri_link_ind(Radio1),

	case nci_common_utils:get_du() of
		dul->

			%% Check tranceiver setting by read FPGA register before reset cpri
			ct:pal("Action1 for dul"),
			FpgaReg = 16#1c00 + (16#40 * (PortNo - 1)) + 16#016,

			FpgaVal_before = nci_common_utils:rdfpga(FpgaReg),

			FpgaVal_before = 16#66bf,

			%% Reset cpri link for ruId 1
			ct:pal("Action2 for dul"),
			ok = nci_dci_actions:reset_cpri_link(Radio1),

			ok = nci_dci_actions:reset_cpri_link_ind(Radio1),

			%% Check tranceiver setting by read FPGA register after reset cpri link
			ct:pal("Action3 for dul"),
			FpgaVal_after = nci_common_utils:rdfpga(FpgaReg),

			FpgaVal_after = 16#64bf;
		dus->

			%% Check tranceiver setting by read FPGA register before reset cpri
			ct:pal("Action1 for dus"),

			FpgaReg = 16#4000 + ((PortNo - 1) * 16#100) + 16#3c,
			FpgaVal_before = nci_common_utils:rdfpga(FpgaReg),

			Tranceiver_before = (FpgaVal_before band 16#80000),
			1 = Tranceiver_before bsr 19,

			%% Reset cpri link for ruId 1
			ct:pal("Action2 for dus"),
			ok = nci_dci_actions:reset_cpri_link(Radio1),

			ok = nci_dci_actions:reset_cpri_link_ind(Radio1),

			%% Check tranceiver setting by read FPGA register after reset cpri link
			ct:pal("Action3 for dus"),
			FpgaVal_after = nci_common_utils:rdfpga(FpgaReg),

			Tranceiver_after = (FpgaVal_after band 16#80000),

			0 = Tranceiver_after bsr 19

	end,

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id DCI_CSMAX_RCL_CSMAX
%%
%% $Header
%%  Max Allocation
%%
%% $Description
%%  Carrier Setup, Max Allocation - reset CPRI link - start CPRI link again and set up Max Allocation again.
%%
%% $Requirements
%%  CBD_RICM_DCI-RESET-CPRI-LINK_FU:1:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  CPRI links is started according to configuration
%%
%%  No carrier setup
%%
%% $Action_1
%%  Setup max carriers according to configuration
%%
%%  See Appendix for max carrier setup
%%
%% $Result_1
%%  Carriers setup successfully
%%  Check that the following registers are setup
%%  For DUL-20
%%  * Common Configuration register in XIO_I block (addr: 0x3f2)
%%  * Egress link configuration registers for UL (addr: 0x4c0-0x4c8) and DL (addr: 0x440-0x454) in IQ_X block
%%  * Ingress link configuration registers for UL (addr: 0x480-0x494) and DL (addr: 0x400-0x408) in IQ_X block
%%  * Configuration word in control memory for UL (addr: 0x600-0x5e) and DL (addr: 0x540-0x5fe) in IQ_X block
%%  For DUS-41 (DUXI)
%%  * Egress link configuration registers for UL (addr: 0x68c0-0x6910) and DL (addr: 0x6800-0x68af) in IQ_X block
%%  * Ingress link configuration registers for UL (addr: 0x6050-0x610f) and DL (addr: 0x6000-0x606f) in IQ_X block
%%  * Configuration word in control memory for UL (addr: 0x7600-0x7880) and DL (addr: 0x7000-0x75ff) in IQ_X block
%%
%% $Action_2
%%  Send a RESET_CPRI_LINK_REQ with parameters according to configuration
%%
%% $Result_2
%%  A RESET_CPRI_LINK_CFM is received with parameters according to configuration
%%  A RESET_CPRI_LINK_IND is received with parameters according to configuration
%%
%% $Action_3
%%  Send a START_CPRI_LINK_REQ with parameters according to configuration
%%
%% $Result_3
%%  A START_CPRI_LINK_CFM is received
%%  A START_CPRI_LINK_IND is received with parameters:
%%  availStatus = 1
%%
%% $Action_4
%%  Repeat Action_1
%%
%% $Result_4
%%  Same as in Result_1
%%
%% $Action_5
%%  Release all carriers
%%
%% $Result_5
%%  Carriers released successfully
%%
%% $Action_6
%%  Release cpri links
%%
%% $Result_6
%%  Cpri links released successfully
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2013-08-27, EYANWZH
%%    First version
%%  2013-10-30, ehuayya
%%    corrected usage of ruPortNo for nci_rici_actions:get_current_port
%%
%%------------------------------------------------------------------------------
dci_csmax_rcl_csmax() ->
	[{userdata,[{wp, ""},
				{requirement, "CBD_RICM_DCI-RESET-CPRI-LINK_FU:1:C"},
				{slogan, "Carrier Setup, Max Allocation - reset CPRI link - start CPRI link again and set up Max Allocation again"},
				{hwConfig, hwConfigA}]}].

dci_csmax_rcl_csmax(_Config) ->
	dci_csmax_rcl_csmax("dci_csmax_rcl_csmax",[{}]).

dci_csmax_rcl_csmax(Name,Parameters) ->
	ct:pal(Name),

	Band = proplists:get_value(bandtype,Parameters,subband),

	{Radios,DcServer,MaxCarriers,_,_} = max_allocation_pre(Parameters),

	case Band of
		fullband ->
			IsSubBand = ?ELIB_CONST_HWU_NO;
		_->
			IsSubBand = ?ELIB_CONST_HWU_YES
	end,

	ct:pal("Action_1"),
	lists:foreach(fun({_CarrierSetupItemName,CarrierSetupItem}) ->
		ok = nci_dci_actions:carrier_setup3(CarrierSetupItem ++ [{dcServer,DcServer},{isSubBand,IsSubBand}])
	end,
	MaxCarriers),

	ct:pal("Action_2"),
	reset_all_cpri_links(Radios),

	ct:pal("Action_3"),
	%% Start CPRI
	lists:foreach(fun(Radio) ->
		%% Start CPRI
		ok = nci_dci_actions:start_cpri_link(Radio ++ [{dcServer,DcServer}]),
		ok = nci_dci_actions:cpri_link_ind(Radio ++ [{dcServer,DcServer}]),

		%% Add Radio Control
		nci_dci_actions:add_radio_control(Radio ++ [{expectedSigNo, ?RICM_ADD_RADIO_CTL_CFM}]),
		nci_dci_actions:radio_control_ind(Radio ++ [{connStatus, 1},{radioSoftware, application}])

	end,
	Radios),

	ct:pal("Action_4"),
	lists:foreach(fun({_CarrierSetupItemName,CarrierSetupItem}) ->
		ok = nci_dci_actions:carrier_setup3(CarrierSetupItem ++ [{dcServer,DcServer},{isSubBand,IsSubBand}])
	end,
	MaxCarriers),

	ct:pal("Action_5"),
	lists:foreach(fun({_CarrierSetupItemName,CarrierSetupItem}) ->
		ok = nci_dci_actions:carrier_release(CarrierSetupItem ++ [{dcServer,DcServer}])
	end,
	MaxCarriers),

	ct:pal("Action_6"),
	reset_all_cpri_links(Radios),

	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id DCI_CSMAX_RESET_RC_CSMAX
%%
%% $Header
%%  Reset and CPRI link, Max allocation
%%
%% $Description
%%  Carrier Setup, Max Allocation - reset CPRI link - start CPRI link again and set up Max Allocation again, first on port 4-6, then port 1-3.
%%
%% $Requirements
%%  CBD_RICM_DCI-RESET-RADIO-CONTROL-LINK_FU:1:H
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  CPRI Link is up.
%%
%%  Radio control is up.
%%
%% $Action
%%  Reset CPRI link
%%
%% $Result
%%  -
%% 
%% $Action
%%  Start CPRI link
%%
%% $Result
%%  -
%%
%% $Action
%%  Setup Max allocation
%%
%% $Result
%%  -
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%    First version
%%
%%------------------------------------------------------------------------------


%%##############################################################################
%% $ChapterH2 Get Delay
%%
%%
%% $End
%%##############################################################################
%%------------------------------------------------------------------------------
%% $Id DCI_DELAY_1
%%
%% $Header
%%  Get LINK_DELAY_DL: State - Starting.
%%
%% $Description
%% Verify that RICM calculates LINK_DELAY_DL correctly in state Starting.
%%
%% $Requirements
%%  CBD_RICM_DCI_DELAY-VALUE_CA:1:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  At least 1 RU
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  The DU BC is in state starting.
%%  CPRI, O&M link is set up.
%%  Subscribe BCI&DCI fault.
%%
%% $Action_1
%%  Send a RICM_GET_DELAY_REQ with parameters:
%%  ruId = <1...last connected radio>
%%
%% $Result_1
%%  A GET_DELAY_CFM is received with parameters:
%%  ruId = <1...last connected radio>
%%  linkDelayDl = <a value>
%%
%% $Action_2
%%  Check that linkDelayDl value is reasonable
%%
%% $Result_2
%%  linkDelayDl in nano seconds should be within the limits: (radios total cableLength * 5) + radios CascadeDelayDL + - 10 for DUL20
%%  and DuinternalDelay + (radios total cableLength * 5) + radios CascadeDelayDL + - 40 for DUS41
%%      DuinternalDelay is euqal to (Delay_ri_tx_f/1000) + Delay_ri_tx_v/8
%%
%% $Action_3
%% Repeat Action_1 to Action_2 for all radios
%%
%% $Result_3
%% Same as Result_1 to Result_2
%% 
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  2013-01-15, EJONUNA
%%
%% Revision history:
%%  2012-12-19, EYANWZH
%%    First version
%%  2013-01-16, EYANWZH
%%    Update for review comments:Add function delay_pre,get_delay,restructure the test case to use such function 
%%  2013-08-21, ejonuna
%%    Improved test case to support radios with different types of cascadedDelayDL values and for each radio to have different cable lengths
%%  2013-10-17, ehuayya
%%    Use common function to get link_delay_dl
%%------------------------------------------------------------------------------
dci_delay_1() ->
	[{userdata,[{wp, ""},
				{requirement, "CBD_RICM_DCI_DELAY-VALUE_CA:1:C"},
				{slogan, "Get LINK_DELAY_DL: State - Starting."},
				{hwConfig, hwConfigA}]}].

dci_delay_1(_Config) ->

	ct:pal("dci_delay_1"),

	dci_delay_main(starting_lmc_loaded).

dci_delay_main(State) ->

	%%setup cpril and O&M link.
	Radios = delay_pre(State),

	ct:pal("Action_1,2,3"),
	lists:foreach(fun(Radio) ->
		%%caculate the delay and decide its validy
		get_delay_validity(Radio,Radios,1)

	end,
	Radios),

	%% Reset CPRI Link
	[Radio|_] = Radios,

	ok = nci_dci_actions:reset_cpri_link(Radio),

	ok = nci_dci_actions:reset_cpri_link_ind(Radio),

	%% Check that NO BC/DC_FAULT_IND is generated
	nci_common_utils:check_outstanding_faults(2000).

%%---------------------------------------------------------------------------------
delay_pre(State) ->

	% Set state, make audit, establish BCI and DCI connections, subscribe BCI faults
	set_state_and_connect(State),

	%% Subscribe Faults DCI
	ok = nci_dci_actions:subscribe_faults([]),

	%% Get the cascading radios, or the first radio
	Radios2plus = nci_ricm_utils:get_first_cascaded_radios(),
	if (Radios2plus == []) ->
		Radios = [nci_ricm_utils:get_first_radio()];
	true ->
		Radios = Radios2plus
	end,

	%% Setup cascading cpri and O&M link
	ok = setup_casc_cpri_link(Radios),

	lists:foreach(fun(CurrentRadio) ->
						  ok = nci_rici_actions:conn_establish(CurrentRadio)
				  end,
				  Radios),

	Radios.

%%---------------------------------------------------------------------
get_delay_validity(Radio,AllCascadedRadios,ActionNumberBase) ->

	ct:pal("Action_~p",[ActionNumberBase]),
	%% Get Delay
	{ok, Received} = nci_dci_actions:get_delay_get(Radio),
	{ _, _, _, _, LinkDelay } = Received,

	ct:pal("Action_~p",[ActionNumberBase+1]),

	Expectdelay = nci_ricm_utils:get_link_delay_dl(Radio, AllCascadedRadios),

	case nci_common_utils:get_du() of
		dul ->
			MaxDelay = (Expectdelay+10),
			MinDelay = case Expectdelay > 10 of
						   true ->
							   (Expectdelay-10);
						   _ ->
							   0
					   end;
		dus  ->
			MaxDelay = (Expectdelay+20),
			MinDelay = case Expectdelay > 20 of
						   true ->
							   (Expectdelay-20);
						   _ ->
							   0
					   end;
		mRBS_lte  ->

			%% FIXME: workaround for unstable delay measurements on mRBS. Remove workaround
			%% as soon as problem is fixed. We expect this to be solved in version later than R6D
			RadioApplic = "CYB10173/11 R6D  (RIHI version 0)",

			case nci_ricm_utils:check_correct_ricr(Radio ++ [{radioApplic, RadioApplic}]) of
				ok ->
					%% Workaround value
					DelayDiff = 70;
				nok ->
					%% Original value
					DelayDiff = 20,
					ct:fail("Radio revision exceeding R6D. Remove delay measurement workaround in nci_ft_ricm_dul_SUITE.erl!")
			end,

			MaxDelay = (Expectdelay+DelayDiff),
			MinDelay = case Expectdelay > DelayDiff of
						   true ->
							   (Expectdelay-DelayDiff);
						   _ ->
							   0
					   end;
		_ ->
			MaxDelay = 0,
			MinDelay = 0, 
			ct:fail("Unknown test node type")
	end,
	
	ct:pal("Delay should be within: ~p - ~p~nDelay is: ~p", [MinDelay, MaxDelay, LinkDelay]),

	ct:pal("There is a bug (HS28427) in RICM that will cause the RICM_GET_DELAY_REQ verification to sometimes fail.~n"
		   "This bug will not be fixed since this signal will be replaced with the new time alignment signals.~n"
		   "Therefore the delay verification for RICM_GET_DELAY_REQ has been disabled").

	%% case LinkDelay < MinDelay of
	%% 	true -> ct:fail("Delay is too small");
	%% 	false -> ok
	%% end,

	%% case LinkDelay > MaxDelay of
	%% 	true -> ct:fail("Delay is too large");
	%% 	false -> ok
	%% end.

%%------------------------------------------------------------------------------
%% $Id DCI_DELAY_2
%%
%% $Header
%%  Get LINK_DELAY_DL: State - Operational.
%%
%% $Description
%% Verify that RICM calculates LINK_DELAY_DL correctly in state operational.
%%
%% $Requirements
%%  CBD_RICM_DCI_DELAY-VALUE_CA:1:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  At least 1 RU
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  The DU BC is in state operational.
%%  CPRI, O&M link is set up.
%%  Subscribe BCI&DCI fault.
%%
%% $Action_1
%%  Send a RICM_GET_DELAY_REQ with parameters:
%%  ruId = <1...last connected radio>
%%
%% $Result_1
%%  A GET_DELAY_CFM is received with parameters:
%%  ruId = <1...last connected radio>
%%  linkDelayDl = <a value>
%%
%% $Action_2
%%  Check that linkDelayDl value is reasonable
%%
%% $Result_2
%%  linkDelayDl in nano seconds should be within the limits: (radios total cableLength * 5) + radios CascadeDelayDL + - 10 for DUL20
%%  and DuinternalDelay + (radios total cableLength * 5) + radios CascadeDelayDL + - 40 for DUS41
%%      DuinternalDelay is euqal to (Delay_ri_tx_f/1000) + Delay_ri_tx_v/8
%%
%% $Action_3
%% Repeat Action_1 to Action_2 for all radios
%%
%% $Result_3
%% Same as Result_1 to Result_2
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%% 
%%
%% Revision history:
%% 2013-10-16, ehuayya
%%------------------------------------------------------------------------------
dci_delay_2() ->
	[{userdata,[{wp, ""},
				{requirement, "CBD_RICM_DCI_DELAY-VALUE_CA:1:C"},
				{slogan, "Get LINK_DELAY_DL: State - Operational."},
				{hwConfig, hwConfigA}]}].

dci_delay_2(_Config) ->

	ct:pal("dci_delay_2"),

	dci_delay_main(operational).

%%------------------------------------------------------------------------------
%% $Id DCI_DELAY_3
%%
%% $Header
%%  Get LINK_DELAY_DL: State - Disabled.
%%
%% $Description
%%  Shall not be possible to Get Delay in O&M state disabled.
%%
%% $Requirements
%%  CBD_RICM_DCI_DELAY-VALUE_FU:1:C
%%  CBD_RICM_TIMING-DIST_FU:1:C
%%  CBD_RICM_TIMING-DIST_FU:3:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  The DU BC is in state disabled.
%%  
%% $Action_1
%%  Send a GET_DELAY_REQ with parameters:
%%  ruId = 1
%%
%% $Result_1
%%  A GET_DELAY_REJ is received with parameters:
%%  ruId = 1
%%  errorCode = ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL
%%  errorDescription = "Invalid O&M state"
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%
%% Revision history:
%%  2012-10-04, EEDAJA
%%    First version
%%
%%  2013-07-02, EBACEMI
%%    Removed code that expects RICM_ADD_RADIO_CTL_IND after entering disabled state
%%  2013-10-09, eraasli
%%    Updated to use nci_dci_actions:subscribe_faults([])
%%  2013-10-17, ehuayya
%%    Rename from dci_rd3 to dci_delay_3
%%  2013-11-27, ehuayya
%%    Temporarily added load_lmc, should be removed when Bugzilla #607 is implemented.
%%
%%------------------------------------------------------------------------------
dci_delay_3() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_RICM_DCI_DELAY-VALUE_FU:1:C, CBD_RICM_TIMING-DIST_FU:1:C, CBD_RICM_TIMING-DIST_FU :3:C"},
				{slogan, "Get LINK_DELAY_DL: State - Disabled."}]}].

dci_delay_3(_Config) ->
	ct:pal("dci_delay_3"), 

	%% Temporary workaround
	ok = nci_bci_states:set_state([{state, starting_lmc_loaded}]),
	%% End of workaround
	set_state_and_connect(disabled),

	ct:pal("Action1 & Result1"), 
	nci_dci_actions:get_delay([{expectedSigNo, ?RICM_GET_DELAY_REJ},
													{errorCode, ?ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL},
													{errorDescription, {regexp, "Invalid O&M state*"}}]),

	%% Check that NO BC/DC_FAULT_IND is generated
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id DCI_DELAY_4
%%
%% $Header
%%  Get LINK_DELAY_DL: ruId not in use.
%%
%% $Description
%%  Verify that LINK_DELAY_DL can't be collected for a ruId that is not in use.
%%
%% $Requirements
%%  CBD_RICM_DCI_DELAY-VALUE_FU:1:C
%%  CBD_RICM_TIMING-DIST_FU:1:C
%%  CBD_RICM_TIMING-DIST_FU:3:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state starting.
%%  Subscribe BCI&DCI fault.
%%
%% $Action_1
%%  Send a GET_DELAY_REQ with parameters:
%%  ruId = random interger between 1 and 65535
%%
%% $Result_1
%%  A GET_DELAY_REJ is received with parameters:
%%  ruId = same as in action_1
%%  errorCode = ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL
%%  errorDescription = "ruId not in use"
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%
%% Revision history:
%%  2012-10-04, EEDAJA
%%    First version
%%  2013-10-17, ehuayya
%%    rename from dci_rd4 to dci_delay_4.
%%
%%------------------------------------------------------------------------------
dci_delay_4() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_RICM_DCI_DELAY-VALUE_FU:1:C, CBD_RICM_TIMING-DIST_FU:1:C, CBD_RICM_TIMING-DIST_FU:3:C"},
				{slogan, "Get LINK_DELAY_DL: ruId not in use."}]}].

dci_delay_4(_Config) ->
	ct:pal("dci_delay_4"),

	% Set state, make audit, establish BCI and DCI connections, subscribe faults
	set_state_and_connect( starting_lmc_loaded ),
	%% Subscribe Faults DCI
	ok = nci_dci_actions:subscribe_faults([]),

	RuId = random:uniform(65535),
	ct:pal("Action1 & Result1"),
	%% Get Delay
	nci_dci_actions:get_delay([{expectedSigNo, ?RICM_GET_DELAY_REJ},
				{ruId, RuId},
				{errorCode, ?ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL},
				{errorDescription, {regexp, "ruId not in use*"}}]),

	%% Check that NO BC/DC_FAULT_IND is generated
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id DCI_DELAY_5
%%
%% $Header
%%  Get LINK_DELAY_DL: No Radio Control
%%
%% $Description
%%  Verify that it shall not be possible to get LINK_DELAY_DL when no Radio Control is added.
%%
%% $Requirements
%%  CBD_RICM_DCI_DELAY-VALUE_FU:1:C
%%  CBD_RICM_TIMING-DIST_FU:1:C
%%  CBD_RICM_TIMING-DIST_FU:3:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  At least 1 RU
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state starting.
%%  Subscribe BCI&DCI fault.
%%  CPRI but not O&M link is set up for first radio.
%%
%% $Action_1
%%  Send a GET_DELAY_REQ with parameters:
%%  ruId = ruId for 1st RU <read from config file>
%%
%% $Result_1
%%  A GET_DELAY_REJ is received with parameters:
%%  ruId = ruId for 1st RU <read from config file>
%%  errorCode = ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL
%%  errorDescription = "Delay measurement not started"
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%
%% Revision history:
%%  2012-10-04, EEDAJA
%%    First version
%%  2013-10-17, ehuayya
%%    rename from dci_rd5 to dci_delay_5
%%
%%------------------------------------------------------------------------------
dci_delay_5() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_RICM_DCI_DELAY-VALUE_FU:1:C, CBD_RICM_TIMING-DIST_FU:1:C, CBD_RICM_TIMING-DIST_FU:3:C"},
				{slogan, "Get LINK_DELAY_DL: No Radio Control."},
				{hwConfig, hwConfigA}]}].

dci_delay_5(_Config) ->
	ct:pal("dci_delay_5"),

	% Set state, make audit, establish BCI and DCI connections, subscribe fault
	set_state_and_connect( starting_lmc_loaded ),
	%% Subscribe Faults DCI
	ok = nci_dci_actions:subscribe_faults([]),

	Radio = nci_ricm_utils:get_first_radio(),

	%% Start CPRI
	ok = nci_dci_actions:start_cpri_link(Radio),
	ok = nci_dci_actions:cpri_link_ind(Radio ++ [{typeOfUnit, '_'},{availStatus, 1}]),

	ct:pal("Action1 & Result1"),
	%% Get Delay
	nci_dci_actions:get_delay(Radio ++ [{expectedSigNo, ?RICM_GET_DELAY_REJ},
										{errorCode, ?ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL},
										{errorDescription, {regexp, "Delay measurement not started*"}}]),
	%% Reset CPRI Link
	ok = nci_dci_actions:reset_cpri_link(Radio),
	ok = nci_dci_actions:reset_cpri_link_ind(Radio),

	%% Check that NO BC/DC_FAULT_IND is generated
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id DCI_DELAY_6
%%
%% $Header
%%  Get LINK_DELAY_DL: DP not loaded.
%%
%% $Description
%%  Verify that it shall not be possible to get LINK_DELAY_DL when DP lMC is not loaded.
%%
%% $Requirements
%%  CBD_RICM_DCI_DELAY-VALUE_FU:1:C
%%  CBD_RICM_TIMING-DIST_FU:1:C
%%  CBD_RICM_TIMING-DIST_FU:3:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state starting.
%%  Subscribe BCI&DCI fault.
%%  The DP is not loaded
%%
%% $Action
%%  Send a GET_DELAY_REQ with parameters:
%%  ruId = 1
%%
%% $Result
%%  A GET_DELAY_REJ is received with parameters:
%%  ruId = 1
%%  errorCode = ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL
%%  errorDescription = "DP not loaded"
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-10-05, EEDAJA
%%    First version
%%  2013-10-17, ehuayya
%%    rename from dci_rd8 to dci_delay_6
%%  2013-10-18, ejonuna
%%    Now using function set_state_and_connect
%%------------------------------------------------------------------------------
dci_delay_6() ->
	[{userdata,[{wp, ""},
				{requirement, "CBD_RICM_DCI_DELAY-VALUE_FU:1:C, CBD_RICM_TIMING-DIST_FU:1:C, CBD_RICM_TIMING-DIST_FU:3:C"},
				{slogan, "Get LINK_DELAY_DL: DP not loaded."}]}].

dci_delay_6(_Config) ->
	ct:pal("dci_delay_6"),

	%% Set state, make audit, establish BCI and DCI connections, subscribe faults
	set_state_and_connect( starting_lmc_not_loaded ),
	%% Subscribe Faults DCI
	ok = nci_dci_actions:subscribe_faults([]),

	ct:pal("Action1 & Result1"),
	%% Get Delay
	nci_dci_actions:get_delay([{expectedSigNo, ?RICM_GET_DELAY_REJ},
					{errorCode, ?ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL},
					{errorDescription, {regexp, "DP not loaded*"}}]),

	%% Check that NO BC/DC_FAULT_IND is generated
	nci_common_utils:check_outstanding_faults(2000).


%%------------------------------------------------------------------------------
%% $Id DCI_DELAY_7
%%
%% $Header
%%  Get LINK_DELAY_DL: O&M link taken down.
%%
%% $Description
%%  Check that Timing Distribution is stopped when O&M link is goes down and resumed when O&M link is up again.
%%
%% $Requirements
%%  CBD_RICM_DCI_DELAY-VALUE_FU:1:C
%%  CBD_RICM_TIMING-DIST_FU:2:C
%%  CBD_RICM_TIMING-DIST_FU:1:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  At least 1 RU
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state starting.
%%  Subscribe BCI&DCI fault.
%%  CPRI, O&M link is set up to RU
%%
%% $Action_1
%%  Send a RELEASE_RADIO_CTL_REQ with parameter:
%%  ruId = <read from config file>.
%%
%% $Result_1
%%  A RELEASE_RADIO_CTL_CFM is received with parameter:
%%  ruId = <read from config file>.
%%
%% $Result_1
%%  A RELEASE_RADIO_CTL_IND is received with parameter:
%%  ruId = <read from config file>.
%%
%% $Action_2
%%  Send a GET_DELAY_REQ with parameter:
%%  ruId = <read from config file>.
%%
%% $Result_2
%%  A GET_DELAY_REJ is received with parameters:
%%  errorCode = ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL
%%  errorDescription = "Delay measurement not started"
%%
%% $Action_3
%%  Send a ADD_RADIO_CTL_REQ with parameter:
%%  ruId = <read from config file>.
%%
%% $Result_3
%%  A ADD_RADIO_CTL_CFM is received:
%%  ruId = <read from config file>.
%%
%% $Result_3
%%  A ADD_RADIO_CTL_IND is received with parameters:
%%  connStatus = 1
%%  ruId = <read from config file>.
%%  huntPath = <read from config file>.
%%
%% $Action_4
%%  Send a GET_DELAY_REQ with parameter:
%%  ruId = <read from confi file>.
%%
%% $Result_4
%%  A GET_DELAY_CFM is received with parameter:
%%  linkDelayDl = <a value>
%%  
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  2012-12-17, EJONUNA
%%
%% Revision history:
%%  2012-12-06, EEDAJA
%%    First version
%%  2013-10-09, eraasli
%%    Updated to use nci_dci_actions:subscribe_faults([])
%%  2013-10-17, ehuayya
%%    Rename from dci_rd10 to dci_delay_7.
%%
%%------------------------------------------------------------------------------
dci_delay_7() ->
	[{userdata,[{wp, ""},
				{requirement, "CBD_RICM_DCI_DELAY-VALUE_FU:1:C, CBD_RICM_TIMING-DIST_FU:2:C, CBD_RICM_TIMING-DIST_FU:1:C"},
				{slogan, "Get LINK_DELAY_DL: O&M link taken down."},
				{hwConfig, hwConfigA}]}].

dci_delay_7(_Config) ->
	ct:pal("dci_delay_7"),

	% Set state, make audit, establish BCI and DCI connections, subscribe faults
	set_state_and_connect( starting_lmc_loaded ),

	ok = nci_dci_actions:subscribe_faults([]),

	Radio1 = nci_ricm_utils:get_first_radio(),

	%% Start CPRI
	ok = nci_dci_actions:start_cpri_link(Radio1),
	ok = nci_dci_actions:cpri_link_ind(Radio1 ++ [{availStatus, 1}]),

	%% Add Radio Control
	nci_dci_actions:add_radio_control(Radio1),
	nci_dci_actions:radio_control_ind(Radio1 ++ [{connStatus, 1},{radioSoftware, application}]),

	ct:pal("Action_1 & Result_1"),
	%% Release Radio Control
	nci_dci_actions:release_radio_control(Radio1),
	ct:pal("Result1"),
	nci_dci_actions:release_radio_control_ind(Radio1),

	ct:pal("Action2 & Result2"),
	%% Get Delay
	nci_dci_actions:get_delay(Radio1 ++ [{expectedSigNo, ?RICM_GET_DELAY_REJ},
												{errorCode, ?ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL},
												{errorDescription, {regexp, "Delay measurement not started*"}}]),

	ct:pal("Action3 & Result3"),
	%% Add Radio Control
	nci_dci_actions:add_radio_control(Radio1),
	ct:pal("Result3"),
	nci_dci_actions:radio_control_ind(Radio1 ++ [{connStatus, 1},{radioSoftware, application}]),

	ct:pal("Result4"),
	%% Get Delay
	nci_dci_actions:get_delay(Radio1),

	%% Reset CPRI Link
	ok = nci_dci_actions:reset_cpri_link(Radio1),
	ok = nci_dci_actions:reset_cpri_link_ind(Radio1),

	%% Check that NO BC/DC_FAULT_IND is generated
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id DCI_DELAY_8
%%
%% $Header
%%  Get LINK_DELAY_DL: restarting RU
%%
%% $Description
%%  Check delay, test delay before, during and after restart of RUs.
%%
%% $Requirements
%%  CBD_RICM_DCI_DELAY-VALUE_CA:1:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  At least 1 radio
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  The DU BC is in state starting.
%%  The RU is connected and ECP up for the whole cascaded chain
%%
%% $Action_1
%%  Send a GET_DELAY_REQ with parameters:
%%  ruId = <read from config file>
%%
%% $Result_1
%%  A GET_DELAY_CFM is received with parameters:
%%  ruId = <read from config file>
%%  linkDelayDl = <a value>
%% 
%% $Action_2
%%  Restart radio by "lhsh restart"
%%
%% $Result_2
%%  --
%%
%% $Action_3
%%  Send a GET_DELAY_REQ with parameters:
%%  ruId = <read from config file>
%%
%% $Result_3
%%  A GET_DELAY_REJ is received with parameters:
%%  ruId = <read from config file>
%%  errorCode = ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL
%%  errorDescription = "Delay measurement not started"
%%
%% $Action_4
%%  Receive link down signals triggered by the restart.
%%
%% $Result_4
%%  RICM_START_CPRI_LINK_IND signals are received with parameters:
%%  ruId = ruIds for radios on cascading Chain(currect to last)
%%  availStatus = 0
%%  typeOfUnit = don't care
%%
%%  RICM_ADD_RADIO_CTL_IND signals are received with parameters:
%%  ruId = don't care
%%  connStatus = 0
%%  ruLnhPath = don't care
%%
%%  ELIB_DC_FAULT_IND signals are received with parameters:
%%  faultId = ELIB_CONST_FH_FAULT_ID_LF_STABILITY
%%  faultDescription = contains string "Temporary not in operation"
%%
%%  ELIB_DC_FAULTCEASE_IND signal is received with parameters:
%%  faultId = ELIB_CONST_FH_FAULT_ID_LF_STABILITY
%%
%%  ELIB_DC_FAULT_IND signals are received with parameters:
%%  faultId = ELIB_CONST_FH_FAULT_ID_LINK_FAILURE
%%  faultDescription = contains string "Not in operation"
%%
%% $Action_5
%%  Receive link up signals triggered by the restart.
%%
%% $Result_5
%%  RICM_START_CPRI_LINK_IND signals are received with parameters:
%%  ruId = ruIds for radios on cascading Chain(currect to last)
%%  availStatus = 1
%%  typeOfUnit = don't care
%%
%%  RICM_ADD_RADIO_CTL_IND signals are received with parameters:
%%  ruId = ruIds for radios on cascading Chain(currect to last)
%%  connStatus = 1
%%  ruLnhPath = don't care
%%
%%  ELIB_DC_FAULTCEASE_IND signal is received with parameters:
%%  faultId = ELIB_CONST_FH_FAULT_ID_LINK_FAILURE
%%
%% $Action_6
%%  Send a GET_DELAY_REQ with parameters:
%%  ruId = read from config file
%%
%% $Result_6
%%  A GET_DELAY_CFM is received with parameters:
%%  ruId = read from config file
%%  linkDelayDl = <a value>
%%
%% $Action_7
%%  Check that linkDelayDl value is reasonable
%%
%% $Result_7
%%  linkDelayDl in nano seconds should be within the limits: (radios total cableLength * 5) + radios CascadeDelayDL + - 10 for DUL20
%%  and DuinternalDelay + (radios total cableLength * 5) + radios CascadeDelayDL + - 40 for DUS41
%%      DuinternalDelay is euqal to (Delay_ri_tx_f/1000) + Delay_ri_tx_v/8
%%
%% $Action_8
%% Repeat Action_1 to Action_7 for all the radio on the cascading Chain
%%
%% $Result_8
%% Same as Result_1 to Result_7
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  2013-01-15, EJONUNA
%%
%% Revision history:
%%  2012-12-19, EYANWZH
%%    First version
%%  2013-01-16. EYANWZH
%%    Update for review comments:Add function delay_2_3,restructure the test case to use such function .
%%  2013-08-21, ejonuna
%%    Improved test case to support radios with different types of cascadedDelayDL values and for each radio to have different cable lengths
%%  2013-10-17, ehuayya
%%    Rename from dci_delay_2 to dci_delay_8, use common function to get LINK_DELAY_DL, rename delay_2_r to delay_8_9_main.
%%  2014-04-02, EMASNOK
%%    Added delay before restarting radio.
%%
%%------------------------------------------------------------------------------
dci_delay_8() ->
	[{userdata,[{wp, ""},
				{requirement, "CBD_RICM_DCI_DELAY-VALUE_CA:1:C"},
				{slogan, "Get LINK_DELAY_DL: restarting RU."},
				{hwConfig, hwConfigA}]}].

dci_delay_8(_Config) ->
	ct:pal("dci_delay_8"),
	
	%%setup cpril and O&M link.
	Radios = delay_pre(starting_lmc_loaded),

	delay_8_9_main("dci_delay_8", Radios, [], Radios),
	
	%% Reset CPRI Link
	[Radio|_] = Radios,  
    	
	ok = nci_dci_actions:reset_cpri_link(Radio),
    
	ok = nci_dci_actions:reset_cpri_link_ind(Radio),
    
	%% Check that NO BC/DC_FAULT_IND is generated
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id DCI_DELAY_9
%%
%% $Header
%%  Get LINK_DELAY_DL: after restart RU
%%
%% $Description
%%  Get delay, Read delay after restart of RUs. From the last to first in cascaded chain (if cascade chain is present).
%%
%% $Requirements
%%  CBD_RICM_DCI_DELAY-VALUE_CA:1:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  At least 1 radio
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  The DU BC is in state starting.
%%  The RU is connected and ECP up for the whole cascaded chain
%%
%% $Action_1
%%  Send a GET_DELAY_REQ with parameters:(X is last radio on the chain)
%%  ruId = X
%%
%% $Result_1
%%  A GET_DELAY_CFM is received with parameters:
%%  ruId = X
%%  linkDelayDl = <a value>
%% 
%% $Action_2
%%  Restart radio for ruId X (last radio on the chain)
%%
%% $Result_2
%%  --
%%
%% $Action_3
%%  Send a GET_DELAY_REQ with parameters:
%%  ruId = X
%%
%% $Result_3
%%  A GET_DELAY_REJ is received with parameters:
%%  ruId = X
%%  errorCode = ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL
%%  errorDescription = "Delay measurement not started"
%%
%% $Action_4
%%  Receive link down signals triggered by the restart.
%%
%% $Result_4
%%  RICM_START_CPRI_LINK_IND signals are received with parameters:
%%  ruId = ruIds for radios on cascading Chain(currect to last)
%%  availStatus = 0
%%  typeOfUnit = don't care
%%
%%  RICM_ADD_RADIO_CTL_IND signals are received with parameters:
%%  ruId = don't care
%%  connStatus = 0
%%  ruLnhPath = don't care
%%
%%  ELIB_DC_FAULT_IND signals are received with parameters:
%%  faultId = ELIB_CONST_FH_FAULT_ID_LF_STABILITY
%%  faultDescription = contains string "Temporary not in operation"
%%
%%  ELIB_DC_FAULTCEASE_IND signal is received with parameters:
%%  faultId = ELIB_CONST_FH_FAULT_ID_LF_STABILITY
%%
%%  ELIB_DC_FAULT_IND signals are received with parameters:
%%  faultId = ELIB_CONST_FH_FAULT_ID_LINK_FAILURE
%%  faultDescription = contains string "Not in operation"
%%
%% $Action_5
%%  Receive link up signals triggered by the restart.
%%
%% $Result_5
%%  RICM_START_CPRI_LINK_IND signals are received with parameters:
%%  ruId = ruIds for radios on cascading Chain(currect to last)
%%  availStatus = 1
%%  typeOfUnit = don't care
%%
%%  RICM_ADD_RADIO_CTL_IND signals are received with parameters:
%%  ruId = ruIds for radios on cascading Chain(currect to last)
%%  connStatus = 1
%%  ruLnhPath = don't care
%%
%%  ELIB_DC_FAULTCEASE_IND signal is received with parameters:
%%  faultId = ELIB_CONST_FH_FAULT_ID_LINK_FAILURE
%%
%% $Action_6
%%  Send a GET_DELAY_REQ with parameters:
%%  ruId = X
%%
%% $Result_6
%%  A GET_DELAY_CFM is received with parameters:
%%  ruId = X
%%  linkDelayDl = <a value>
%%
%% $Action_7
%%  Check that linkDelayDl value is reasonable
%%
%% $Result_7
%%  linkDelayDl in nano seconds should be within the limits: (radios total cableLength * 5) + radios CascadeDelayDL + - 10 for DUL20
%%  and DuinternalDelay + (radios total cableLength * 5) + radios CascadeDelayDL + - 40 for DUS41
%%      DuinternalDelay is euqal to (Delay_ri_tx_f/1000) + Delay_ri_tx_v/8
%%
%% $Action_8
%% Repeat Action_1 to Action_7 for all the radio on the cascading Chain from last to first
%%
%% $Result_8
%% Same as Result_1 to Result_7.
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  2013-01-15, EJONUNA
%%
%% Revision history:
%%  2012-12-19, EYANWZH
%%    First version
%%  2013-01-16, EYANWZH
%%    Update for review comments: Add function delay_2_3,restructure the test case to use such function .
%%  2013-08-21, ejonuna
%%    Improved test case to support radios with different types of cascadedDelayDL values and for each radio to have different cable lengths
%%  2013-10-17, ehuayya
%%    Rename from dci_delay_2 to dci_delay_9, use common function to get LINK_DELAY_DL.
%%  2014-04-02, EMASNOK
%%    Added delay before restarting radios.
%%
%%------------------------------------------------------------------------------
dci_delay_9() ->
	[{userdata,[{wp, ""},
				{requirement, "CBD_RICM_DCI_DELAY-VALUE_CA:1:C"},
				{slogan, "Get LINK_DELAY_DL: after restart RU"},
				{hwConfig, hwConfigA}]}].

dci_delay_9(_Config) ->
	ct:pal("dci_delay_9"),
	
	%%setup cpril and O&M link.
	Radios = delay_pre(starting_lmc_loaded),	
	
	Radiosrev = lists:reverse(Radios),

	delay_8_9_main("dci_delay_9",Radiosrev,[],Radios),
	
	%% Reset CPRI Link
	[Radio|_] = Radios,  
    	
	ok = nci_dci_actions:reset_cpri_link(Radio),
    
	ok = nci_dci_actions:reset_cpri_link_ind(Radio),
    
	%% Check that NO BC/DC_FAULT_IND is generated
	nci_common_utils:check_outstanding_faults(2000).
	
%%-------------------------------------------------------------------------------
%% The parameter Lastradios is only used for test case dci_delay_9
%%-------------------------------------------------------------------------------
delay_8_9_main(_Name,[],_Lastradios,_AllCascadedRadios) ->

	ok;
	
delay_8_9_main(Name,[Radios1|Restradios],Lastradios,AllCascadedRadios) -> 

	ct:pal("Action_1"),
	%%get the delay values
	nci_dci_actions:get_delay(Radios1),
	
	ct:pal("Action_2"),
	restart_ru(Radios1),
	
	ct:pal("Action_3"),
	%%try to get the delay value when the RE:s is down
	nci_dci_actions:get_delay(Radios1 ++ [{expectedSigNo, ?RICM_GET_DELAY_REJ},
										  {errorCode, ?ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL},
										  {errorDescription, {regexp, "Delay measurement not started*"}}]),

	ct:pal("Action_4 & Result_4"),
	%% Received signal from current radio to last radio on the radio	
	case Name of
		"dci_delay_9"	->
			Radios = [Radios1|Lastradios];
		_ ->
			Radios = [Radios1|Restradios]
	end,

	cascade_restart_ru_post_signals(Radios1, Radios),

	lists:foreach(
		fun(RadioItemValue) ->
				ok = nci_rici_actions:conn_establish(RadioItemValue)

		end,
		Radios),
	
	ct:pal("Action_6,7,8"),	
	%%caculate the delay and decide it's validy
	get_delay_validity(Radios1,AllCascadedRadios,5),
	
	delay_8_9_main(Name,Restradios,Radios,AllCascadedRadios).

%%------------------------------------------------------------------------------
%% $Id DCI_DELAY_10
%%
%% $Header
%%  Delay value updated after link up
%%
%% $Description
%%  Get Delay, Check that LinkDelay value is updated after link to RU is up
%%
%% $Requirements
%%  CBD_RICM_TIMING-DIST_FU:1:C
%%  CBD_RICM_DELAY-VALUE-DIST_CA:2:H
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  At least one radio on any port
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state starting.
%%  DP LMC is loaded
%%  DCI connection establish performed
%%  Subscribe DCI faults
%%  Supervision RICI trace enabled ("te e trace1 RICM_SUPERVISION_RICI")
%%  CPRI and O&M is set up for the first connected RU.
%%
%% $Action_1
%%  Keep link up for 5 seconds in order to make sure an update 
%%  delay request is sent to the radio.
%%
%% $Result_1
%%  -
%%
%% $Action_2
%%  Send a RELEASE_RADIO_CTL_REQ
%%
%% $Result_2a
%%  A RELEASE_RADIO_CTL_CFM is received
%%
%% $Result_2b
%%  A RELEASE_RADIO_CTL_IND is received
%%
%% $Action_3
%%  Send a RESET_CPRI_LINK_REQ
%%
%% $Result_3a
%%  A RESET_CPRI_LINK_CFM is received
%%
%% $Result_3b
%%  A RESET_CPRI_LINK_IND is received
%%
%% $Action_4
%%  Check Trace&Error log for trace: RICI_UPDATE_DELAY2_REQ 
%%
%% $Result_4
%%  Trace exists
%%
%% $Postcondition
%%  Supervision RICI trace disabled ("te d trace1 RICM_SUPERVISION_RICI")
%%
%% $End
%%
%% Review:
%%  2013-01-15, EJONUNA
%%
%% Revision history:
%%  2012-12-26, EYANWZH
%%    First version
%%  2013-01-16, EYANWZH
%%    Update for review comments:Remove unused variable and unuseful comments.
%%  2013-10-09, eraasli
%%    Updated to use nci_dci_actions:subscribe_faults([])
%%  2013-10-18, ejonuna
%%    Now using function set_state_and_connect
%% 2013-10-23, ehuayya
%%    Rename from dci_rd12 to dci_delay_10
%% 2014-02-20, emasnok
%%    Modified test scope, check for RICI_UPDATE_DELAY2_REQ after link up
%%
%%------------------------------------------------------------------------------
dci_delay_10() ->
	[{userdata,[{wp, ""},
				{requirement, "CBD_RICM_DCI_DELAY-VALUE_CA:1:C"},
				{slogan, "Delay value updated after link up"},
				{hwConfig, hwConfigA}]}].

dci_delay_10(_Config) ->
	ct:pal("dci_delay_10"),
	{ok, session_up} = coli:subscribe_state(?SHELL_COMMAND),
	{ok, session_up} = osegw:subscribe_state(?OSE_GW_DEAMON_1),

	%%Set state, make audit, establish BCI and DCI connections, subscribe faults
	set_state_and_connect( starting_lmc_loaded ),

	%% Subscribe Faults DCI
	ok = nci_dci_actions:subscribe_faults([]),

	%% Turn on traces for RICI_UPDATE_DELAY2_REQ
	nci_common_utils:coli_cmd("te e trace1 RICM_SUPERVISION_RICI", ""),

	%% Start CPRI link
	Radio1 = nci_ricm_utils:get_first_radio(),
	ok = nci_dci_actions:start_cpri_link(Radio1),
	ok = nci_dci_actions:cpri_link_ind(Radio1 ++ [{availStatus, 1}]),

	%% Add Radio Control
	nci_dci_actions:add_radio_control(Radio1),
	nci_dci_actions:radio_control_ind(Radio1 ++ [{connStatus, 1},{radioSoftware, application}]),
	
	%% Keep link up so update delay request is sent to RU.
	ct:pal("Action_1: Keep link up for 5 seconds"),
	timer:sleep(5*1000),

	%% Release Radio Control
	ct:pal("Action_2"),
	ok = nci_dci_actions:release_radio_control(Radio1),
	ok = nci_dci_actions:release_radio_control_ind(Radio1),
	
	%% Reset CPRI Link
	ct:pal("Action_3"),
	ok = nci_dci_actions:reset_cpri_link(Radio1),
	ok = nci_dci_actions:reset_cpri_link_ind(Radio1),

	%% Verify update delay trace is present in T&E log
	ct:pal("Action_4"),
	nci_common_utils:find_string_in_te_log(?SHELL_COMMAND, "RICI_UPDATE_DELAY2_REQ"),

	%% Disable RICI supervision tracing
	coli:cmd(?SHELL_COMMAND, "te d trace1 RICM_SUPERVISION_RICI"),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).	


%%------------------------------------------------------------------------------
%% $Id dci_delay_11
%%
%% $Header
%%  Get delay, Check that delay values reported are valid for long cables.
%%
%% $Description
%%  Check that delay values reported are valid for long cables using CPRI-C
%%
%% $Requirements
%%  CBD_RICM_DCI_DELAY-VALUE_CA:1:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  One CPRIC-NG in Sniffer Mode connected between DU and a Radio
%%
%% $Type
%%  Regression
%%
%% $Precondition
%%  The DU BC is in state starting.
%%  CPRI-C cable length set to 40000 meter on both ports
%%  CPRI Link and O&M started 
%%  
%%
%% $Action_1
%%  Send a GET_DELAY_REQ with parameters:
%%
%%  ruId = <according to configuration>
%%
%% $Result_1
%%  A GET_DELAY_CFM is received with parameters:
%%
%%  ruId = <according to configuration>
%%
%%  linkDelayDl = <a value>
%%
%% $Action_2
%%  Check that linkDelayDl value is reasonable
%%
%% $Result_2
%%  linkDelayDl in nano seconds should be within the limits: (radios total cableLength * 5) + radios CascadeDelayDL + - 10 for DUL20
%%  and DuinternalDelay + (radios total cableLength * 5) + radios CascadeDelayDL + - 40 for DUS41
%%      DuinternalDelay is euqal to (Delay_ri_tx_f/1000) + Delay_ri_tx_v/8
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%
%% Revision history:
%%  2013-11-08, ejonuna
%%    First version
%%
%%------------------------------------------------------------------------------
dci_delay_11() ->
	[{userdata,[{wp, ""},
				{requirement, "CBD_RICM_DCI_DELAY-VALUE_CA:1:C"},
				{slogan, "Get delay, Check that delay values reported are valid for long cables"},
				{hwConfig, hwConfig_CPRI_Converter}]}].

dci_delay_11(_Config) ->

	set_state_and_connect( starting_lmc_loaded ),

	%% Subscribe Faults DCI
	ok = nci_dci_actions:subscribe_faults([]),
	
	Radio = nci_ricm_utils:get_first_cpri_converter_connected_radio(),

	CPRI_Converter = nci_ricm_utils:get_cpri_converter(Radio),

	nci_cpri_converter:enable_emulator(CPRI_Converter),
	nci_cpri_converter:set_cable_length_emulator(CPRI_Converter,40000,?CPRI_CONVERTER_PORT_BOTH),

	%% Start CPRI
	ok = nci_dci_actions:start_cpri_link(Radio),
	ok = nci_dci_actions:cpri_link_ind(Radio ++ [{availStatus, 1}]),

	nci_dci_actions:add_radio_control(Radio),
	nci_dci_actions:radio_control_ind(Radio ++ [{connStatus, 1},
										{radioSoftware, application}]),

	ct:pal("Action_1 & Action_2"),
	CableLength = proplists:get_value(cableLength,Radio),
	RadiosWithUpdatedCableLength = proplists:delete(cableLength,Radio) ++ [{cableLength,CableLength+40000}],
	get_delay_validity(RadiosWithUpdatedCableLength,[RadiosWithUpdatedCableLength],1),

	%% Reset CPRI Link
	ok = nci_dci_actions:reset_cpri_link(Radio),
	ok = nci_dci_actions:reset_cpri_link_ind(Radio),

	nci_cpri_converter:set_cable_length_emulator(CPRI_Converter,0,?CPRI_CONVERTER_PORT_BOTH),

	nci_cpri_converter:disable_emulator(CPRI_Converter),

	%% Check that NO BC/DC_FAULT_IND is generated
	nci_common_utils:check_outstanding_faults(2000).

%%##############################################################################
%% $ChapterH2 Release Radio Control
%%
%%
%% $End
%%##############################################################################

%%------------------------------------------------------------------------------
%% $Id DCI_RRC1
%%
%% $Header
%%  DCI Release Radio Control - State Starting
%%
%% $Description
%%  Verify release radio control in state starting
%%
%% $Requirements
%%  CBD_RICM_DCI-RELEASE-RADIO-CTL_FU:1:C
%%  CBD_RICM_EL1CI-REG-ESTABLISH_FU:1:C
%%  CBD_RICM_EL1CI-LTE-ECP_X_FU:1:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  At least one radio on any port
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state starting.
%%
%%  Radio control for ruId 1, port 4 is added
%%
%% $Action_1
%%  Check connection with shellcommand "lhsh BXP_3_1 lmclist"
%%
%% $Result_1
%%  The output should not be the line "failed to connect to BXP_3_1"
%%
%% $Action_2
%%  Send a RELEASE_RADIO_CTL_REQ with parameters:
%%
%%  ruId = 1
%%
%% $Result_2
%%  A RELEASE_RADIO_CTL_CFM is received with parameters:
%%
%%  ruId = 1
%%
%% $Result_2
%%  A RELEASE_RADIO_CTL_IND is received with parameters:
%%
%%  ruId = 1
%%
%% $Action_3
%%  Check connection with shellcommand "lhsh BXP_3_1 lmclist"
%%
%% $Result_3
%%  The output should be the line "failed to connect to BXP_3_1"
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  2012-10-18, EYANWZH
%%
%% Revision history:
%%  2012-10-01, EEDAJA
%%    First version
%%
%%  2012-10-18, EEDAJA
%%    Minor changes after review
%%
%%  2012-12-17, EEDAJA
%%    dci_rrc group of test cases restructured to use function dci_rrc_pre
%%
%%------------------------------------------------------------------------------
dci_rrc1() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_RICM_DCI-RELEASE-RADIO-CTL_FU:1:C, CBD_RICM_EL1CI-REG-ESTABLISH_FU:1:C, CBD_RICM_EL1CI-LTE-ECP_X_FU:1:C"},
				{slogan, "DCI Release Radio Control - State Starting"},
				{hwConfig, hwConfigA}]}].

dci_rrc1(_Config) ->
	ct:pal("dci_rrc1"),
	Radio1 = nci_ricm_utils:get_first_radio(),
	RuLnhPath = proplists:get_value(ruLnhPath, Radio1),

	dci_rrc_pre( Radio1, starting_lmc_loaded ),

	%% Release Radio Control
	nci_dci_actions:release_radio_control(Radio1 ++ [{expectedSigNo, ?RICM_RELEASE_RADIO_CTL_CFM}]),

	nci_dci_actions:release_radio_control_ind(Radio1),

	nci_common_utils:coli_cmd("lhsh " ++ RuLnhPath ++ " llmclist", "failed to connect to"),

	%% Reset CPRI Link
	ok = nci_dci_actions:reset_cpri_link(Radio1),

	ok = nci_dci_actions:reset_cpri_link_ind(Radio1),

	%% Check that NO BC/DC_FAULT_IND is generated
	nci_common_utils:check_outstanding_faults(2000).


dci_rrc_pre( Radio, State ) ->

	% Set state, make audit, establish BCI and DCI connections, subscribe BCI faults
	set_state_and_connect( State ),

	%% Subscribe Faults DCI
	ok = nci_dci_actions:subscribe_faults([]),

	Radio1 = nci_ricm_utils:get_first_radio(),
	RuLnhPath = proplists:get_value(ruLnhPath, Radio1),

	%% Start CPRI
	ok = nci_dci_actions:start_cpri_link(Radio),

	ok = nci_dci_actions:cpri_link_ind(Radio ++ [{availStatus, 1}]),

	%% Add Radio Control
	nci_dci_actions:add_radio_control(Radio ++ [{expectedSigNo, ?RICM_ADD_RADIO_CTL_CFM}]),

 	nci_dci_actions:radio_control_ind(Radio ++ [{connStatus, 1},{radioSoftware, application}]),

	nci_common_utils:coli_cmd("lhsh " ++ RuLnhPath ++ " lmclist", "SlotProt State").

%%------------------------------------------------------------------------------
%% $Id DCI_RRC2
%%
%% $Header
%%  DCI Release Radio Control - State Operational
%%
%% $Description
%%  Verify release radio control in state operational
%%
%% $Requirements
%%  CBD_RICM_DCI-RELEASE-RADIO-CTL_FU:1:C
%%  CBD_RICM_EL1CI-REG-ESTABLISH_FU:1:C
%%  CBD_RICM_EL1CI-LTE-ECP_X_FU:1:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  At least one radio on any port
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state operational.
%%
%%  Radio control for ruId 1, port 4 is added
%%
%% $Action_1
%%  Check connection with shellcommand "lhsh BXP_3_1 lmclist"
%%
%% $Result_1
%%  The output should not be the line "failed to connect to BXP_3_1"
%%
%% $Action_2
%%  Send a RELEASE_RADIO_CTL_REQ with parameters:
%%
%%  ruId = 1
%%
%% $Result_2
%%  A RELEASE_RADIO_CTL_CFM is received with parameters:
%%
%%  ruId = 1
%%
%% $Result_2
%%  A RELEASE_RADIO_CTL_IND is received with parameters:
%%
%%  ruId = 1
%%
%% $Action_3
%%  Check connection with shellcommand "lhsh BXP_3_1 lmclist"
%%
%% $Result_3
%%  The output should be the line "failed to connect to BXP_3_1"
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  2012-10-18, EYANWZH
%%
%% Revision history:
%%  2012-10-01, EEDAJA
%%    First version
%%
%%  2012-10-18, EEDAJA
%%    Minor changes after review
%%
%%  2012-12-17, EEDAJA
%%    dci_rrc group of test cases restructured to use function dci_rrc_pre
%%
%%------------------------------------------------------------------------------
dci_rrc2() ->
	[{userdata,[{wp, ""},
				{requirement, "CBD_RICM_DCI-RELEASE-RADIO-CTL_FU:1:C, CBD_RICM_EL1CI-REG-ESTABLISH_FU:1:C, CBD_RICM_EL1CI-LTE-ECP_X_FU:1:C"},
				{slogan, "DCI Release Radio Control - State Operational"},
				{hwConfig, hwConfigA}]}].

dci_rrc2(_Config) ->
	ct:pal("dci_rrc2"),
	Radio1 = nci_ricm_utils:get_first_radio(),
	RuLnhPath = proplists:get_value(ruLnhPath, Radio1),

	dci_rrc_pre( Radio1, operational ),

	%% Release Radio Control
	nci_dci_actions:release_radio_control(Radio1 ++ [{expectedSigNo, ?RICM_RELEASE_RADIO_CTL_CFM}]),

	nci_dci_actions:release_radio_control_ind(Radio1),

	nci_common_utils:coli_cmd("lhsh " ++ RuLnhPath ++ " lmclist", "failed to connect to"),

	%% Reset CPRI Link
	ok = nci_dci_actions:reset_cpri_link(Radio1),

	ok = nci_dci_actions:reset_cpri_link_ind(Radio1),

	%% Check that NO BC/DC_FAULT_IND is generated
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id DCI_RRC3
%%
%% $Header
%%  DCI Release Radio Control - State Disabled
%%
%% $Description
%%  Verify release radio control in state disabled
%%
%% $Requirements
%%  CBD_RICM_DCI-RELEASE-RADIO-CTL_FU:1:C
%%  CBD_RICM_EL1CI-REG-ESTABLISH_FU:1:C
%%  CBD_RICM_EL1CI-LTE-ECP_X_FU:1:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  At least one radio on any port
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  The DU BC is in state disabled.
%%
%%  Radio control for ruId 1, port 4 is added
%%
%% $Action
%%  Check connection with shellcommand "lhsh BXP_3_1 lmclist"
%%
%% $Result
%%  The output should not be the line "failed to connect to BXP_3_1"
%%
%% $Action
%%  Send a RELEASE_RADIO_CTL_REQ with parameters:
%%
%%  ruId = 1
%%
%% $Result
%%  A RELEASE_RADIO_CTL_REJ is received with parameters:
%%
%%  ruId = 1
%%
%%  errorDescription = "Invalid O&M state"
%%
%% $Action
%%  Check connection with shellcommand "lhsh BXP_3_1 lmclist"
%%
%% $Result
%%  The output should still not be the line "failed to connect to BXP_3_1"
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  2012-12-14, EJONUNA
%%
%% Revision history:
%%  2012-05-30, QMAGSED
%%    First version
%%
%%  2012-12-17, EEDAJA
%%    dci_rrc group of test cases restructured to use function dci_rrc_pre
%%
%%  2013-05-20, EYANWZH
%%    Fix the defects.
%%
%%  2013-07-02, EBACEMI
%%    Removed code that expects RICM_ADD_RADIO_CTL_IND after entering disabled state
%%------------------------------------------------------------------------------
dci_rrc3() ->
	[{userdata,[{wp, ""},
				{requirement, "CBD_RICM_DCI-RELEASE-RADIO-CTL_FU:1:C, CBD_RICM_EL1CI-REG-ESTABLISH_FU:1:C, CBD_RICM_EL1CI-LTE-ECP_X_FU:1:C"},
				{slogan, "DCI Release Radio Control - State Disabled"},
				{hwConfig, hwConfigA}]}].

dci_rrc3(_Config) ->
	ct:pal("dci_rrc3"),
	Radio1 = nci_ricm_utils:get_first_radio(),
	RuLnhPath = proplists:get_value(ruLnhPath, Radio1),

	dci_rrc_pre( Radio1, starting_lmc_loaded ),

	%% Disable Operation
	nci_bci_states:set_state([{state, disabled}]),

	%% Release Radio Control
	nci_dci_actions:release_radio_control(Radio1 ++ [{expectedSigNo, ?RICM_RELEASE_RADIO_CTL_REJ},
													{errorDescription, {regexp, "Invalid O&M state*"}}]),

	{ok, Result} = coli:cmd(?SHELL_COMMAND, "lhsh " ++ RuLnhPath ++ " lmclist"),

	case re:run(Result,"failed to connect|lost contact") of
		{match,[_]} -> ok;
		_ -> ct:fail("returned wrong result")
	end,

	%% Check that NO BC/DC_FAULT_IND is generated
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id DCI_RRC4
%%
%% $Header
%%  DCI Release Radio Control - No Control Added
%%
%% $Description
%%  Verify add radio control when no radio control has been added
%%
%% $Requirements
%%  CBD_RICM_DCI-RELEASE-RADIO-CTL_FU:1:C
%%  CBD_RICM_EL1CI-REG-ESTABLISH_FU:1:C
%%  CBD_RICM_EL1CI-LTE-ECP_X_FU:1:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  At least one radio on any port
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state starting.
%%
%%  Radio control for ruId 2 is not added
%%
%% $Action_1
%%  Send a RELEASE_RADIO_CTL_REQ with parameters:
%%
%%  ruId = 2
%%
%% $Result_1
%%  A RELEASE_RADIO_CTL_REJ is received with parameters:
%%
%%  ruId = 2
%%
%%  errorCode = UNSUCCESSFUL
%%
%%  errorDescription = "ruId not in use"
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-05-30, QMAGSED
%%    First version
%%
%%  2012-12-17, EEDAJA
%%    dci_rrc group of test cases restructured to use function dci_rrc_pre
%%
%%------------------------------------------------------------------------------
dci_rrc4() ->
	[{userdata,[{wp, ""},
				{requirement, "CBD_RICM_DCI-RELEASE-RADIO-CTL_FU:1:C, CBD_RICM_EL1CI-REG-ESTABLISH_FU:1:C, CBD_RICM_EL1CI-LTE-ECP_X_FU:1:C"},
				{slogan, "DCI Release Radio Control - No Control Added"},
				{hwConfig, hwConfigA}]}].

dci_rrc4(_Config) ->
	ct:pal("dci_rrc4"),
	Radio1 = nci_ricm_utils:get_first_radio(),
	dci_rrc_pre( Radio1, starting_lmc_loaded ),

	%% Release Radio Control
	ct:pal("Action_1"),
	nci_dci_actions:release_radio_control([{ruId,55},{expectedSigNo, ?RICM_RELEASE_RADIO_CTL_REJ},
													{errorDescription, {regexp, "ruId not in use*"}}]),
	%% Reset CPRI Link
	ok = nci_dci_actions:reset_cpri_link(Radio1),

	ok = nci_dci_actions:reset_cpri_link_ind(Radio1),

	%% Check that NO BC/DC_FAULT_IND is generated
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id DCI_RRC6
%%
%% $Header
%%  DCI Release Radio Control - ruId out of range and max value
%%
%% $Description
%%  Release Radio Control, Invalid ruId. Supported range is 1-65535.
%%
%% $Requirements
%%  CBD_RICM_DCI-RELEASE-RADIO-CTL_FU:1:C
%%  CBD_RICM_EL1CI-REG-ESTABLISH_FU:1:C
%%  CBD_RICM_EL1CI-LTE-ECP_X_FU:1:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  At least one radio on any port
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state starting.
%%  Radio control for ruId 65535, port 4 is added
%%
%% $Action_1
%%  Send a RICM_RELEASE_RADIO_CTL_REQ with parameters: ruId = 65535
%%
%% $Result_1a
%%  A RICM_RELEASE_RADIO_CTL_CFM is received with parameters: ruId = 65535
%%
%% $Result_1b
%%  A RICM_RELEASE_RADIO_CTL_IND is received with parameters: ruId = 65535
%%
%% $Action_2
%%  Send a RICM_RELEASE_RADIO_CTL_REQ with parameters: ruId = 0
%%
%% $Result_2
%%  A RICM_RELEASE_RADIO_CTL_REJ is received with parameters: 
%%   * ruId = 0
%%   * errorCode = UNSUCCESSFUL
%%   * errorDescription = "ruId not in use"
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-10-05, EEDAJA
%%    First version
%%  2012-12-17, EEDAJA
%%    dci_rrc group of test cases restructured to use function dci_rrc_pre
%%  2014-02-19, EMASNOK
%%    Added check for release radio control ind. Updated header.
%%
%%------------------------------------------------------------------------------
dci_rrc6() ->
	[{userdata,[{wp, ""},
				{requirement, "CBD_RICM_DCI-RELEASE-RADIO-CTL_FU:1:C, CBD_RICM_EL1CI-REG-ESTABLISH_FU:1:C, CBD_RICM_EL1CI-LTE-ECP_X_FU:1:C"},
				{slogan, "DCI Release Radio Control - ruId out of range and max value"},
				{hwConfig, hwConfigA}]}].

dci_rrc6(_Config) ->
	ct:pal("dci_rrc6"),
	Radio1 = nci_ricm_utils:get_first_radio(),
	RadioMaxRuId = proplists:delete(ruId,Radio1) ++ [{ruId,65535}],
	dci_rrc_pre( RadioMaxRuId, starting_lmc_loaded ),

	%% Release Radio Control
	ct:pal("Action_1"),
	nci_dci_actions:release_radio_control(RadioMaxRuId),
	nci_dci_actions:release_radio_control_ind(RadioMaxRuId),

	%% Release Radio Control
	ct:pal("Action_2"),
	nci_dci_actions:release_radio_control([{ruId, 0},
										   {expectedSigNo, ?RICM_RELEASE_RADIO_CTL_REJ},
										   {errorDescription, {regexp, "ruId not in use*"}}]),

	%% Reset CPRI Link
	ok = nci_dci_actions:reset_cpri_link(RadioMaxRuId),
	ok = nci_dci_actions:reset_cpri_link_ind(RadioMaxRuId),

	%% Check that NO BC/DC_FAULT_IND is generated
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id DCI_RRC7
%%
%% $Header
%%  DCI Release Radio Control - Link already disconnected
%%
%% $Description
%%  Release Radio Control, Link already disconnected.
%%
%% $Requirements
%%  CBD_RICM_DCI-RELEASE-RADIO-CTL_FU:1:C
%%  CBD_RICM_EL1CI-REG-ESTABLISH_FU:1:C
%%  CBD_RICM_EL1CI-LTE-ECP_X_FU:1:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  At least one radio on any port
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state starting.
%%
%%  Radio control is up
%%
%% $Action_1
%%  Send a RELEASE_RADIO_CTL_REQ
%%
%% $Result_1_1
%%  A RELEASE_RADIO_CTL_CFM is received
%%
%% $Result_1_2
%%  A RELEASE_RADIO_CTL_IND is received
%%
%% $Action_2
%%  Send a RELEASE_RADIO_CTL_REQ
%%
%% $Result_2
%%  A RELEASE_RADIO_CTL_CFM is received
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-10-05, EEDAJA
%%    First version
%%
%%  2012-12-17, EEDAJA
%%    dci_rrc group of test cases restructured to use function dci_rrc_pre
%%
%%------------------------------------------------------------------------------
dci_rrc7() ->
	[{userdata,[{wp, ""},
				{requirement, "CBD_RICM_DCI-RELEASE-RADIO-CTL_FU:1:C, CBD_RICM_EL1CI-REG-ESTABLISH_FU:1:C, CBD_RICM_EL1CI-LTE-ECP_X_FU:1:C"},
				{slogan, "DCI Release Radio Control - Link already disconnected"},
				{hwConfig, hwConfigA}]}].

dci_rrc7(_Config) ->
	ct:pal("dci_rrc7"),
	Radio1 = nci_ricm_utils:get_first_radio(),
	dci_rrc_pre( Radio1, starting_lmc_loaded ),

	%% Release Radio Control
	ct:pal("Action_1"),
	nci_dci_actions:release_radio_control(Radio1 ++ [{expectedSigNo, ?RICM_RELEASE_RADIO_CTL_CFM}]),
	nci_dci_actions:release_radio_control_ind(Radio1),

	%% Release Radio Control again
	ct:pal("Action_2"),
	nci_dci_actions:release_radio_control(Radio1 ++ [{expectedSigNo, ?RICM_RELEASE_RADIO_CTL_CFM}]),
	nci_dci_actions:release_radio_control_ind(Radio1),

	%% Reset CPRI Link
	ok = nci_dci_actions:reset_cpri_link(Radio1),

	ok = nci_dci_actions:reset_cpri_link_ind(Radio1),

	%% Check that NO BC/DC_FAULT_IND is generated
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id DCI_RRC8
%%
%% $Header
%%  DCI Release Radio Control - DP not loaded
%%
%% $Description
%%  Release Radio Control, DP not loaded
%%
%% $Requirements
%%  CBD_RICM_DCI-RELEASE-RADIO-CTL_FU:1:C
%%  CBD_RICM_EL1CI-REG-ESTABLISH_FU:1:C
%%  CBD_RICM_EL1CI-LTE-ECP_X_FU:1:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  At least one radio on any port
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state starting.
%%
%%  The DP is not loaded
%%
%% $Action_1
%%  Send a RELEASE_RADIO_CTL_REQ with parameters:
%%
%%  ruId = 1
%%
%% $Result_1
%%  A RELEASE_RADIO_CTL_REJ is received with parameters:
%%
%%  ruId = 1
%%
%%  errorCode = UNSUCCESSFUL
%%
%%  errorDescription = "DP not loaded"
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2011-11-09, EEDAJA
%%    First version
%%
%%  2012-12-17, EEDAJA
%%    dci_rrc group of test cases restructured to use function dci_rrc_pre
%%
%%------------------------------------------------------------------------------
dci_rrc8() ->
	[{userdata,[{wp, ""},
				{requirement, "CBD_RICM_DCI-RELEASE-RADIO-CTL_FU:1:C, CBD_RICM_EL1CI-REG-ESTABLISH_FU:1:C, CBD_RICM_EL1CI-LTE-ECP_X_FU:1:C"},
				{slogan, "DCI Release Radio Control - DP not loaded"},
				{hwConfig, hwConfigA}]}].

dci_rrc8(_Config) ->
	ct:pal("dci_rrc8"),

	% Set state, make audit, establish BCI and DCI connections, subscribe BCI faults
	set_state_and_connect( starting_lmc_not_loaded ),

	%% Subscribe Faults DCI
	ok = nci_dci_actions:subscribe_faults([]),

	Radio1 = nci_ricm_utils:get_first_radio(),

	%% Start CPRI
	ok = nci_dci_actions:start_cpri_link(Radio1 ++ [
										{expectedSigNo, ?RICM_START_CPRI_LINK_REJ},
										{errorCode, 1},
										{errorDescription, {regexp, "DP not loaded*"}}]),

	%% Add Radio Control
	nci_dci_actions:add_radio_control( Radio1 ++ [
										{expectedSigNo, ?RICM_ADD_RADIO_CTL_REJ},
										{errorCode, 1},
										{errorDescription, {regexp, "DP not loaded*"}}]),

	%% Release Radio Control
	nci_dci_actions:release_radio_control(Radio1 ++ [
										{expectedSigNo, ?RICM_RELEASE_RADIO_CTL_REJ},
										{errorCode, 1},
										{errorDescription, {regexp, "DP not loaded*"}}]),

	%% Check that NO BC/DC_FAULT_IND is generated
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id DCI_RRC9
%%
%% $Header
%%  DCI Release Radio Control - Different ServerRef and ClientRef
%%
%% $Description
%%  Verify release radio control with serverRef and clientRef.
%%
%% $Requirements
%%  CBD_RICM_DCI-RELEASE-RADIO-CTL_FU:1:C
%%  CBD_RICM_EL1CI-REG-ESTABLISH_FU:1:C
%%  CBD_RICM_EL1CI-LTE-ECP_X_FU:1:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  At least one radio on any port
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state operational.
%%  Radio control for ruId 1 is added.
%%
%% $Action_1
%%  Check the ECP link for ruId 1.
%%
%% $Result_1
%%  The ECP link is up for the ruId 1.
%%
%% $Action_2
%%  Release Radio Control Link sent with ServerRef and ClientRef as 0.
%%
%% $Result_2
%%  Ricm releases the Radio Control Link with the same ServerRef and ClientRef as that in the request signal.
%%
%% $Action_3
%%  Add Radio control again for ruId 1.
%%
%% $Result_3
%%  Radio control is added.
%%
%% $Action_4
%%  Check the ECP link again for ruId 1.
%%
%% $Result_4
%%  The ECP link is up for the ruId 1.
%%
%% $Action_5
%%  Release Radio Control Link is sent with different ServerRef and ClientRef.
%%
%% $Result_5
%%  Ricm releases the Radio Control Link with the same ServerRef and ClientRef as that in the request signal.
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  2012-12-14, EJONUNA
%%
%% Revision history:
%%  2012-12-10, EYANWZH
%%    First version
%%
%%  2012-12-17, EEDAJA
%%    dci_rrc group of test cases restructured to use function dci_rrc_pre
%%
%%------------------------------------------------------------------------------
dci_rrc9() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_RICM_DCI-RELEASE-RADIO-CTL_FU:1:C, CBD_RICM_EL1CI-REG-ESTABLISH_FU:1:C, CBD_RICM_EL1CI-LTE-ECP_X_FU:1:C"},
				{slogan, "DCI Release Radio Control - Different ServerRef and ClientRef"},
				{hwConfig, hwConfigA}]}].

dci_rrc9(_Config) ->
	ct:pal("dci_rrc9"),
	Radio1 = nci_ricm_utils:get_first_radio(),
	RuLnhPath= proplists:get_value(ruLnhPath, Radio1),

	dci_rrc_pre( Radio1, operational ),

	%% Release Radio Control			
	nci_dci_actions:release_radio_control(Radio1 ++ [{clientRef, 0},{serverRef, 0},
												{expectedSigNo, ?RICM_RELEASE_RADIO_CTL_CFM}]),
												
	nci_dci_actions:release_radio_control_ind(Radio1 ++ [{clientRef, 0},{serverRef, 0}]),

 	nci_common_utils:coli_cmd("lhsh " ++ RuLnhPath ++ " lmclist", "failed to connect to"),
			
	%% Add Radio Control again
	nci_dci_actions:add_radio_control(Radio1 ++ [{expectedSigNo, ?RICM_ADD_RADIO_CTL_CFM}]),

	nci_dci_actions:radio_control_ind(Radio1 ++ [{connStatus, 1},{radioSoftware, application}]),
										
	nci_common_utils:coli_cmd("lhsh " ++ RuLnhPath ++ " lmclist", "SlotProt State"),
			
	%% Release Radio Control
	nci_dci_actions:release_radio_control(Radio1 ++ [{clientRef, 1},{serverRef, 0},
										{expectedSigNo, ?RICM_RELEASE_RADIO_CTL_CFM}]),
												
	nci_dci_actions:release_radio_control_ind(Radio1 ++ [{clientRef, 1},{serverRef, 0}]),

	nci_common_utils:coli_cmd("lhsh " ++ RuLnhPath ++ " lmclist", "failed to connect to"),

	%% Reset CPRI Link
	ok = nci_dci_actions:reset_cpri_link(Radio1),

	ok = nci_dci_actions:reset_cpri_link_ind(Radio1),

	%% Check that NO BC/DC_FAULT_IND is generated
	nci_common_utils:check_outstanding_faults(2000).

%%##############################################################################
%% $ChapterH2 Start CPRI Link
%%
%%
%% $End
%%##############################################################################



%%------------------------------------------------------------------------------
%% $Id DCI_SCLD1
%%
%% $Header
%%  Time Alignment Subscribe Cpri Link Delay in state starting. The RICM DCI
%%  interface supports cascaded DUs (WP2629).
%%
%% $Description
%%  Verify Time Alignment Subscribe Cable Delay in state starting
%%
%% $Requirements
%%   CBD_RICM_DCI-SUBSCRIBE-CABLE-DELAY_FU:1:A
%%   CBD_RICM_DCI-SUBSCRIBE-CABLE-DELAY_FU:3:A
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  At least one RU
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  The DU BC is in state starting.
%%  CPRI link and O&M link is set up to all configured radios
%%  Subscribe BCI&DCI fault.
%%
%% $Action_1
%%   RICM_SUBSCRIBE_CABLE_DELAY_REQ
%%     linkId = <according to configuration>
%%
%% $Result_1a
%%   RICM_SUBSCRIBE_CABLE_DELAY_CFM
%%     linkId = <according to configuration>
%%
%% $Result_1b
%%   RICM_SUBSCRIBE_CABLE_DELAY_IND
%%     linkId = <according to configuration>
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%
%% Revision history:
%%  2014-04-10, uabpar


%%    First version
%%
%%------------------------------------------------------------------------------
dci_scld1() ->
	[{userdata,[{wp, ""}, 
				{requirement, ""},
				{slogan, "Verify Time Alignment Subscribe Cable Delay in state starting"},
				{hwConfig, hwConfigA}]}].

dci_scld1(_Config) ->
	ct:pal("dci_scd1"),
 	dci_scld_main(starting_lmc_loaded).

dci_scld_main(State) ->
	Radios = nci_ricm_utils:get_all_radios(),
 	dci_scld_pre(Radios, State),

	%%Subscribe cable delay on all radios
	lists:foreach(
		fun(RadioItem) ->
				%%Subcribe for the cable delay
				ct:pal("Action_1 & Result_1a"),
				ok = nci_dci_actions:subscribe_cpri_link_delay(RadioItem),
				ct:pal("Result_1b"),
				ok = nci_dci_actions:cpri_link_delay_changed_ind(RadioItem)	
		end,
		Radios),

	stop_cpri_links(Radios),
	
	%% Check that NO BC/DC_FAULT_IND is generated
	nci_common_utils:check_outstanding_faults(2000).


dci_scld_pre(Radios, State) ->
	% Set state, make audit, establish BCI and DCI connections, subscribe faults
	set_state_and_connect( State ),

	%% Subscribe Faults DCI
	ok = nci_dci_actions:subscribe_faults([]),

	start_cpri_and_oam_links(Radios).


%%------------------------------------------------------------------------------
%% $Id DCI_SCD2
%%
%% $Header
%%  Time Alignment Subscribe Cable Delay in state operational
%%
%% $Description
%%  Verify Time Alignment Subscribe Cable Delay in state operational
%%
%% $Requirements
%%   CBD_RICM_DCI-SUBSCRIBE-CABLE-DELAY_FU:1:A
%%   CBD_RICM_DCI-SUBSCRIBE-CABLE-DELAY_FU:3:A
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  At least one RU
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  The DU BC is in operational.
%%  CPRI link and O&M link is set up to all configured radios
%%  Subscribe BCI&DCI fault.
%%
%% $Action_1
%%   RICM_SUBSCRIBE_CABLE_DELAY_REQ
%%     linkId = <according to configuration>
%%
%% $Result_1a
%%   RICM_SUBSCRIBE_CABLE_DELAY_CFM
%%     linkId = <according to configuration>
%%
%% $Result_1b
%%   RICM_SUBSCRIBE_CABLE_DELAY_IND
%%     linkId = <according to configuration>
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%
%% Revision history:
%%  2014-02-17, ejonuna
%%    First version
%%
%%------------------------------------------------------------------------------
dci_scd2() ->
	[{userdata,[{wp, ""}, 
				{requirement, ""},
				{slogan, "Verify Time Alignment Subscribe Cable Delay in state operational"},
				{hwConfig, hwConfigA}]}].

dci_scd2(_Config) ->
	ct:pal("dci_scd2"),
	dci_scld_main(operational).


%%------------------------------------------------------------------------------
%% $Id DCI_SCD3
%%
%% $Header
%%  Time Alignment Subscribe Cable Delay in state disabled
%%
%% $Description
%%  Verify Time Alignment Subscribe Cable Delay in state disabled
%%
%% $Requirements
%%   CBD_RICM_DCI-SUBSCRIBE-CABLE-DELAY_FU:1:A
%%   CBD_RICM_DCI-SUBSCRIBE-CABLE-DELAY_FU:3:A
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  The DU BC is in state starting.
%%  Subscribe BCI&DCI fault.
%%
%% $Action_1
%%   RICM_SUBSCRIBE_CABLE_DELAY_REQ
%%     linkId = <according to configuration>
%%
%% $Result_1
%%   RICM_SUBSCRIBE_CABLE_DELAY_REJ
%%     linkId = <according to configuration>
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%
%% Revision history:
%%  2014-02-17, ejonuna
%%    First version
%%
%%------------------------------------------------------------------------------
dci_scd3() ->
	[{userdata,[{wp, ""}, 
				{requirement, ""},
				{slogan, "Verify Time Alignment Subscribe Cable Delay in state disabled"}]}].

dci_scd3(_Config) ->
	ct:pal("dci_scd3"),

	set_state_and_connect( disabled ),

	ct:pal("Action_1 & Result_1"),
	ok = nci_dci_actions:subscribe_cable_delay([{linkId, 1},
												{expectedSigNo, ?RICM_SUBSCRIBE_CPRI_LINK_DELAY_REJ},
												{errorCode, ?ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL},
												{errorDescription, {regexp, "Invalid O&M state*"}}]),

	%% Check that NO BC/DC_FAULT_IND is generated
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id DCI_SCD4
%%
%% $Header
%%  Time Alignment Subscribe Cable Delay after radio restart in state starting
%%
%% $Description
%%  Verify Time Alignment Subscribe Cable Delay after radio restart in state starting
%%
%% $Requirements
%%   CBD_RICM_DCI-SUBSCRIBE-CABLE-DELAY_FU:1:A
%%   CBD_RICM_DCI-SUBSCRIBE-CABLE-DELAY_FU:2:A
%%   CBD_RICM_DCI-SUBSCRIBE-CABLE-DELAY_FU:3:A
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  At least one RU
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  The DU BC is in state starting.
%%  CPRI link and O&M link is set up to all configured radios
%%  Subscribe BCI&DCI fault.
%%
%% $Action_1
%%   RICM_SUBSCRIBE_CABLE_DELAY_REQ
%%     linkId = <according to configuration>
%%
%% $Result_1a
%%   RICM_SUBSCRIBE_CABLE_DELAY_CFM
%%     linkId = <according to configuration>
%%
%% $Result_1b
%%   RICM_SUBSCRIBE_CABLE_DELAY_IND
%%     linkId = <according to configuration>
%%
%% $Action_2
%%   Restart radio <according to configuration>
%%
%% $Result_2a
%%   Recevie restart radio signals
%%
%% $Result_2b
%%   RICM_SUBSCRIBE_CABLE_DELAY_IND
%%     linkId = <according to configuration>
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%
%% Revision history:
%%  2014-02-17, ejonuna
%%    First version
%%
%%------------------------------------------------------------------------------
dci_scd4() ->
	[{userdata,[{wp, ""}, 
				{requirement, ""},
				{slogan, "Verify Time Alignment Subscribe Cable Delay after radio restart in state starting"},
				{hwConfig, hwConfigA}]}].

dci_scd4(_Config) ->
	ct:pal("dci_scd4"),

	CascadedRadios = nci_ricm_utils:get_first_cascaded_radios(),
	if (CascadedRadios == []) ->
		Radios = [nci_ricm_utils:get_first_radio()];
	true ->
		Radios = CascadedRadios
	end,

	dci_scld_pre(Radios, starting_lmc_loaded),

	%%Subscribe cable delay on all radios
	lists:foreach(
		fun(RadioItem) ->
				%%Subcribe for the unit delay
				ct:pal("Action_1 & Result_1a"),
				ok = nci_dci_actions:subscribe_cable_delay(RadioItem),
				ct:pal("Result_1b"),
				ok = nci_dci_actions:subscribe_cable_delay_ind(RadioItem),

				ct:pal("Action_2"),
				restart_ru(RadioItem),

				ct:pal("Result_2a"),
				cascade_restart_ru_post_signals(RadioItem, Radios),

				ct:pal("Result_2b"),
				ok = nci_dci_actions:subscribe_cable_delay_ind(RadioItem)
		end,
		Radios),

	reset_all_cpri_links(Radios),

	%% Check that NO BC/DC_FAULT_IND is generated
	nci_common_utils:check_outstanding_faults(2000).


%%------------------------------------------------------------------------------
%% $Id DCI_SUD1
%%
%% $Header
%%  DCI Subscribe Unit Delay - State Starting
%%
%% $Description
%%  Verify that RICM subscribe unit delay correctly in state Starting.
%%
%% $Requirements
%%  CBD_RICM_DCI_SUBSCRIBE_UNIT_DELAY-VALUE_FU:1A
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  At least 1 RU
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  The DU BC is in state starting.
%%  CPRI, O&M link is set up to all radios.
%%  Subscribe BCI&DCI fault.
%%
%% $Action_1
%%  Send a RICM_SUBSCRIBE_UNIT_DELAY_REQ with parameters:
%%  * unitId = <read from config file>
%%  * thresholdValue = 0
%%  
%% $Result_1
%%  A RICM_SUBSCRIBE_UNIT_DELAY_CFM is received with parameters:
%%  * unitId = <Same as in Action_1>
%%
%% $Action_2
%%  Receive a RICM_SUBSCRIBE_UNIT_DELAY_IND if this is not the last radio in the cascade chain
%%
%% $Result_2
%%  A RICM_SUBSCRIBE_UNIT_DELAY_IND is received with parameters:
%%  * unitId = <read from config file>
%%  * unitDelayValues = <consist of the delayParameterDataS of parameterId and delay values>
%%
%% $Action_3
%%  Verify the delays from Result_2
%%  
%% $Result_3
%%  The delays are within a 10ns interval
%%
%% $Action_4
%%  Repeat Action_1 to Action_2 for all remaining radios in the configuration
%%  
%% $Result_4
%%  -
%%
%% $Action_5
%%  Delay for 1 minute
%%  
%% $Result_5
%%  -
%%
%% $Action_6
%%  Receive a RICM_SUBSCRIBE_UNIT_DELAY_IND
%%
%% $Result_6
%%  A RICM_SUBSCRIBE_UNIT_DELAY_IND is received with parameters:
%%  * unitId = <read from config file>
%%  * unitDelayValues = <consist of the delayParameterDataS of parameterId and delay values>
%%
%% $Action_7
%%  Verify the delays from Result_1b
%%  
%% $Result_7
%%  The delays are within a 10ns interval
%%
%% $Action_8
%%  Repeat Action_5 to Action_6 for all remaining radios in the configuration
%%  
%% $Result_8
%%  -
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%% -
%%
%% Revision history:
%%   2014-04-02 ebacemi
%%     First version.
%%
%%--------------------------------------------------------------------------------
dci_sud1() ->
	[{userdata,[{wp, ""},
				{requirement, "CBD_RICM_DCI_SUBSCRIBE_UNIT_DELAY-VALUE_FU:1A"},
				{slogan, "DCI Subscribe Unit Delay - State Starting"},
				{hwConfig, hwConfigA}]}].

dci_sud1(_Config) ->
	ct:pal("dci_sud1"),

	dci_sud(starting_lmc_loaded).

dci_sud(State) ->
	set_state_and_connect(State),

	ok = nci_dci_actions:subscribe_faults([]),

	Radios = nci_ricm_utils:get_all_radios(),

	start_cpri_and_oam_links(Radios),

	lists:foreach(
		fun(Radio) ->
				ct:pal("Action_1"),
				ok = nci_dci_actions:subscribe_unit_delay(Radio ++ [{thresholdValue, 0}]),

				ct:pal("Action_2"),
				case nci_ricm_utils:get_next_radio(Radio, Radios) of
					[] ->
						ct:pal("This is the last radio in the cascade chain.~n"
							   "RICM should send no IND"),
						RecvResult = osegw:recv(?OSE_GW_DEAMON_1, [?RICM_UNIT_DELAY_CHANGED_IND], 2*1000),
						case RecvResult of
							{error, timeout} ->
								ok;
							_ ->
								{ok, {_SenderPid, _SigNo, SigData}} = RecvResult,
								ct:pal("Received:~n~s", [osegw_lib:pretty_format(SigData, nci_bci_dci)]),
								ct:fail("Received unexpected RICM_UNIT_DELAY_CHANGED_IND")
						end;
					_ ->
						UnitDelayValues = get_expected_unit_delay_values(Radio),
						{ok, DelayInd} = nci_dci_actions:unit_delay_changed_ind(Radio ++ [{unitDelayValues, UnitDelayValues}]),

						ct:pal("Action_3"),
						verify_unit_delays(Radio, DelayInd)
				end,

				ct:pal("Action_4")
		end,
		Radios),

	ct:pal("Action_5"),
	ct:pal("1 min delay. Wait for RICM to calculate new delays"),
	timer:sleep(60 * 1000),

	lists:foreach(
		fun(Radio) ->
				ct:pal("Action_6"),
				case nci_ricm_utils:get_next_radio(Radio, Radios) of
					[] ->
						%% This is the last radio in the cascade chain. Don't attempt to receive any IND.
						ok;
					_ ->
						UnitDelayValues = get_expected_unit_delay_values(Radio),
						{ok, DelayInd} = nci_dci_actions:unit_delay_changed_ind(Radio ++ [{unitDelayValues, UnitDelayValues}]),

						ct:pal("Action_7"),
						verify_unit_delays(Radio, DelayInd)
				end,

				ct:pal("Action_8")
		end,
		Radios),

	stop_cpri_links(Radios),

	%% Check that NO BC/DC_FAULT_IND is generated
	nci_common_utils:check_outstanding_faults(2000).


%%------------------------------------------------------------------------------
%% $Id DCI_SUD2
%%
%% $Header
%%  DCI Subscribe Unit Delay - State Operational
%%
%% $Description
%%  Verify that RICM subscribe unit delay correctly in state Operational.
%%
%% $Requirements
%%  CBD_RICM_DCI_SUBSCRIBE_UNIT_DELAY-VALUE_FU:1A
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  At least 1 RU
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  The DU BC is in state operational.
%%  CPRI, O&M link is set up to all radios.
%%  Subscribe BCI&DCI fault.
%%
%% $Action_1
%%  Send a RICM_SUBSCRIBE_UNIT_DELAY_REQ with parameters:
%%  * unitId = <read from config file>
%%  * thresholdValue = 0
%%  
%% $Result_1
%%  A RICM_SUBSCRIBE_UNIT_DELAY_CFM is received with parameters:
%%  * unitId = <Same as in Action_1>
%%
%% $Action_2
%%  Receive a RICM_SUBSCRIBE_UNIT_DELAY_IND if this is not the last radio in the cascade chain
%%
%% $Result_2
%%  A RICM_SUBSCRIBE_UNIT_DELAY_IND is received with parameters:
%%  * unitId = <read from config file>
%%  * unitDelayValues = <consist of the delayParameterDataS of parameterId and delay values>
%%
%% $Action_3
%%  Verify the delays from Result_2
%%  
%% $Result_3
%%  The delays are within a 10ns interval
%%
%% $Action_4
%%  Repeat Action_1 to Action_2 for all remaining radios in the configuration
%%  
%% $Result_4
%%  -
%%
%% $Action_5
%%  Delay for 1 minute
%%  
%% $Result_5
%%  -
%%
%% $Action_6
%%  Receive a RICM_SUBSCRIBE_UNIT_DELAY_IND
%%
%% $Result_6
%%  A RICM_SUBSCRIBE_UNIT_DELAY_IND is received with parameters:
%%  * unitId = <read from config file>
%%  * unitDelayValues = <consist of the delayParameterDataS of parameterId and delay values>
%%
%% $Action_7
%%  Verify the delays from Result_1b
%%  
%% $Result_7
%%  The delays are within a 10ns interval
%%
%% $Action_8
%%  Repeat Action_5 to Action_6 for all remaining radios in the configuration
%%  
%% $Result_8
%%  -
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%% -
%%
%% Revision history:
%%   2014-04-02 ebacemi
%%     First version.
%%
%%-------------------------------------------------------------------------------
dci_sud2() ->
	[{userdata,[{wp, ""},
				{requirement, "CBD_RICM_DCI_SUBSCRIBE_UNIT_DELAY-VALUE_FU:1A"},
				{slogan, "DCI Subscribe Unit Delay - State Operational"},
				{hwConfig, hwConfigA}]}].

dci_sud2(_Config) ->
	ct:pal("dci_sud2"),

	dci_sud(operational).


%%------------------------------------------------------------------------------
%% $Id DCI_SUD3
%%
%% $Header
%%  DCI Subscribe Unit Delay - State Disabled
%%
%% $Description
%%  Subscribtion for unit delay in O&M state disabled should be disallowed.
%%
%% $Requirements
%%  CBD_RICM_DCI_SUBSCRIBE_UNIT_DELAY-VALUE_FU:1A
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  The DU BC is in state disabled.
%%  
%% $Action_1
%%  Send a RICM_SUBSCRIBE_UNIT_DELAY_REQ with parameters:
%%  * unitId = 1
%%
%% $Result_1
%%  A RICM_SUBSCRIBE_UNIT_DELAY_REJ is received with parameters:
%%  * unitId = 1
%%  * errorCode = ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL
%%  * errorDescription = "Invalid O&M state"
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%
%% Revision history:
%%  2014-02-019, EISMELE
%%    First version
%%
%%  2014-04-02, EBACEMI
%%    Revised the TC
%%------------------------------------------------------------------------------
dci_sud3() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_RICM_DCI_SUBSCRIBE_UNIT_DELAY-VALUE_FU:1A"},
				{slogan, "DCI Subscribe Unit Delay - State Disabled"}]}].

dci_sud3(_Config) ->
	ct:pal("dci_sdu3"), 

	set_state_and_connect(starting_lmc_loaded),
	nci_bci_states:set_state([{state, disabled}]),

	ct:pal("Action_1"), 
	nci_dci_actions:subscribe_unit_delay([{expectedSigNo, ?RICM_SUBSCRIBE_UNIT_DELAY_REJ},
										  {unitId, 1},
										  {errorCode, ?ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL},
										  {errorDescription, {regexp, "Invalid O&M state*"}}]),

	%% Check that NO BC/DC_FAULT_IND is generated
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id DCI_SUD4
%%
%% $Header
%%  DCI Subscribe Unit Delay - DP not loaded
%%
%% $Description
%%  Verify that it shall not be possible to subscribe unit delay when DP LMC is not loaded.
%%
%% $Requirements
%%  CBD_RICM_DCI_SUBSCRIBE_UNIT_DELAY-VALUE_FU:1A.
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state starting.
%%  Subscribe BCI&DCI fault.
%%  The DP is not loaded
%%
%% $Action
%%  Send a RICM_SUBSCRIBE_UNIT_DELAY_REQ with parameters:
%%  * unitId = 1
%%
%% $Result
%%  A RICM_SUBSCRIBE_UNIT_DELAY_REJ is received with parameters:
%%  * unitId = 1
%%  * errorCode = ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL
%%  * errorDescription = "DP not loaded"
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2014-02-19, EISMELE
%%    First version
%%
%%  2014-04-02, EBACEMI
%%    Revised the TC
%%
%%------------------------------------------------------------------------------
dci_sud4() ->
	[{userdata,[{wp, ""},
				{requirement, "CBD_RICM_DCI_SUBSCRIBE_UNIT_DELAY-VALUE_FU:1A"},
				{slogan, "DCI Subscribe Unit Delay - DP not loaded"}]}].

dci_sud4(_Config) ->
	ct:pal("dci_sud4"),

	set_state_and_connect( starting_lmc_not_loaded ),

	ok = nci_dci_actions:subscribe_faults([]),

	ct:pal("Action_1"),
	nci_dci_actions:subscribe_unit_delay([{expectedSigNo, ?RICM_SUBSCRIBE_UNIT_DELAY_REJ},
										  {unitId, 1},
										  {errorCode, ?ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL},
										  {errorDescription, {regexp, "DP not loaded*"}}]),

	%% Check that NO BC/DC_FAULT_IND is generated
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id DCI_SUD5
%%
%% $Header
%%  DCI Subscribe Unit Delay - unitId not in use.
%%
%% $Description
%%  Verify that Subscription of unit delay can not be made for a unitId that is not in use.
%%
%% $Requirements
%%   CBD_RICM_DCI_SUBSCRIBE_UNIT_DELAY-VALUE_FU:1A
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state starting.
%%  Subscribe BCI&DCI fault.
%%
%% $Action_1
%%  Send a RICM_SUBSCRIBE_UNIT_DELAY_REQ with parameters:
%%  * unitId = <0, 999>
%%
%% $Result_1
%%  A RICM_SUBSCRIBE_UNIT_DELAY_REJ is received with parameters:
%%  * unitId = <0, 999>
%%  * errorCode = ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL
%%  * errorDescription = "unitId not in use"
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%
%% Revision history:
%%  2014-02-19, EISMELE
%%    First version
%%
%%  2014-04-02, EBACEMI
%%    Revised the TC
%%
%%------------------------------------------------------------------------------
dci_sud5() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_RICM_DCI_SUBSCRIBE_UNIT_DELAY-VALUE_FU:1A"},
				{slogan, "DCI Subscribe Unit Delay - unitId not in use."}]}].

dci_sud5(_Config) ->
	ct:pal("dci_sud5"),

	set_state_and_connect( starting_lmc_loaded ),

	ok = nci_dci_actions:subscribe_faults([]),
	
	ct:pal("Action_1"),
	lists:foreach(
		fun(UnitId) ->
				nci_dci_actions:subscribe_unit_delay([{expectedSigNo, ?RICM_SUBSCRIBE_UNIT_DELAY_REJ},
													  {unitId, UnitId},
													  {errorCode, ?ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL},
													  {errorDescription, {regexp, "unitId not in use*"}}])
		end,
		[0, 999]),

	%% Check that NO BC/DC_FAULT_IND is generated
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id DCI_SUD6
%%
%% $Header
%%  DCI Subscribe Unit Delay - O&M link is not setup
%%
%% $Description
%%  Verify that it shall not be possible to subscribe unit delay when O&M Link is not setup.
%%
%% $Requirements
%%  CBD_RICM_DCI_SUBSCRIBE_UNIT_DELAY-VALUE_FU:1:A
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  At least 1 RU
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state starting.
%%  Subscribe BCI&DCI fault.
%%  CPRI but not O&M link is set up to first radio.
%%
%% $Action_1
%%  Send a RICM_SUBSCRIBE_UNIT_DELAY_REQ with parameters:
%%  * unitId = <read from config file>
%%
%% $Result_1
%%  A RICM_SUBSCRIBE_UNIT_DELAY_REJ is received with parameters:
%%  * unitId = <read from config file>
%%  * errorCode = ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL
%%  * errorDescription = "Invalid O&M link"
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%
%% Revision history:
%%  2014-02-19, EISMELE
%%    First version
%%
%%  2014-04-02, EBACEMI
%%    Revised the TC
%%
%%------------------------------------------------------------------------------
dci_sud6() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_RICM_DCI_SUBSCRIBE_UNIT_DELAY-VALUE_FU:1:A"},
				{slogan, "DCI Subscribe Unit Delay - O&M link is not setup"},
				{hwConfig, hwConfigA}]}].

dci_sud6(_Config) ->
	ct:pal("dci_sud6"),

	set_state_and_connect( starting_lmc_loaded ),

	ok = nci_dci_actions:subscribe_faults([]),

	Radio = nci_ricm_utils:get_first_radio(),

	start_cpri_link(Radio),

	ct:pal("Action_1"),
	nci_dci_actions:subscribe_unit_delay(Radio ++ [{expectedSigNo, ?RICM_SUBSCRIBE_UNIT_DELAY_REJ},
												   {errorCode, ?ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL},
												   {errorDescription, {regexp, "Invalid O&M link*"}}]),

	stop_cpri_link(Radio),

	%% Check that NO BC/DC_FAULT_IND is generated
	nci_common_utils:check_outstanding_faults(2000).


%%------------------------------------------------------------------------------
%% $Id DCI_SUD7
%%
%% $Header
%%  DCI Subscribe Unit Delay - Restart radio
%%
%% $Description
%%  Verify that RICM reports correct unit delays after a radio restart
%%
%% $Requirements
%%  CBD_RICM_DCI_SUBSCRIBE_UNIT_DELAY-VALUE_FU:1A
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  At least 1 RU
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  The DU BC is in state starting.
%%  CPRI, O&M link is set up to all radios.
%%  Subscribe BCI&DCI fault.
%%  Unit delay subscription performed for all radios.
%%
%% $Action_1
%%  Restart the radio if it's not the last radio in the cascade chain
%%  
%% $Result_1
%%  Radio is restarted and all indications received
%%
%% $Action_2
%%  Receive a RICM_SUBSCRIBE_UNIT_DELAY_IND signal
%%
%% $Result_2
%%  A RICM_SUBSCRIBE_UNIT_DELAY_IND is received with parameters:
%%  * unitId = <read from configuration>
%%  * unitDelayValues = <consist of the delayParameterDataS of parameterId and delay values>
%%
%% $Action_3
%%  Verify the delays from Result_2
%%  
%% $Result_3
%%  The delays are within a 10ns interval
%%
%% $Action_4
%%  Repeat Action_1 to Action_3 for all remaining radios in the cascade chain
%%  
%% $Result_4
%%  -
%%
%% $Action_5
%%  Repeat Action_1 to Action_4 for all remaining radios in the configuration
%%  
%% $Result_5
%%  -
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%% -
%%
%% Revision history:
%%   2014-04-09 ebacemi
%%     First version.
%%
%%--------------------------------------------------------------------------------
dci_sud7() ->
	[{userdata,[{wp, ""},
				{requirement, "CBD_RICM_DCI_SUBSCRIBE_UNIT_DELAY-VALUE_FU:1A"},
				{slogan, "DCI Subscribe Unit Delay - Restart radio"},
				{hwConfig, hwConfigA}]}].

dci_sud7(_Config) ->
	ct:pal("dci_sud7"),
	
	set_state_and_connect( starting_lmc_loaded ),

	ok = nci_dci_actions:subscribe_faults([]),

	Radios = nci_ricm_utils:get_all_radios(),
	
	start_cpri_and_oam_links(Radios),

	lists:foreach(
		fun(Radio) ->
				ok = nci_dci_actions:subscribe_unit_delay(Radio ++ [{thresholdValue, 0}]),
				case nci_ricm_utils:get_next_radio(Radio, Radios) of
					[] ->
						ok;
					_ ->
						{ok, _} = nci_dci_actions:unit_delay_changed_ind(Radio)
				end
		end,
		Radios),

	lists:foreach(
		fun(Radio) ->
				CascadedRadios = nci_ricm_utils:get_all_cascaded_radios_from_radio(Radio, Radios),

				case nci_ricm_utils:get_next_radio(Radio, CascadedRadios) of
					[] ->
						%% No need to restart the last radio in the cascade chain
						ok;
					_ ->
						ct:pal("Action_1"),
						restart_ru(Radio),
						cascade_restart_ru_post_signals(Radio, CascadedRadios, false, 1),

						%% Get all next cascaded radios except for the last one
						NextCascadedRadios = nci_ricm_utils:get_all_next_cascaded_radios(Radio, CascadedRadios) -- [lists:last(CascadedRadios)],

						lists:foreach(
							fun(RU) ->
									UnitDelayValues = get_expected_unit_delay_values(RU),

									ct:pal("Action_2"),
									{ok, DelayInd} = nci_dci_actions:unit_delay_changed_ind(RU ++ [{unitDelayValues, UnitDelayValues}]),

									ct:pal("Action_3"),
									verify_unit_delays(RU, DelayInd),

									ct:pal("Action_4")
							end,
							[Radio] ++ NextCascadedRadios),

						ct:pal("Action_5")
				end
		end,
		Radios),

	stop_cpri_links(Radios),
    
	%% Check that NO BC/DC_FAULT_IND is generated
	nci_common_utils:check_outstanding_faults(2000).


%%------------------------------------------------------------------------------
%% $Id DCI_SUD8
%%
%% $Header
%%  DCI Subscribe Unit Delay - DU unit delays
%%
%% $Description
%%  Verify that RICM reports correct unit delays for the DU
%%
%% $Requirements
%%  CBD_RICM_DCI_SUBSCRIBE_UNIT_DELAY-VALUE_FU:1A
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  The DU BC is in state starting.
%%  Subscribe BCI&DCI fault.
%%  Set DU unit id to the default ID.
%%
%% $Action_1
%%  Send a RICM_SUBSCRIBE_UNIT_DELAY_REQ with parameters:
%%  * unitId = <id of the DU>
%%  * thresholdValue = 0
%%  
%% $Result_1a
%%  A RICM_SUBSCRIBE_UNIT_DELAY_CFM is received with parameters:
%%  * unitId = <id of the DU>
%%
%% $Result_1b
%%  A RICM_SUBSCRIBE_UNIT_DELAY_IND is received with parameters:
%%  * unitId = <id of the DU>
%%  * unitDelayValues = <consist of the delayParameterDataS of parameterId and delay values>
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%% -
%%
%% Revision history:
%%   2014-04-11 ebacemi
%%     First version.
%%
%%--------------------------------------------------------------------------------
dci_sud8() ->
	[{userdata,[{wp, ""},
				{requirement, "CBD_RICM_DCI_SUBSCRIBE_UNIT_DELAY-VALUE_FU:1A"},
				{slogan, "DCI Subscribe Unit Delay - DU unit delays"}]}].

dci_sud8(_Config) ->
	ct:pal("dci_sud8"),
	
	set_state_and_connect( starting_lmc_loaded ),

	ok = nci_dci_actions:subscribe_faults([]),

	ok = nci_dci_actions:set_du_unit_id([{unitId, ?UNIT_ID_DU1}]),

	LRATIcmDelay =
		#'Ricm_LratIcmDelay'{dl = 0,
							 ul = 0,
							 has_dl = 1,
							 has_ul = 1},

	UnitDelayValues = 
		#'RicmDelayParametersS'{cpriLinkDelay = '_',
								lratIcmDelay = LRATIcmDelay,
								wratIcmDelay = '_',
								gratIcmDelay = '_',
								cpriPartnerDelayList_count = 0,
								cpriPartnerDelayList = '_',
								cascadePortDelayList_count = 0,
								cascadePortDelayList = '_',
								bfnCompensationList_count = 0,
								bfnCompensationList = '_',
								has_cpriLinkDelay = 0,
								has_lratIcmDelay = 1,
								has_wratIcmDelay = 0,
								has_gratIcmDelay = 0
							   },

	ct:pal("Action_1"),
	ok = nci_dci_actions:subscribe_unit_delay([{unitId, ?UNIT_ID_DU1},
											   {thresholdValue, 0}]),
	{ok, _} = nci_dci_actions:unit_delay_changed_ind([{unitId, ?UNIT_ID_DU1},
													  {unitDelayValues, UnitDelayValues}]),

	%% Check that NO BC/DC_FAULT_IND is generated
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id DCI_SUD9
%%
%% $Header
%%  DCI Subscribe Unit Delay - Subscribe before setting up cascaded radios
%%
%% $Description
%%  Verify that RICM reports correct unit delays when performing this sequence:
%%  1. Start CPRI and O&M to the radio
%%  2. Subscribe for unit delays
%%  3. Start CPRI and O&M to the second radio
%%  4. Subscribe for unit delays
%%  And so forth
%%
%% $Requirements
%%  CBD_RICM_DCI_SUBSCRIBE_UNIT_DELAY-VALUE_FU:1A
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  At least 2 cascaded radios
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  The DU BC is in state starting.
%%  Subscribe BCI&DCI fault.
%%
%% $Action_1
%%  Start CPRI and O&M to the radio
%%  
%% $Result_1
%%  CPRI and O&M started
%%
%% $Action_2
%%  Send a RICM_SUBSCRIBE_UNIT_DELAY_REQ with parameters:
%%  * unitId = <read from config file>
%%  * thresholdValue = 0
%%  
%% $Result_2
%%  A RICM_SUBSCRIBE_UNIT_DELAY_CFM is received with parameters:
%%  * unitId = <Same as in Action_1>
%%
%% $Action_2
%%  Receive a RICM_SUBSCRIBE_UNIT_DELAY_IND signal
%%
%% $Action_3
%%  Receive a RICM_SUBSCRIBE_UNIT_DELAY_IND that corresponds to the previous radio
%%  in the cascade chain. If no previous radios exists, no IND shall be received.
%%
%% $Result_3
%%  A RICM_SUBSCRIBE_UNIT_DELAY_IND is received with parameters:
%%  * unitId = <read from config file>
%%  * unitDelayValues = <consist of the delayParameterDataS of parameterId and delay values>
%%
%% $Action_4
%%  Verify the delays from Result_3
%%  
%% $Result_4
%%  The delays are within a 10ns interval
%%
%% $Action_5
%%  Repeat Action_1 to Action_4 for all remaining radios in the configuration
%%  
%% $Result_5
%%  -
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%% -
%%
%% Revision history:
%%   2014-04-09 ebacemi
%%     First version.
%%
%%--------------------------------------------------------------------------------
dci_sud9() ->
	[{userdata,[{wp, ""},
				{requirement, "CBD_RICM_DCI_SUBSCRIBE_UNIT_DELAY-VALUE_FU:1A"},
				{slogan, "DCI Subscribe Unit Delay - Subscribe before setting up cascaded radios"},
				{hwConfig, hwConfigB}]}].

dci_sud9(_Config) ->
	ct:pal("dci_sud9"),
	
	set_state_and_connect( starting_lmc_loaded ),

	ok = nci_dci_actions:subscribe_faults([]),

	Radios = nci_ricm_utils:get_all_radios(),

	lists:foreach(
		fun(Radio) ->
				CascadedRadios = nci_ricm_utils:get_all_cascaded_radios_from_radio(Radio, Radios),

				%% Only test cascade chains with 2 or more radios
				if length(CascadedRadios) >= 2 ->
						ct:pal("Action_1"),
						start_cpri_and_oam_link(Radio),

						ct:pal("Action_2"),
						ok = nci_dci_actions:subscribe_unit_delay(Radio ++ [{thresholdValue, 0}]),

						ct:pal("Action_3"),
						PreviousRadio = nci_ricm_utils:get_previous_radio(Radio, Radios),
						case PreviousRadio of
							[] ->
								ct:pal("This is the first radio in the cascade chain.~n"
									   "RICM should send no IND:s since no cascaded links are started at this point"),
								RecvResult = osegw:recv(?OSE_GW_DEAMON_1, [?RICM_UNIT_DELAY_CHANGED_IND], 2*1000),
								case RecvResult of
									{error, timeout} ->
										ok;
									_ ->
										{ok, {_SenderPid, _SigNo, SigData}} = RecvResult,
										ct:pal("Received:~n~s", [osegw_lib:pretty_format(SigData, nci_bci_dci)]),
										ct:fail("Received unexpected RICM_UNIT_DELAY_CHANGED_IND")
								end;
							_ ->
								UnitDelayValues = get_expected_unit_delay_values(PreviousRadio),
								{ok, DelayInd} = nci_dci_actions:unit_delay_changed_ind(PreviousRadio ++ [{unitDelayValues, UnitDelayValues}]),

								ct:pal("Action_4"),
								verify_unit_delays(PreviousRadio, DelayInd)
						end,

						ct:pal("Action_5");
				   true ->
						%% The cascade chain only contains one radio. Skip it
						ok
				end
		end,
		Radios),

	stop_cpri_links(Radios),
    
	%% Check that NO BC/DC_FAULT_IND is generated
	nci_common_utils:check_outstanding_faults(2000).


%%------------------------------------------------------------------------------
%% $Id DCI_SCLD5
%%
%% $Header
%%  Time Alignment Subscribe Cable Delay linkId not in use
%%
%% $Description
%%  Verify Time Alignment Subscribe CPRI Link Delay linkId not in use
%%
%% $Requirements
%%   CBD_RICM_DCI-SUBSCRIBE-CABLE-DELAY_FU:1:A
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  The DU BC is in state starting.
%%  Subscribe BCI&DCI fault.
%%
%% $Action_1
%%   RICM_SUBSCRIBE_CPRI_LINK_DELAY_REQ
%%     linkId = 1
%%
%% $Result_1
%%   RICM_SUBSCRIBE_CPRI_LINK_DELAY_REJ
%%     linkId = 1
%%     errorCode = ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL
%%     errorDescription = unitId not in use*
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%
%% Revision history:
%%  2014-02-27, ejonuna
%%    First version
%%
%%  2014-04-24, uabpar
%%    Second revision
%%
%%------------------------------------------------------------------------------
dci_scld5() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_RICM_DCI-SUBSCRIBE-CABLE-DELAY_FU:1:A"},
				{slogan, "Time Alignment Subscribe CPRI Link Delay linkId not in use"}]}].

dci_scld5(_Config) ->
	ct:pal("dci_scld5"),

	set_state_and_connect( starting_lmc_loaded ),

	ct:pal("Action_1 & Result_1"),
	ok = nci_dci_actions:subscribe_cpri_link_delay([{linkId, 1},
												{expectedSigNo, ?RICM_SUBSCRIBE_CPRI_LINK_DELAY_REJ},
												{errorCode, ?ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL},
												{errorDescription, {regexp, "linkId not in use*"}}]),

	%% Check that NO BC/DC_FAULT_IND is generated
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id DCI_SCLD6
%%
%% $Header
%%  Time Alignment Subscribe Cpri Link Delay invalid O&M link
%%
%% $Description
%%  Verify Time Alignment Subscribe Cpri Link Delay invalid O&M link
%%
%% $Requirements
%%   CBD_RICM_DCI-SUBSCRIBE-CABLE-DELAY_FU:1:A
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  The DU BC is in state starting.
%%  Subscribe BCI&DCI fault.
%%  CPRI link started to one radio
%%
%% $Action_1
%%   RICM_SUBSCRIBE_CPRI_LINK_DELAY_REQ
%%     linkId = 1
%%
%% $Result_1
%%   RICM_SUBSCRIBE_CPRI_LINK_DELAY_REJ
%%     linkId = 1
%%     errorCode = ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL
%%     errorDescription = Invalid O&M link*
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%
%% Revision history:
%%  2014-02-27, ejonuna
%%    First version
%%
%%  2014-04-24, uabpar
%%    Second revision
%%
%%
%%------------------------------------------------------------------------------
dci_scld6() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_RICM_DCI-SUBSCRIBE-CABLE-DELAY_FU:1:A"},
				{slogan, "Time Alignment Subscribe Cable Delay invalid O&M link"}]}].

dci_scld6(_Config) ->
	ct:pal("dci_scld6"),

	set_state_and_connect( starting_lmc_loaded ),

	Radio = nci_ricm_utils:get_first_radio(),

	%% Start CPRI
	ok = nci_dci_actions:start_cpri_link(Radio),
	ok = nci_dci_actions:cpri_link_ind(Radio ++ [{availStatus, 1}]),


	ct:pal("Action_1 & Result_1"),
	ok = nci_dci_actions:subscribe_cpri_link_delay([{linkId, 1},
												{expectedSigNo, ?RICM_SUBSCRIBE_CPRI_LINK_DELAY_REJ},
												{errorCode, ?ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL},
												{errorDescription, {regexp, "Invalid O&M link*"}}]),

	%% Reset CPRI Link
	ok = nci_dci_actions:reset_cpri_link(Radio),
	ok = nci_dci_actions:reset_cpri_link_ind(Radio),

	%% Check that NO BC/DC_FAULT_IND is generated
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id DCI_SCLD7
%%
%% $Header
%%  Time Alignment Subscribe CPRI Link Delay DP not loaded
%%
%% $Description
%%  Verify Time Alignment Subscribe CPRI Link Delay DP not loaded
%%
%% $Requirements
%%   CBD_RICM_DCI-SUBSCRIBE-CABLE-DELAY_FU:1:A
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  The DU BC is in state starting.
%%  Subscribe BCI&DCI fault.
%%
%% $Action_1
%%   RICM_SUBSCRIBE_CPRI_LINK_DELAY_REQ
%%     linkId = 1
%%
%% $Result_1
%%   RICM_SUBSCRIBE_CPRI_LINK_DELAY_REJ
%%     linkId = 1
%%     errorCode = ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL
%%     errorDescription = DP not loaded*
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%
%% Revision history:
%%  2014-02-27, ejonuna
%%    First version
%%
%%  2014-04-24, uabpar
%%    Second revision
%%
%%
%%------------------------------------------------------------------------------
dci_scld7() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_RICM_DCI-SUBSCRIBE-CABLE-DELAY_FU:1:A"},
				{slogan, "Time Alignment Subscribe Cable Delay DP not loaded"}]}].

dci_scld7(_Config) ->
	ct:pal("dci_scld7"),

	set_state_and_connect( starting_lmc_not_loaded ),

	ct:pal("Action_1 & Result_1"),
	ok = nci_dci_actions:subscribe_cpri_link_delay([{linkId, 1},
												{expectedSigNo, ?RICM_SUBSCRIBE_CPRI_LINK_DELAY_REJ},
												{errorCode, ?ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL},
												{errorDescription, {regexp, "DP not loaded*"}}]),

	%% Check that NO BC/DC_FAULT_IND is generated
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id DCI_SCL1
%%
%% $Header
%%  State Starting
%%
%% $Description
%%  Verify start CPRI link in state starting.
%%
%% $Requirements
%%  CBD_RICM_DCI-START-CPRI-LINK_FU:1:C
%%
%%  CBD_RICM_START-CPRI_FU:1:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  The DU BC is in state starting.
%%
%%  CPRI Link is not up for ruId 1, port 1 and cascade 1
%%
%% $Action
%%  Send a START_CPRI_LINK_REQ with parameters:
%%
%%  ruId = 1
%%
%%  port = 1
%%
%%  cascade = 1
%%
%%  primary = 1
%%
%% $Result
%%  A START_CPRI_LINK_CFM is received with parameters:
%%
%%  ruId = 1
%%
%% $Result
%%  A START_CPRI_LINK_IND is received with parameters:
%%
%%  ruId = 1
%%
%%  typeOfUnit = <ignored>
%%
%%  availStatus = 1
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  2012-10-15, EJOJUNA
%%
%% Revision history:
%%  2012-05-30, QMAGSED
%%    First version
%%
%%  2012-10-16, EEDAJA
%%    Minor changes after review comments
%%
%%------------------------------------------------------------------------------
dci_scl1() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_RICM_DCI-START-CPRI-LINK_FU:1:C, CBD_RICM_START-CPRI_FU:1:C"},
				{slogan, "Verify start CPRI link in state starting"},
				{hwConfig, hwConfigA}]}].

dci_scl1(_Config) ->
	ct:pal("dci_scl1"),

	% Set state, make audit, establish BCI and DCI connections, subscribe BCI faults
	set_state_and_connect( starting_lmc_loaded ),

	Radio1 = nci_ricm_utils:get_first_radio(),

	%% Start CPRI
	ok = nci_dci_actions:start_cpri_link(Radio1),
	ok = nci_dci_actions:cpri_link_ind(Radio1 ++ [{availStatus, 1}]),

	%% Reset CPRI Link
	ok = nci_dci_actions:reset_cpri_link(Radio1),
	ok = nci_dci_actions:reset_cpri_link_ind(Radio1),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).


%%------------------------------------------------------------------------------
%% $Id DCI_SCL2
%%
%% $Header
%%  State Operational
%%
%% $Description
%%  Verify start CPRI link in state operational.
%%
%% $Requirements
%%  CBD_RICM_DCI-START-CPRI-LINK_FU:1:C
%%
%%  CBD_RICM_START-CPRI_FU:1:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state operational.
%%
%%  CPRI Link is not up for ruId 1, port 4 and cascade 1
%%
%% $Action_1
%%  Send a START_CPRI_LINK_REQ with parameters:
%%
%%  ruId = 1
%%
%%  port = 1
%%
%%  cascade = 1
%%
%%  primary = 1
%%
%% $Result_1
%%  A START_CPRI_LINK_CFM is received with parameters:
%%
%%  ruId = 1
%%
%% $Result
%%  A START_CPRI_LINK_IND is received with parameters:
%%
%%  ruId = 1
%%
%%  typeOfUnit = <ignored>
%%
%%  availStatus = 1
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  2012-10-15, EJOJUNA
%%
%% Revision history:
%%  2012-05-30, QMAGSED
%%    First version
%%
%%  2012-10-16, EEDAJA
%%    Minor changes after review comments
%%
%%------------------------------------------------------------------------------
dci_scl2() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_RICM_DCI-START-CPRI-LINK_FU:1:C, CBD_RICM_START-CPRI_FU:1:C"},
				{slogan, "Verify start CPRI link in state operational"},
				{hwConfig, hwConfigA}]}].

dci_scl2(_Config) ->
	ct:pal("dci_scl2"),

	% Set state, make audit, establish BCI and DCI connections, subscribe BCI faults
	set_state_and_connect( operational ),

	Radio1 = nci_ricm_utils:get_first_radio(),

	%% Start CPRI
	ok = nci_dci_actions:start_cpri_link(Radio1),
	ok = nci_dci_actions:cpri_link_ind(Radio1 ++ [{availStatus, 1}]),

	%% Reset CPRI Link
	ok = nci_dci_actions:reset_cpri_link(Radio1),
	ok = nci_dci_actions:reset_cpri_link_ind(Radio1),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id DCI_SCL3
%%
%% $Header
%%  State Disabled
%%
%% $Description
%%  Verify start CPRI link in state disabled
%%
%% $Requirements
%%  CBD_RICM_DCI-START-CPRI-LINK_FU:1:C
%%
%%  CBD_RICM_START-CPRI_FU:1:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state disabled
%%
%%  CPRI Link is not up for ruId 1, port 4 and cascade 1
%%
%% $Action_1
%%  Send a START_CPRI_LINK_REQ with parameters:
%%
%%  ruId = 1
%%
%%  port = 4
%%
%%  cascade = 1
%%
%%  primary = 1
%%
%% $Result_1
%%  A START_CPRI_LINK_REJ is received with parameters:
%%
%%  ruId = 1
%%
%%  errorCode = UNSUCCESSFUL
%%
%%  errorDescription = "Invalid O&M state"
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-10-04, EEDAJA
%%    First version
%%
%%------------------------------------------------------------------------------
dci_scl3() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_RICM_DCI-START-CPRI-LINK_FU:1:C, CBD_RICM_START-CPRI_FU:1:C"},
				{slogan, "State Disabled"},
				{hwConfig, hwConfigA}]}].

dci_scl3(_Config) ->
	ct:pal("dci_scl3"),

	% Set state, make audit, establish BCI and DCI connections, subscribe BCI faults
	set_state_and_connect( starting_lmc_loaded ),

	nci_bci_states:set_state([{state, disabled}]),

	%% Start CPRI
	ct:pal("Action_1"),
	ok = nci_dci_actions:start_cpri_link([{expectedSigNo, ?RICM_START_CPRI_LINK_REJ},
										  {errorCode, 1},
										  {errorDescription, {regexp, "Invalid O&M state*"}}]),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id DCI_SCL4
%%
%% $Header
%%  Unused Cascade No
%%
%% $Description
%%  Verify start CPRI link for an unused cascade no.
%%
%% $Requirements
%%  CBD_RICM_DCI-START-CPRI-LINK_FU:1:C
%%
%%  CBD_RICM_START-CPRI_FU:1:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state starting.
%%
%%  RRU on cascade no 2 on port 1 is not available
%%
%% $Action_1
%%  Send a START_CPRI_LINK_REQ with parameters:
%%
%%  ruId = 1
%%
%%  port = 4
%%
%%  cascade = 2
%%
%%  primary = 1
%%
%% $Result_1
%%  A START_CPRI_LINK_REJ is received with parameters:
%%
%%  ruId = 1
%%
%%  errorCode = UNSUCCESSFUL
%%
%%  errorDescription = "Invalid cascadeNo"
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-10-08, EEDAJA
%%    First version
%%
%%------------------------------------------------------------------------------
dci_scl4() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_RICM_DCI-START-CPRI-LINK_FU:1:C, CBD_RICM_START-CPRI_FU:1:C"},
				{slogan, "Unused cascade number"},
				{hwConfig, hwConfigA}]}].

dci_scl4(_Config) ->
	ct:pal("dci_scl4"),

	% Set state, make audit, establish BCI and DCI connections, subscribe BCI faults
	set_state_and_connect( starting_lmc_loaded ),

	%% Start CPRI with erroneous input parameters
	ct:pal("Action_1"),

	Radios = nci_ricm_utils:get_all_radios(),

	NotConfiguredRu = case nci_common_utils:get_du() of

		mRBS_lte ->
			nci_ricm_utils:get_unconfigured_cascaded_ru(Radios, [3,4]);

		_ ->
			nci_ricm_utils:get_unconfigured_cascaded_ru(Radios, [1,2,3,4,5,6])
		end,

	ok = nci_dci_actions:start_cpri_link(NotConfiguredRu ++ [
										  {expectedSigNo, ?RICM_START_CPRI_LINK_REJ},
										  {errorCode, 1},
										  {errorDescription, {regexp, "Cascaded RE chain not connected*"}}]),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id DCI_SCL5
%%
%% $Header
%%  Invalid Parameters
%%
%% $Description
%%  Verify start CPRI link with invalid parameters.
%%
%% $Requirements
%%  CBD_RICM_DCI-START-CPRI-LINK_FU:1:C
%%
%%  CBD_RICM_START-CPRI_FU:1:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state starting.
%%
%%  CPRI Link is not up for ruId 1, port 1 and cascade 1
%%
%% $Action_1
%%  Send a START_CPRI_LINK_REQ with parameters:
%%
%%  ruId = 1
%%
%%  port = 0
%%
%%  cascade = 1
%%
%%  primary = 1
%%
%% $Result_1
%%  A START_CPRI_LINK_REJ is received with parameters:
%%
%%  ruId = 1
%%
%%  errorCode = UNSUCCESSFUL
%%
%%  errorDescription = "Invalid portNo"
%%
%% $Action_2
%%  Send a START_CPRI_LINK_REQ with parameters:
%%
%%  ruId = 1
%%
%%  port = 7
%%
%%  cascade = 1
%%
%%  primary = 1
%%
%% $Result_2
%%  A START_CPRI_LINK_REJ is received with parameters:
%%
%%  ruId = 1
%%
%%  errorCode = UNSUCCESSFUL
%%
%%  errorDescription = "Invalid portNo"
%%
%% $Action_3
%%  Send a START_CPRI_LINK_REQ with parameters:
%%
%%  ruId = 1
%%
%%  port = 4
%%
%%  cascade = 0
%%
%%  primary = 1
%%
%% $Result_3
%%  A START_CPRI_LINK_REJ is received with parameters:
%%
%%  ruId = 1
%%
%%  errorCode = UNSUCCESSFUL
%%
%%  errorDescription = "Invalid cascadeNo"
%%
%% $Action_4
%%  Send a START_CPRI_LINK_REQ with parameters:
%%
%%  ruId = 1
%%
%%  port = 4
%%
%%  cascade = 7
%%
%%  primary = 1
%%
%% $Result_4
%%  A START_CPRI_LINK_REJ is received with parameters:
%%
%%  ruId = 1
%%
%%  errorCode = UNSUCCESSFUL
%%
%%  errorDescription = "Invalid cascadeNo"
%%
%% $Action_5
%%  Send a START_CPRI_LINK_REQ with parameters:
%%
%%  ruId = 1
%%
%%  port = 4
%%
%%  cascade = 1
%%
%%  primary = 3
%%
%% $Result_5
%%  A START_CPRI_LINK_REJ is received with parameters:
%%
%%  ruId = 1
%%
%%  errorCode = UNSUCCESSFUL
%%
%%  errorDescription = "Invalid primary"
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-10-08, EEDAJA
%%    First version
%%
%%------------------------------------------------------------------------------
dci_scl5() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_RICM_DCI-START-CPRI-LINK_FU:1:C, CBD_RICM_START-CPRI_FU:1:C"},
				{slogan, "State Operational"},
				{hwConfig, hwConfigA}]}].

dci_scl5(_Config) ->
	ct:pal("dci_scl5"),

	% Set state, make audit, establish BCI and DCI connections, subscribe BCI faults
	set_state_and_connect( operational ),

	%% Start CPRI with erroneous input parameters
	ct:pal("Action_1"),

	Radio1 = nci_ricm_utils:get_first_radio(),

	Radio2 = proplists:delete(portNo,Radio1) ++ [{portNo,0}],

	ok = nci_dci_actions:start_cpri_link(Radio2 ++ [
											{expectedSigNo, ?RICM_START_CPRI_LINK_REJ},
											{errorCode, 1},
											{errorDescription, {regexp, "Invalid portNo*"}}]),

	ct:pal("Action_2"),

	Radio3 = proplists:delete(portNo,Radio1) ++ [{portNo,7}],

	ok = nci_dci_actions:start_cpri_link(Radio3 ++ [
										  {expectedSigNo, ?RICM_START_CPRI_LINK_REJ},
										  {errorCode, 1},
										  {errorDescription, {regexp, "Invalid portNo*"}}]),

	ct:pal("Action_3"),
	Radio4 = proplists:delete(cascadeNo,Radio1) ++ [{cascadeNo,0}],

	ok = nci_dci_actions:start_cpri_link(Radio4 ++ [
										  {expectedSigNo, ?RICM_START_CPRI_LINK_REJ},
										  {errorCode, 1},
										  {errorDescription, {regexp, "Invalid cascadeNo*"}}]),

	ct:pal("Action_4"),
	Radio5 = proplists:delete(cascadeNo,Radio1) ++ [{cascadeNo,7}],

	ok = nci_dci_actions:start_cpri_link(Radio5 ++ [
										  {expectedSigNo, ?RICM_START_CPRI_LINK_REJ},
										  {errorCode, 1},
										  {errorDescription, {regexp, "Invalid cascadeNo*"}}]),

	ct:pal("Action_5"),
	Radio6 = proplists:delete(primary,Radio1) ++ [{primary,3}],

	ok = nci_dci_actions:start_cpri_link(Radio6 ++ [
										  {expectedSigNo, ?RICM_START_CPRI_LINK_REJ},
										  {errorCode, 1},
										  {errorDescription, {regexp, "Invalid primary*"}}]),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id DCI_SCL7
%%
%% $Header
%%  Already Started
%%
%% $Description
%%  Verify start CPRI link when the link is already started
%%
%% $Requirements
%%  CBD_RICM_DCI-START-CPRI-LINK_FU:1:C
%%
%%  CBD_RICM_START-CPRI_FU:1:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state starting.
%%
%%  CPRI Link is up for ruId 1, port 4 and cascade 1
%%
%% $Action_1
%%  Send a START_CPRI_LINK_REQ with parameters:
%%
%%  ruId = 1
%%
%%  port = 4
%%
%%  cascade = 1
%%
%%  primary = 1
%%
%% $Result_1
%%  A START_CPRI_LINK_REJ is received with parameters:
%%
%%  ruId = 1
%%
%%  errorCode = UNSUCCESSFUL
%%
%%  errorDescription = "ruId already in use"
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-10-08, EEDAJA
%%    First version
%%
%%------------------------------------------------------------------------------
dci_scl7() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_RICM_DCI-START-CPRI-LINK_FU:1:C, CBD_RICM_START-CPRI_FU:1:C"},
				{slogan, "CPRI link is already started"},
				{hwConfig, hwConfigA}]}].

dci_scl7(_Config) ->
	ct:pal("dci_scl7"),

	% Set state, make audit, establish BCI and DCI connections, subscribe BCI faults
	set_state_and_connect( operational ),

	Radio1 = nci_ricm_utils:get_first_radio(),

	%% Start CPRI
	ct:pal("Action_1"),
	ok = nci_dci_actions:start_cpri_link(Radio1),
	ok = nci_dci_actions:cpri_link_ind(Radio1 ++ [{availStatus, 1}]),

	%% Start CPRI, already up
	ok = nci_dci_actions:start_cpri_link(Radio1),
	ok = nci_dci_actions:cpri_link_ind(Radio1 ++ [{availStatus, 1}]),

	%% Reset CPRI Link
	ok = nci_dci_actions:reset_cpri_link(Radio1),
	ok = nci_dci_actions:reset_cpri_link_ind(Radio1),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id DCI_SCL9
%%
%% $Header
%%  DP Not Loaded
%%
%% $Description
%%  Verify start CPRI link when DP is not loaded
%%
%% $Requirements
%%  CBD_RICM_DCI-START-CPRI-LINK_FU:1:C
%%
%%  CBD_RICM_START-CPRI_FU:1:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state starting.
%%
%%  The DP LMC is not loaded.
%%
%%  CPRI Link is not up for ruId 1, port 4 and cascade 1
%%
%% $Action_1
%%  Send a START_CPRI_LINK_REQ with parameters:
%%
%%  ruId = 1
%%
%%  port = 4
%%
%%  cascade = 1
%%
%%  primary = 1
%%
%% $Result_1
%%  A START_CPRI_LINK_REJ is received with parameters:
%%
%%  ruId = 1
%%
%%  errorCode = UNSUCCESSFUL
%%
%%  errorDescription = "DP not loaded"
%%
%% $Action_2
%%  Send a BC_LOAD_LMC_REQ with parameters:
%%
%%  loadModule = <Name of the LMC>
%%
%%  searchPath = <The directory it resides in on MP>
%%
%% $Result_2
%%  A BC_LOAD_LMC_CFM is received.
%%
%% $Action_3
%%  Send a START_CPRI_LINK_REQ with parameters:
%%
%%  ruId = 1
%%
%%  port = 4
%%
%%  cascade = 1
%%
%%  primary = 1
%%
%% $Result_3_1
%%  A START_CPRI_LINK_CFM is received with parameters:
%%
%%  ruId = 1
%%
%% $Result_3_2
%%  A START_CPRI_LINK_IND is received with parameters:
%%
%%  ruId = 1
%%
%%  typeOfUnit = 0
%%
%%  availStatus = 1
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-10-04, EEDAJA
%%    First version
%%
%%------------------------------------------------------------------------------
dci_scl9() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_RICM_DCI-START-CPRI-LINK_FU:1:C, CBD_RICM_START-CPRI_FU:1:C"},
				{slogan, "DP not loaded"},
				{hwConfig, hwConfigA}]}].

dci_scl9(_Config) ->
	ct:pal("dci_scl9"),

	% Set state, make audit, establish BCI and DCI connections, subscribe BCI faults
	set_state_and_connect( starting_lmc_not_loaded ),

	Radio1 = nci_ricm_utils:get_first_radio(),

	ct:pal("Action_1"),
	ok = nci_dci_actions:start_cpri_link( Radio1 ++ [
										  {expectedSigNo, ?RICM_START_CPRI_LINK_REJ},
										  {errorCode, 1},
										  {errorDescription, {regexp, "DP not loaded*"}}]),

	ct:pal("Action_2"),
	nci_bci_states:set_state([{state, starting_lmc_loaded}]),

	%% Start CPRI
	ct:pal("Action_3"),
	ok = nci_dci_actions:start_cpri_link(Radio1),
	ok = nci_dci_actions:cpri_link_ind(Radio1 ++ [{availStatus, 1}]),

	%% Reset CPRI Link
	ok = nci_dci_actions:reset_cpri_link(Radio1),
	ok = nci_dci_actions:reset_cpri_link_ind(Radio1),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id DCI_SCL12
%%
%% $Header
%%  ruId out of range and max value
%%
%% $Description
%%  Start CPRI Link, Invalid ruId, and max supported value on ruId
%%
%% $Requirements
%%  CBD_RICM_DCI-START-CPRI-LINK_FU:1:C
%%
%%  CBD_RICM_START-CPRI_FU:1:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state starting.
%%
%%  CPRI Link is not up for ruId 65535, port 4 and cascade 1
%%
%% $Action_1
%%  Send a START_CPRI_LINK_REQ with parameters:
%%
%%  ruId = 0
%%
%%  port = 4
%%
%%  cascade = 1
%%
%%  primary = 1
%%
%% $Result_1
%%  A START_CPRI_LINK_REJ is received with parameters:
%%
%%  ruId = 0
%%
%%  errorCode = UNSUCCESSFUL
%%
%%  errorDescription = "Invalid ruId"
%%
%% $Action_2
%%  Send a START_CPRI_LINK_REQ with parameters:
%%
%%  ruId = 65535
%%
%%  port = 4
%%
%%  cascade = 1
%%
%%  primary = 1
%%
%% $Result_21
%%  A START_CPRI_LINK_CFM is received with parameters:
%%
%%  ruId = 65535
%%
%% $Result_22
%%  A START_CPRI_LINK_IND is received with parameters:
%%
%%  ruId = 65535
%%
%%  typeOfUnit = 0
%%
%%  availStatus = 1
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-10-08, EEDAJA
%%    First version
%%
%%------------------------------------------------------------------------------
dci_scl12() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_RICM_DCI-START-CPRI-LINK_FU:1:C, CBD_RICM_START-CPRI_FU:1:C"},
				{slogan, "Invalid ruId and max value of ruId"},
				{hwConfig, hwConfigA}]}].

dci_scl12(_Config) ->
	ct:pal("dci_scl12"),

	% Set state, make audit, establish BCI and DCI connections, subscribe BCI faults
	set_state_and_connect( operational ),

	Radio1 = nci_ricm_utils:get_first_radio(),

	RuId = proplists:get_value(ruId,Radio1),
	Radio1new = (Radio1 -- [{ruId,RuId}]) ++ [{ruId, 0}],
	Radio1new2 = (Radio1 -- [{ruId,RuId}]) ++ [{ruId, 16#ffff}],

	%% Start CPRI with erroneous input parameters
	ct:pal("Action_1"),
	ok = nci_dci_actions:start_cpri_link(Radio1new ++ [
										  {expectedSigNo, ?RICM_START_CPRI_LINK_REJ},
										  {errorCode, 1},
										  {errorDescription, {regexp, "Invalid ruId*"}}]),

	%% Start CPRI with maximum value of ruId
	ct:pal("Action_2"),
	ok = nci_dci_actions:start_cpri_link(Radio1new2),

	ok = nci_dci_actions:cpri_link_ind(Radio1new2 ++ [{availStatus, 1}]),
	%% Reset CPRI Link
	ok = nci_dci_actions:reset_cpri_link(Radio1new2),

	ok = nci_dci_actions:reset_cpri_link_ind(Radio1new2),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id DCI_SCL13
%%
%% $Header
%%  ruId already in use
%%
%% $Description
%%  Start CPRI Link, ruId already in use
%%
%% $Requirements
%%  CBD_RICM_DCI-START-CPRI-LINK_FU:1:C
%%
%%  CBD_RICM_START-CPRI_FU:1:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state starting.
%%
%% $Action_1
%%  Send a START_CPRI_LINK_REQ with parameters retrieved from radios.cfg file
%%
%% $Result_1a
%%  A START_CPRI_LINK_CFM is received
%%
%% $Result_1b
%%  A START_CPRI_LINK_IND is received with parameters:
%%
%%  availStatus = 1
%%
%% $Action_2
%%  Send a START_CPRI_LINK_REQ with parameters:
%%
%%  the same ruId as that of action_1
%%
%%  the same portNo as that of action_1
%%
%%  cascadeNo = the previous cascadeNo + 1
%%
%%  primary = 1
%%
%% $Result_2
%%  A START_CPRI_LINK_REJ is received with parameters:
%%
%%  the same ruId as that of action_1
%%
%%  errorCode = UNSUCCESSFUL
%%
%%  errorDescription = "ruId already in use"
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-10-08, EEDAJA
%%    First version
%%  2012-07-04, EWENYWU
%%    Updated for mRBS doesn't support port 5
%%
%%------------------------------------------------------------------------------
dci_scl13() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_RICM_DCI-START-CPRI-LINK_FU:1:C, CBD_RICM_START-CPRI_FU:1:C"},
				{slogan, "RuId already in use"},
				{hwConfig, hwConfigA}]}].

dci_scl13(_Config) ->
	ct:pal("dci_scl13"),

	% Set state, make audit, establish BCI and DCI connections, subscribe BCI faults
	set_state_and_connect( operational ),

	Radio1 = nci_ricm_utils:get_first_radio(),

	%% Start CPRI
	ct:pal("Action_1"),
	ok = nci_dci_actions:start_cpri_link(Radio1),

	ok = nci_dci_actions:cpri_link_ind(Radio1 ++ [{availStatus, 1}]),

	%% Start CPRI, already up with the same ruId
	CascadeNo = proplists:get_value(cascadeNo,Radio1),
	Radio1new = (Radio1 -- [{cascadeNo,CascadeNo}]) ++ [{cascadeNo, CascadeNo + 1}],

	ct:pal("Action_2"),
	ok = nci_dci_actions:start_cpri_link(Radio1new ++ [
										{expectedSigNo, ?RICM_START_CPRI_LINK_REJ},
										{errorCode, ?ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL},
										{errorDescription, {regexp, "ruId already in use*"}}]),
	%% Reset CPRI Link
	ok = nci_dci_actions:reset_cpri_link(Radio1),

	ok = nci_dci_actions:reset_cpri_link_ind(Radio1),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id DCI_SCL14
%%
%% $Header
%%  Link already setup with another ruId
%%
%% $Description
%%  Start CPRI Link, Link already setup with another ruId
%%
%% $Requirements
%%  CBD_RICM_DCI-START-CPRI-LINK_FU:1:C
%%
%%  CBD_RICM_START-CPRI_FU:1:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state starting.
%%
%%  CPRI Link is not up for ruId 1, port 4 and cascade 1
%%
%%  CPRI Link is not up for ruId 2, port 4 and cascade 1
%%
%% $Action_1
%%  Send a START_CPRI_LINK_REQ with parameters:
%%
%%  ruId = 1
%%
%%  port = 4
%%
%%  cascade = 1
%%
%%  primary = 1
%%
%% $Result_11
%%  A START_CPRI_LINK_CFM is received with parameters:
%%
%%  ruId = 1
%%
%% $Result_12
%%  A START_CPRI_LINK_IND is received with parameters:
%%
%%  ruId = 1
%%
%%  typeOfUnit = 0
%%
%%  availStatus = 1
%%
%% $Action_2
%%  Send a START_CPRI_LINK_REQ with parameters:
%%
%%  ruId = 2
%%
%%  port = 4
%%
%%  cascade = 1
%%
%%  primary = 1
%%
%% $Result_2
%%  A START_CPRI_LINK_REJ is received with parameters:
%%
%%  ruId = 2
%%
%%  errorCode = UNSUCCESSFUL
%%
%%  errorDescription = "Link already setup with another ruId"
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-10-08, EEDAJA
%%    First version
%%
%%------------------------------------------------------------------------------
dci_scl14() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_RICM_DCI-START-CPRI-LINK_FU:1:C, CBD_RICM_START-CPRI_FU:1:C"},
				{slogan, "Link already setup with another ruId"},
				{hwConfig, hwConfigA}]}].

dci_scl14(_Config) ->
	ct:pal("dci_scl14"),

	% Set state, make audit, establish BCI and DCI connections, subscribe BCI faults
	set_state_and_connect( operational ),

	Radio1 = nci_ricm_utils:get_first_radio(),

	%% Start CPRI
	ct:pal("Action_1"),
	ok = nci_dci_actions:start_cpri_link(Radio1),
	ok = nci_dci_actions:cpri_link_ind(Radio1 ++ [{availStatus, 1}]),

	%% Start CPRI, already up
	ct:pal("Action_2"),

	RuId = proplists:get_value(ruId,Radio1),
	Radio2 = proplists:delete(ruId,Radio1) ++ [{ruId,RuId + 1}],

	ok = nci_dci_actions:start_cpri_link(Radio2 ++ [
										{expectedSigNo, ?RICM_START_CPRI_LINK_REJ},
										{errorCode, 1},
										{errorDescription, {regexp, "Link already setup with another ruId*"}}]),
	%% Reset CPRI Link
	ok = nci_dci_actions:reset_cpri_link(Radio1),
	ok = nci_dci_actions:reset_cpri_link_ind(Radio1),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id DCI_SCL15
%%
%% $Header
%%  No RU then connect/disconnect RU
%%
%% $Description
%%  Start CPRI Link, No RU then connect/disconnect RU
%%
%% $Requirements
%%  CBD_RICM_DCI-START-CPRI-LINK_FU:2:C
%%
%%  CBD_RICM_EL1CI-SUBSCRIBE-LINK-STATUS_CA:1:C
%%
%%  CBD_RICM_EL1CI-SUBSCRIBE-LINK-STATUS_CA:2:C
%%
%%  CBD_RICM_EL1CI-LINK-STATUS_FU:1:C
%%
%%  CBD_RICM_EL1CI-UNSUBSCRIBE-LINK-STATUS_FU:1:C
%%
%%  CBD_RICM_START-CPRI_FU:1:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state starting.
%%
%%  CPRI Link is not up for ruId 1, port 4 and cascade 1
%%
%%  No RU connected to port 4
%%
%% $Action
%%  Send a START_CPRI_LINK_REQ with parameters:
%%
%%  ruId = 1
%%
%%  port = 4
%%
%%  cascade = 1
%%
%%  primary = 1
%%
%% $Result
%%  A START_CPRI_LINK_CFM is received with parameters:
%%
%%  ruId = 1
%%
%% $Action
%%  Sleep 65 seconds then connect an RU to port 4
%%
%% $Result
%%  A START_CPRI_LINK_IND is received with parameters:
%%
%%  ruId = 1
%%
%%  typeOfUnit = 0
%%
%%  availStatus = 1
%%
%% $Action
%%  Sleep 65 seconds then disconnect RU on port 4
%%
%% $Result
%%  A START_CPRI_LINK_IND is received with parameters:
%%
%%  ruId = 1
%%
%%  typeOfUnit = 0
%%
%%  availStatus = 0
%%
%% $Postcondition
%%  -
%%
%% $End
%%------------------------------------------------------------------------------

%%------------------------------------------------------------------------------
%% $Id DCI_SCL16
%%
%% $Header
%%  Disconnect/re-connect RU
%%
%% $Description
%%  Start CPRI Link, Disconnect/re-connect RU
%%
%% $Requirements
%%  CBD_RICM_DCI-START-CPRI-LINK_FU:2:C
%%
%%  CBD_RICM_EL1CI-SUBSCRIBE-LINK-STATUS_CA:1:C
%%
%%  CBD_RICM_EL1CI-SUBSCRIBE-LINK-STATUS_CA:2:C
%%
%%  CBD_RICM_EL1CI-LINK-STATUS_FU:1:C
%%
%%  CBD_RICM_EL1CI-UNSUBSCRIBE-LINK-STATUS_FU:1:C
%%
%%  CBD_RICM_START-CPRI_FU:1:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state starting.
%%
%%  CPRI Link is not up for ruId 1, port 4 and cascade 1
%%
%% $Action
%%  Send a START_CPRI_LINK_REQ with parameters:
%%
%%  ruId = 1
%%
%%  port = 4
%%
%%  cascade = 1
%%
%%  primary = 1
%%
%% $Result
%%  A START_CPRI_LINK_CFM is received with parameters:
%%
%%  ruId = 1
%%
%% $Result
%%  A START_CPRI_LINK_IND is received with parameters:
%%
%%  ruId = 1
%%
%%  typeOfUnit = 0
%%
%%  availStatus = 1
%%
%% $Action
%%  Sleep 65 seconds then disconnect RU on port 4
%%
%% $Result
%%  A START_CPRI_LINK_IND is received with parameters:
%%
%%  ruId = 1
%%
%%  typeOfUnit = 0
%%
%%  availStatus = 0
%%
%% $Action
%%  Sleep 65 seconds then connect an RU to port 4
%%
%% $Result
%%  A START_CPRI_LINK_IND is received with parameters:
%%
%%  ruId = 1
%%
%%  typeOfUnit = 0
%%
%%  availStatus = 1
%%
%% $Postcondition
%%  -
%%
%% $End
%%------------------------------------------------------------------------------

%%------------------------------------------------------------------------------
%% $Id DCI_SCL17
%%
%% $Header
%%  Check bit rate at start/re-start
%%
%% $Description
%%  Start CPRI Link, Check bit rate at start/re-start
%%
%% $Requirements
%%  CBD_RICM_LTE-START-CPRI_FU:1:C
%%
%%  CBD_RICM_START-CPRI_FU:1:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state starting.
%%
%%  CPRI Link is not up for ru
%%
%% $Action_1
%%  Send a START_CPRI_LINK_REQ according to configuration
%%
%% $Result_1
%%  A START_CPRI_LINK_CFM is received with parameters according to configuration
%%  A START_CPRI_LINK_IND is received with parameters according to configuration
%%
%% $Action_2
%%  Send a ADD_RADIO_CTL_REQ according to configuration
%%
%% $Result_2
%%  A ADD_RADIO_CTL_CFM is received with parameters according to configuration
%%  A ADD_RADIO_CTL_IND is received with parameters according to configuration
%%
%% $Action_3
%%  Check CPRI FPGA registers to verify that they are configured correctly
%%
%% $Result_3
%%  FPGA registers have correct values according to configuration
%%
%% $Action_4
%%  Send a RELEASE_RADIO_CTL_REQ according to configuration
%%
%% $Result_4
%%  A RELEASE_RADIO_CTL_CFM is received with parameters according to configuration
%%  A RELEASE_RADIO_CTL_IND is received with parameters according to configuration
%%
%% $Action_5
%%  Send a RESET_CPRI_LINK_REQ according to configuration
%%
%% $Result_5
%%  A RESET_CPRI_LINK_CFM is received with parameters according to configuration
%%  A RESET_CPRI_LINK_IND is received with parameters according to configuration
%%
%% The RU is now restarted by an L1 reset
%%
%% $Action_6
%%  Send a START_CPRI_LINK_REQ according to configuration
%%
%% $Result_6
%%  A START_CPRI_LINK_CFM is received with parameters according to configuration
%%  A START_CPRI_LINK_IND is received with parameters according to configuration
%%
%%  and availStatus = 1
%%
%% $Action_7
%%  Send a ADD_RADIO_CTL_REQ with parameters according to configuration
%%
%% $Result_7
%%  A ADD_RADIO_CTL_CFM is received with parameters according to configuration
%%  A ADD_RADIO_CTL_IND is received with parameters according to configuration
%%
%%  and connStatus = 1
%%
%% $Action_8
%%  Check CPRI FPGA registers to verify that they are configured correctly
%%
%% $Result_8
%%  FPGA registers have correct values according to configuration 
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  2012-12-14, EEDAJA
%%
%% Revision history:
%%  2012-12-06, EJONUNA
%%    First version
%% Revision history:
%%  2013-09-10, EJONUNA
%%    Now checking DU's CPRI registers for LINE_RATE insted of checking radios te log
%%
%%------------------------------------------------------------------------------
dci_scl17() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_RICM_DCI-START-CPRI-LINK_FU:1:C, CBD_RICM_START-CPRI_FU:1:C"},
				{slogan, "Start CPRI Link, Check bit rate at start/re-start"},
				{hwConfig, hwConfigA}]}].

dci_scl17(_Config) ->
	ct:pal("dci_scl17"),
	
	% Set state, make audit, establish BCI and DCI connections, subscribe BCI faults
	set_state_and_connect( starting_lmc_loaded ),
	
	Radio = nci_ricm_utils:get_first_radio(),
	
	ct:pal("Action_1"),
	ok = nci_dci_actions:start_cpri_link(Radio),
	ct:pal("Result_1"),
	ok = nci_dci_actions:cpri_link_ind(Radio ++ [{availStatus, 1}]),
	
	ct:pal("Action_2"),
	nci_dci_actions:add_radio_control(Radio),
	ct:pal("Result_2"),
	nci_dci_actions:radio_control_ind(Radio ++ [{connStatus, 1}]),
	
	ct:pal("Action_3"),
	nci_ricm_utils:verify_cpri_link_up(Radio),
	
	ct:pal("Action_4"),
	ok = nci_dci_actions:release_radio_control(Radio),
	ct:pal("Result_4"),
	ok = nci_dci_actions:release_radio_control_ind(Radio),
	
	ct:pal("Action_5"),
	ok = nci_dci_actions:reset_cpri_link(Radio),
	ct:pal("Result_5"),
	ok = nci_dci_actions:reset_cpri_link_ind(Radio),
	
	ct:pal("Action_6"),
	ok = nci_dci_actions:start_cpri_link(Radio),
	ct:pal("Result_6"),
	ok = nci_dci_actions:cpri_link_ind(Radio ++ [{availStatus, 1}]),
	
	ct:pal("Action_7"),
	nci_dci_actions:add_radio_control(Radio),
	ct:pal("Result_7"),
	nci_dci_actions:radio_control_ind(Radio ++ [{connStatus, 1}]),
	
	ct:pal("Action_8"),
	nci_ricm_utils:verify_cpri_link_up(Radio),
	
	%% Clean up after test case
	ok = nci_dci_actions:reset_cpri_link(Radio),
	ok = nci_dci_actions:reset_cpri_link_ind(Radio),
	
	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).


%%------------------------------------------------------------------------------
%% $Id DCI_SCL18
%%
%% $Header
%%  Cascaded RE chain not connected
%%
%% $Description
%%  Verify start CPRI link for an RE not connected in cascaded chain.
%%
%% $Requirements
%%  CBD_RICM_LTE-START-CPRI_FU:1:C
%%
%%  CBD_RICM_START-CPRI_FU:1:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state starting.
%%
%% $Action_1
%%  Send a START_CPRI_LINK_REQ to a ru with cascadeNo > 1 that is not present in configuration.
%%
%% $Result_1
%%  A START_CPRI_LINK_REJ is received with parameters:
%%    errorCode = UNSUCCESSFUL
%%    errorDescription = "Cascaded RE chain not connected"
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  2012-12-14, EEDAJA
%%
%% Revision history:
%%  2012-12-10, EJONUNA
%%    First version
%%
%%------------------------------------------------------------------------------
dci_scl18() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_RICM_DCI-START-CPRI-LINK_FU:1:C, CBD_RICM_START-CPRI_FU:1:C"},
				{slogan, "Start CPRI Link, Check bit rate at start/re-start"},
				{hwConfig, hwConfigA}]}].

dci_scl18(_Config) ->
	ct:pal("dci_scl18"),

	% Set state, make audit, establish BCI and DCI connections, subscribe BCI faults
	set_state_and_connect( starting_lmc_loaded ),

	ok = nci_dci_actions:subscribe_faults([]),

	% Find a not configured RU with cascade > 1	
	% i.e., find the first portNo and cascadeNo combination, for which there exists no radio in the configuration
	% Note that ruId numbering is fixed:  ruId = 6*(portNo-1) + cascadeNo
	AllPortList = case nci_common_utils:get_du() of
		mRBS_lte ->
			[3,4];
		_ ->
			[1,2,3,4,5,6]
	  end,
	NotConfiguredRu = nci_ricm_utils:get_unconfigured_cascaded_ru(AllPortList, AllPortList),
	
	ct:pal("Action_1"),
	ok = nci_dci_actions:start_cpri_link(NotConfiguredRu ++ 
											[{expectedSigNo, ?RICM_START_CPRI_LINK_REJ},
											{errorCode, 1},
											{errorDescription, {regexp, "Cascaded RE chain not connected*"}}]),
	
	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).


%%##############################################################################
%% $ChapterH2 Subscribe Faults
%%
%%
%% $End
%%##############################################################################

%%------------------------------------------------------------------------------
%% $Id DCI_SF1
%%
%% $Header
%%  State Starting
%%
%% $Description
%%  Verify subscribe faults in state starting.
%%
%% $Requirements
%%  CBD_RICM_LTE-SUBSCRIBE-FAULT_CA:1:C
%%
%%  CBD_RICM_SUBSCRIBE-FAULT_CA:1:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  The DU BC is in state starting.
%%
%% $Action_1
%%  Send a DC_SUBSCRIBE_FAULTS_REQ
%%
%% $Result_1
%%  A DC_SUBSCRIBE_FAULTS_CFM is received.
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  2012-10-16, EYANWZH
%%
%% Revision history:
%%  2012-05-30, QMAGSED
%%    First version
%%
%%  2012-10-16, EEDAJA
%%    Minor changes after review
%%
%%------------------------------------------------------------------------------
dci_sf1() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_RICM_LTE-SUBSCRIBE-FAULT_CA:1:C, CBD_RICM_SUBSCRIBE-FAULT_CA:1:C"},
				{slogan, "Verify subscribe faults in state starting"}]}].

dci_sf1(_Config) ->
	dci_sf("dci_sf1", starting_lmc_loaded).

dci_sf( Name, State) ->
	ct:pal( Name ),

	% Set state, make audit, establish BCI and DCI connections, subscribe BCI faults
	set_state_and_connect( State ),

	%% Subscribe Faults DCI
	ct:pal("Action_1"),
	ok = nci_dci_actions:subscribe_faults([]),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id DCI_SF2
%%
%% $Header
%%  State Operational
%%
%% $Description
%%  Verify subscribe faults in state operational.
%%
%% $Requirements
%%  CBD_RICM_LTE-SUBSCRIBE-FAULT_CA:1:C
%%
%%  CBD_RICM_SUBSCRIBE-FAULT_CA:1:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state operational
%%
%% $Action_1
%%  Send a DC_SUBSCRIBE_FAULTS_REQ
%%
%% $Result_1
%%  A DC_SUBSCRIBE_FAULTS_CFM is received.
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  2012-10-16, EYANWZH
%%
%% Revision history:
%%  2012-05-30, QMAGSED
%%    First version
%%
%%  2012-10-16, EEDAJA
%%    Minor changes after review
%%
%%------------------------------------------------------------------------------
dci_sf2() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_RICM_LTE-SUBSCRIBE-FAULT_CA:1:C, CBD_RICM_SUBSCRIBE-FAULT_CA:1:C"},
				{slogan, "Verify subscribe faults in state operational"}]}].

dci_sf2(_Config) ->
	dci_sf("dci_sf2", operational).

%%------------------------------------------------------------------------------
%% $Id DCI_SF3
%%
%% $Header
%%  State Disabled
%%
%% $Description
%%  Verify subscribe faults in state disabled.
%%
%% $Requirements
%%  CBD_RICM_LTE-SUBSCRIBE-FAULT_CA:1:C
%%
%%  CBD_RICM_SUBSCRIBE-FAULT_CA:1:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state disabled
%%
%% $Action_1
%%  Send a DC_SUBSCRIBE_FAULTS_REQ
%%
%% $Result_1
%%  A DC_SUBSCRIBE_FAULTS_CFM is received.
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-10-16, EEDAJA
%%    First version
%%
%%------------------------------------------------------------------------------
dci_sf3() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_RICM_LTE-SUBSCRIBE-FAULT_CA:1:C, CBD_RICM_SUBSCRIBE-FAULT_CA:1:C"},
				{slogan, "Verify subscribe faults in state disabled"}]}].

dci_sf3(_Config) ->
	dci_sf("dci_sf3", disabled).

%%------------------------------------------------------------------------------
%% $Id DCI_SF4
%%
%% $Header
%%  Max No Of Clients
%%
%% $Description
%%  To verify that a maximum of 6 clients can be subscribing simultaneously
%%
%% $Requirements
%%  CBD_RICM_LTE-SUBSCRIBE-FAULT_CA:2:C
%%
%%  CBD_RICM_SUBSCRIBE-FAULT_CA:1:C
%%
%%  CBD_RICM_SUBSCRIBE-FAULT_CA:2:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  One client has performed a connection establish procedure since last restart.
%%
%% $Action_1
%%  Client A - F sends a DC_SUBSCRIBE_FAULTS_REQ each
%%
%% $Result_1
%%  Client A - F receives a DC_SUBSCRIBE_FAULTS_CFM each
%%
%% $Action_2
%%  Client G sends a DC_SUBSCRIBE_FAULTS_REQ
%%
%% $Result_2
%%  Client G receives a DC_SUBSCRIBE_FAULTS_REJ, with parameters:
%%
%%  errorCode = UNSUCCESSFUL
%%
%%  errorDescription = "Too many subscribing clients already active"
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-05-30, QMAGSED
%%    First version
%%
%%------------------------------------------------------------------------------
dci_sf4() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_RICM_LTE-SUBSCRIBE-FAULT_CA:1:C, CBD_RICM_SUBSCRIBE-FAULT_CA:1:C"},
				{slogan, "Maximum simultaneuos clients"}]}].

dci_sf4(_Config) ->
	ct:pal("dci_sf4"),

	{ok, session_up} = coli:subscribe_state(?SHELL_COMMAND),
	{ok, session_up} = osegw:subscribe_state(?OSE_GW_DEAMON_1),

	%% Restart Board
	ok = nci_bci_actions:conn_establish([]),
	LogString = string:concat("Test case ", string:to_upper("dci_sf4")),
	nci_bci_states:restart_board( LogString ),

	%% Create 6 more GWs
	ok = osegw:create(#osegw{name = ?OSE_GW_DEAMON_2, 
				 iap = osegw, 
				 opt = [{ping_timeout, 6000}, 
					{codec_config, 
					{?SIG_MODS, 
					 sizeof, 
					 osegw_ose,big}}]}),
	ok = osegw:create(#osegw{name = ?OSE_GW_DEAMON_3, 
				 iap = osegw, 
				 opt = [{ping_timeout, 6000}, 
					{codec_config, 
					{?SIG_MODS, 
					 sizeof, 
					 osegw_ose,big}}]}),
	ok = osegw:create(#osegw{name = ?OSE_GW_DEAMON_4, 
				 iap = osegw, 
				 opt = [{ping_timeout, 6000}, 
					{codec_config, 
					{?SIG_MODS, 
					 sizeof, 
					 osegw_ose,big}}]}),
	ok = osegw:create(#osegw{name = ?OSE_GW_DEAMON_5, 
				 iap = osegw, 
				 opt = [{ping_timeout, 6000}, 
					{codec_config, 
					{?SIG_MODS, 
					 sizeof, 
					 osegw_ose,big}}]}),
	ok = osegw:create(#osegw{name = ?OSE_GW_DEAMON_6, 
				 iap = osegw, 
				 opt = [{ping_timeout, 6000}, 
					{codec_config, 
					{?SIG_MODS, 
					 sizeof, 
						 osegw_ose,big}}]}),
	ok = osegw:create(#osegw{name = ?OSE_GW_DEAMON_7, 
				 iap = osegw, 
				 opt = [{ping_timeout, 6000}, 
					{codec_config, 
					{?SIG_MODS, 
					 sizeof, 
					 osegw_ose,big}}]}),

	%% First Client Connect to DCI interface
	ok = nci_dci_actions:conn_establish([{oseGwDeamon,?OSE_GW_DEAMON_1},
				 		 {expectedSigNo, ?ELIB_DC_CONN_ESTABLISH_CFM}]),
	%% Subscribe Faults
	ct:pal("Action_1"),
	ok = nci_dci_actions:subscribe_faults([{oseGwDeamon,?OSE_GW_DEAMON_1}]),
	ok = nci_dci_actions:subscribe_faults([{oseGwDeamon,?OSE_GW_DEAMON_2}]),
	ok = nci_dci_actions:subscribe_faults([{oseGwDeamon,?OSE_GW_DEAMON_3}]),
	ok = nci_dci_actions:subscribe_faults([{oseGwDeamon,?OSE_GW_DEAMON_4}]),
	ok = nci_dci_actions:subscribe_faults([{oseGwDeamon,?OSE_GW_DEAMON_5}]),

	ok = nci_dci_actions:subscribe_faults([{oseGwDeamon,?OSE_GW_DEAMON_6}]),

	%% Subscribe Faults should fail
	ct:pal("Action_2"),
	ok = nci_dci_actions:subscribe_faults([{oseGwDeamon,?OSE_GW_DEAMON_7},
											{expectedSigNo, ?ELIB_DC_SUBSCRIBE_FAULTS_REJ},
											{errorCode, 1},
											{errorDescription, {regexp, "Too many subscribing clients already active*"}}]),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(?OSE_GW_DEAMON_1, 2000),
	nci_common_utils:check_outstanding_faults(?OSE_GW_DEAMON_2, 200),
	nci_common_utils:check_outstanding_faults(?OSE_GW_DEAMON_3, 200),
	nci_common_utils:check_outstanding_faults(?OSE_GW_DEAMON_4, 200),
	nci_common_utils:check_outstanding_faults(?OSE_GW_DEAMON_5, 200),
	nci_common_utils:check_outstanding_faults(?OSE_GW_DEAMON_6, 200),
	nci_common_utils:check_outstanding_faults(?OSE_GW_DEAMON_7, 200),

	%% Delete created OSE GWs
	ok = osegw:delete(?OSE_GW_DEAMON_2),
	ok = osegw:delete(?OSE_GW_DEAMON_3),
	ok = osegw:delete(?OSE_GW_DEAMON_4),
	ok = osegw:delete(?OSE_GW_DEAMON_5),
	ok = osegw:delete(?OSE_GW_DEAMON_6),
	ok = osegw:delete(?OSE_GW_DEAMON_7).

%%##############################################################################
%% $ChapterH2 Subscribe Sync Port Indication
%%
%%
%% $End
%%############################################################################

%%------------------------------------------------------------------------------
%% $Id DCI_SSI1
%%
%% $Header
%%  State starting
%%
%% $Description
%%  Verify subscribe sync port indication, main state starting
%%  Only appicable for RICR verison 5.12.0 and later
%%
%% $Requirements
%%  N/A
%%
%% $External References
%%  -
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state starting
%%
%%  An RU is connected and ECP up for ruId 1
%%
%%  Radio has the capability of subscribe sync port
%%
%% $Action_1
%%  Send a RICM_SUBSCRIBE_RE_PORT_SYNC_INFO_REQ with parameters:
%%
%%  ruId = 1
%%
%% $Result_1_A
%%  A RICM_SUBSCRIBE_RE_PORT_SYNC_INFO_CFM is received with parameters:
%%
%%  ruId = 1
%%
%% $Result_1_B
%%  A RICM_RE_PORT_SYNC_INFO_IND is received with parameters:
%%
%%  ruId = 1
%%
%%  rePortNo = 0
%%
%%  syncPort = 0
%%
%%  syncStatus = 1
%%
%%  selectedSyncPort = 0
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  2013-04-03, EJONUNA
%%
%% Revision history:
%%  2013-03-04, EWEIWXU
%%    First version
%%	2013-04-07, EWEIWXU
%%	  Updated after review
%%  2013-10-09, eraasli
%%    Updated to use nci_dci_actions:subscribe_faults([])
%%
%%------------------------------------------------------------------------------
dci_ssi1() ->
	[{userdata,[{wp, ""},
				{requirement, "N/A"},
				{slogan, "Verify subscribe sync port indication, main state starting"},
				{hwConfig, hwConfigA}]}].

dci_ssi1(_Config) ->
	ct:pal("dci_ssi1"),

	%% Set state, make audit, establish BCI and DCI connections, subscribe faults
	set_state_and_connect( starting_lmc_loaded ),

	Radio1 = nci_ricm_utils:get_first_radio(),

	dci_ssi_pre(Radio1),

	%% Subscribe Sync Port
	ct:pal("Action_1"),
	nci_dci_actions:subscribe_re_port_sync_info(Radio1 ++ [{expectedSigNo, ?RICM_SUBSCRIBE_RE_PORT_SYNC_INFO_CFM}]),
	nci_dci_actions:re_port_sync_info_ind(Radio1 ++ [{rePortNo, 0},{syncPort,0},{syncStatus,1},{selectedSyncPort,0}]),

	%% Reset CPRI Link
	ok = nci_dci_actions:reset_cpri_link(Radio1),
	ok = nci_dci_actions:reset_cpri_link_ind(Radio1),

	%% Check that NO BC/DC_FAULT_IND is generated
	nci_common_utils:check_outstanding_faults(2000).


dci_ssi_pre(Radio) ->
	ok = nci_dci_actions:subscribe_faults([]),

	%% Start CPRI Link
	ok = nci_dci_actions:start_cpri_link(Radio),
	ok = nci_dci_actions:cpri_link_ind(Radio ++ [{availStatus, 1}]),

	%% Add Radio Control
	nci_dci_actions:add_radio_control(Radio),
	nci_dci_actions:radio_control_ind(Radio ++ [{connStatus, 1},{radioSoftware, application}]).

%%------------------------------------------------------------------------------
%% $Id DCI_SSI2
%%
%% $Header
%%  State operational
%%
%% $Description
%%	Verify subscribe sync port indication, main state operational
%%  Only appicable for RICR verison 5.12.0 and later
%%
%% $Requirements
%%  N/A
%%
%% $External References
%%  -
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state operational
%%
%%  An RU is connected and ECP up for ruId 1
%%
%%  Radio has the capability of subscribe sync port
%%
%% $Action_1
%%  Send a RICM_SUBSCRIBE_RE_PORT_SYNC_INFO_REQ with parameters:
%%
%%  ruId = 1
%%
%% $Result_1_A
%%  A RICM_SUBSCRIBE_RE_PORT_SYNC_INFO_CFM is received with parameters:
%%
%%  ruId = 1
%%
%% $Result_1_B
%%  A RICM_RE_PORT_SYNC_INFO_IND is received with parameters:
%%
%%  ruId = 1
%%
%%  rePortNo = 0
%%
%%  syncPort = 0
%%
%%  syncStatus = 1
%%
%%  selectedSyncPort = 0
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  2013-04-07, EJONUNA
%%
%% Revision history:
%%  2013-03-05, EWEIWXU
%%    First version
%%	2013-04-07, EWEIWXU
%%	  Updated after review
%%------------------------------------------------------------------------------
dci_ssi2() ->
	[{userdata,[{wp, ""},
				{requirement, "N/A"},
				{slogan, "Verify subscribe sync port indication, main state operational"},
				{hwConfig, hwConfigA}]}].

dci_ssi2(_Config) ->
	ct:pal("dci_ssi2"),

	%% Set state, make audit, establish BCI and DCI connections, subscribe faults
	set_state_and_connect( operational ),

	Radio1 = nci_ricm_utils:get_first_radio(),

	dci_ssi_pre(Radio1),

	%% Subscribe Sync Port
	ct:pal("Action_1"),
	nci_dci_actions:subscribe_re_port_sync_info(Radio1 ++ [{expectedSigNo, ?RICM_SUBSCRIBE_RE_PORT_SYNC_INFO_CFM}]),
	nci_dci_actions:re_port_sync_info_ind(Radio1 ++ [{rePortNo, 0},{syncPort,0},{syncStatus,1},{selectedSyncPort,0}]),

	%% Reset CPRI Link
	ok = nci_dci_actions:reset_cpri_link(Radio1),
	ok = nci_dci_actions:reset_cpri_link_ind(Radio1),

	%% Check that NO BC/DC_FAULT_IND is generated
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id DCI_SSI3
%%
%% $Header
%%  State disabled
%%
%% $Description
%%  Verify subscribe sync port indication, main state disabled
%%  Only appicable for RICR verison 5.12.0 and later
%%
%% $Requirements
%%  N/A
%%
%% $External References
%%  -
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state disabled
%%
%%  An RU is connected and ECP up for ruId 1
%%
%%  Radio has the capability of subscribe sync port
%%
%% $Action_1
%%  Send a RICM_SUBSCRIBE_RE_PORT_SYNC_INFO_REQ with parameters:
%%
%%  ruId = 1
%%
%% $Result_1
%%  A RICM_SUBSCRIBE_RE_PORT_SYNC_INFO_REJ is received with parameters:
%%
%%  ruId = 1
%%
%%  errorCode = UNSUCCESSFUL
%%
%%  errorDescription = "Invalid O&M state"
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  2013-04-07, EJONUNA
%%
%% Revision history:
%%  2013-03-15, eweiwxu
%%    First version
%%
%%  2013-08-07, ebacemi
%%    Updated to not expect an ADD_RADIO_CONTROL_IND signal after entering disabled state
%%
%%------------------------------------------------------------------------------
dci_ssi3() ->
	[{userdata,[{wp, ""},
				{requirement, "N/A"},
				{slogan, "Verify subscribe sync port indication, main state disabled"},
				{hwConfig, hwConfigA}]}].

dci_ssi3(_Config) ->
	ct:pal("dci_ssi3"),

	%% Set state, make audit, establish BCI and DCI connections, subscribe faults
	set_state_and_connect( operational ),

	Radio1 = nci_ricm_utils:get_first_radio(),

	dci_ssi_pre(Radio1),

	%% Set state disable
	nci_bci_states:set_state([{state, disabled}]),

	%% Subscribe Sync Port
	ct:pal("Action_1"),
	nci_dci_actions:subscribe_re_port_sync_info(Radio1 ++ [{expectedSigNo, ?RICM_SUBSCRIBE_RE_PORT_SYNC_INFO_REJ},
														{errorCode, 1},
														{errorDescription, {regexp, "Invalid O&M state*"}}]),

	%% Check that NO BC/DC_FAULT_IND is generated
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id DCI_SSI4
%%
%% $Header
%%  DP not loaded
%%
%% $Description
%%  Verify subscribe sync port indication, DP not loaded
%%  Only appicable for RICR verison 5.12.0 and later
%%
%% $Requirements
%%  N/A
%%
%% $External References
%%  -
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state starting
%%
%%  The DP is not loaded
%%
%% $Action_1
%%  Send a RICM_SUBSCRIBE_RE_PORT_SYNC_INFO_REQ with parameters:
%%
%%  ruId = 1
%%
%% $Result_1
%%  A RICM_SUBSCRIBE_RE_PORT_SYNC_INFO_REJ is received with parameters:
%%
%%  ruId = 1
%%
%%  errorCode = UNSUCCESSFUL
%%
%%  errorDescription = "DP not loaded"
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  2013-04-07, EJONUNA
%%
%% Revision history:
%%  2013-03-18, EWEIWXU
%%    First version
%%	2013-04-07, EWEIWXU
%%	  Updated according to review comments
%%------------------------------------------------------------------------------
dci_ssi4() ->
	[{userdata,[{wp, ""},
				{requirement, "N/A"},
				{slogan, "Verify subscribe sync port indication, DP not loaded"},
				{hwConfig, hwConfigA}]}].

dci_ssi4(_Config) ->
	ct:pal("dci_ssi4"),

	%% Set state, make audit, establish BCI and DCI connections, subscribe faults
	set_state_and_connect( starting_lmc_not_loaded ),

	Radio1 = nci_ricm_utils:get_first_radio(),

	%% Subscribe Sync Port
	ct:pal("Action_1"),
	nci_dci_actions:subscribe_re_port_sync_info(Radio1 ++ [{expectedSigNo, ?RICM_SUBSCRIBE_RE_PORT_SYNC_INFO_REJ},
														   {errorCode, 1},
														   {errorDescription, {regexp, "DP not loaded*"}}]),

	%% Check that NO BC/DC_FAULT_IND is generated
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id DCI_SSI5
%%
%% $Header
%%  Max No Of Clients
%%
%% $Description
%%  Verify a maximum of 3 clients can be subscribing simultaneously
%%  Only appicable for RICR verison 5.12.0 and later
%%
%% $Requirements
%%  N/A
%%
%% $External References
%%  -
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state starting
%%
%%  One clinet has performed a connection establish procedure since last restart
%%
%%  An RU is connected and ECP up for ruId 1
%%
%%  Radio has the capability of subscribe sync port
%%
%% $Action_1
%%  Client A-C sends a RICM_SUBSCRIBE_RE_PORT_SYNC_INFO_REQ each with parameters:
%%
%%  ruId = 1
%%
%% $Result_1_A
%%  Client A-C receives RICM_SUBSCRIBE_RE_PORT_SYNC_INFO_CFM with parameters:
%%
%%  ruId = 1
%%
%% $Result_1_B
%%  Client A-C receives RICM_RE_PORT_SYNC_INFO_IND with parameters:
%%
%%  ruId = 1
%%
%%  rePortNo = 0
%%
%%  syncPort = 0
%%
%%  syncStatus = 1
%%
%%  selectedSyncPort = 0
%%
%% $Action_2
%%  Client D sends a RICM_SUBSCRIBE_RE_PORT_SYNC_INFO_REQ with parameters:
%%
%%  ruId = 1
%%
%% $Result_2
%%  Client D receives RICM_SUBSCRIBE_RE_PORT_SYNC_INFO_REJ with parameters:
%%
%%  ruId=1
%%
%%  errorCode = UNSUCCESSFUL
%%
%%  errorDescription = "Too many clients already connected"
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  2013-04-07, EJONUNA
%%
%% Revision history:
%%  2012-03-13, EWEIWXU
%%    First version
%%------------------------------------------------------------------------------
dci_ssi5() ->
	[{userdata,[{wp, ""},
				{requirement, "N/A"},
				{slogan, "Verify a maximum of 3 clients can be subscribing simultaneously"},
				{hwConfig, hwConfigA}]}].

dci_ssi5(_Config) ->
	ct:pal("dci_ssi5"),

	%% Restart Board
	ok = nci_bci_actions:conn_establish([]),
	LogString = string:concat("Test case ", string:to_upper("dci_ssi5")),
	nci_bci_states:restart_board( LogString ),

	%% Create 3 more GWs
	ok = osegw:create(#osegw{name = ?OSE_GW_DEAMON_2,
				 iap = osegw,
				 opt = [{ping_timeout, 6000},
					{codec_config,
					{?SIG_MODS,
					 sizeof,
					 osegw_ose,big}}]}),
	ok = osegw:create(#osegw{name = ?OSE_GW_DEAMON_3,
				 iap = osegw,
				 opt = [{ping_timeout, 6000},
					{codec_config,
					{?SIG_MODS,
					 sizeof,
					 osegw_ose,big}}]}),
	ok = osegw:create(#osegw{name = ?OSE_GW_DEAMON_4,
				 iap = osegw,
				 opt = [{ping_timeout, 6000},
					{codec_config,
					{?SIG_MODS,
					 sizeof,
					 osegw_ose,big}}]}),

	%% Set state, make audit, establish BCI and DCI connections, subscribe faults
	set_state_and_connect( starting_lmc_loaded ),

	Radio1 = nci_ricm_utils:get_first_radio(),

	dci_ssi_pre(Radio1),

	%% Subscribe Sync Port
	ct:pal("Action_1"),
	nci_dci_actions:subscribe_re_port_sync_info(Radio1 ++ [{oseGwDeamon,?OSE_GW_DEAMON_1}]),
	nci_dci_actions:re_port_sync_info_ind(Radio1 ++ [{oseGwDeamon,?OSE_GW_DEAMON_1},{rePortNo, 0},{syncPort,0},{syncStatus,1},{selectedSyncPort,0}]),
	nci_dci_actions:subscribe_re_port_sync_info(Radio1 ++ [{oseGwDeamon,?OSE_GW_DEAMON_2}]),
	nci_dci_actions:re_port_sync_info_ind(Radio1 ++ [{oseGwDeamon,?OSE_GW_DEAMON_2},{rePortNo, 0},{syncPort,0},{syncStatus,1},{selectedSyncPort,0}]),
	nci_dci_actions:subscribe_re_port_sync_info(Radio1 ++ [{oseGwDeamon,?OSE_GW_DEAMON_3}]),
	nci_dci_actions:re_port_sync_info_ind(Radio1 ++ [{oseGwDeamon,?OSE_GW_DEAMON_3},{rePortNo, 0},{syncPort,0},{syncStatus,1},{selectedSyncPort,0}]),

	ct:pal("Action_2"),
	nci_dci_actions:subscribe_re_port_sync_info(Radio1 ++ [{oseGwDeamon,?OSE_GW_DEAMON_4},
														{expectedSigNo, ?RICM_SUBSCRIBE_RE_PORT_SYNC_INFO_REJ},
														{errorCode, 1},
														{errorDescription, {regexp, "Too many clients already connected*"}}]),

	%% Reset CPRI Link
	ok = nci_dci_actions:reset_cpri_link(Radio1),
	ok = nci_dci_actions:reset_cpri_link_ind(Radio1),

	%% Check that NO BC/DC_FAULT_IND is generated
	nci_common_utils:check_outstanding_faults(?OSE_GW_DEAMON_1, 2000),
	nci_common_utils:check_outstanding_faults(?OSE_GW_DEAMON_2, 200),
	nci_common_utils:check_outstanding_faults(?OSE_GW_DEAMON_3, 200),
	nci_common_utils:check_outstanding_faults(?OSE_GW_DEAMON_4, 200),

	%% Delete created OSE GWs
	ok = osegw:delete(?OSE_GW_DEAMON_2),
	ok = osegw:delete(?OSE_GW_DEAMON_3),
	ok = osegw:delete(?OSE_GW_DEAMON_4).
%%------------------------------------------------------------------------------
%% $Id DCI_SSI6
%%
%% $Header
%%  CPRI Link Not Up
%%
%% $Description
%%  Verify subscribe sync port indication, CPRI Link Not Up
%%  Only appicable for RICR verison 5.12.0 and later
%%
%% $Requirements
%%  N/A
%%
%% $External References
%%  -
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state starting
%%
%%  No CPRI Link up for ruId 1
%%
%% $Action_1
%%  Send a RICM_SUBSCRIBE_RE_PORT_SYNC_INFO_REQ with parameters:
%%
%%  ruId = 1
%%
%% $Result_1
%%  A RICM_SUBSCRIBE_RE_PORT_SYNC_INFO_REJ is received with parameters:
%%
%%  ruId = 1
%%
%%  errorCode = UNSUCCESSFUL
%%
%%  errorDescription = "ruId not in use"
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  2013-04-07, EJONUNA
%%
%% Revision history:
%%  2013-03-13, EWEIWXU
%%    First version
%%------------------------------------------------------------------------------
dci_ssi6() ->
	[{userdata,[{wp, ""},
				{requirement, "N/A"},
				{slogan, "Verify subscribe sync port indication, CPRI Link Not Up"},
				{hwConfig, hwConfigA}]}].

dci_ssi6(_Config) ->
	ct:pal("dci_ssi6"),

	%% Set state, make audit, establish BCI and DCI connections, subscribe faults
	set_state_and_connect( starting_lmc_loaded ),

	Radio1 = nci_ricm_utils:get_first_radio(),

	%% Subscribe Sync Port
	ct:pal("Action_1"),
	nci_dci_actions:subscribe_re_port_sync_info(Radio1 ++ [{expectedSigNo, ?RICM_SUBSCRIBE_RE_PORT_SYNC_INFO_REJ},
														   {errorCode, 1},
														   {errorDescription, {regexp, "ruId not in use*"}}]),

	%% Check that NO BC/DC_FAULT_IND is generated
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id DCI_SSI7
%%
%% $Header
%%  No Radio Control
%%
%% $Description
%%  Verify shall not be possible to subscribe sync port indication when No Radio Control Added
%%  Only appicable for RICR verison 5.12.0 and later
%%
%% $Requirements
%%  N/A
%%
%% $External References
%%  -
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state starting
%%
%%  CPRI link is up for ruId 1
%%
%%  No ECP link up for ruId 1
%%
%% $Action_1
%%  Send a RICM_SUBSCRIBE_RE_PORT_SYNC_INFO_REQ with parameters:
%%
%%  ruId = 1
%%
%% $Result_1
%%  A RICM_SUBSCRIBE_RE_PORT_SYNC_INFO_REJ is received with parameters:
%%
%%  ruId = 1
%%
%%  errorCode = UNSUCCESSFUL
%%
%%  errorDescription = "Invalid O&M link"
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  2013-04-07, EJONUNA
%%
%% Revision history:
%%  2013-03-18, EWEIWXU
%%    First version
%%------------------------------------------------------------------------------
dci_ssi7() ->
	[{userdata,[{wp, ""},
				{requirement, "N/A"},
				{slogan, "Verify shall not be possible to subscribe sync port indication when No Radio Control Added"},
				{hwConfig, hwConfigA}]}].

dci_ssi7(_Config) ->
	ct:pal("dci_ssi7"),

	%% Set state, make audit, establish BCI and DCI connections, subscribe faults
	set_state_and_connect( starting_lmc_loaded ),

	Radio1 = nci_ricm_utils:get_first_radio(),

	%% Start CPRI Link
	ok = nci_dci_actions:start_cpri_link(Radio1),
	ok = nci_dci_actions:cpri_link_ind(Radio1 ++ [{availStatus, 1}]),

	%% Subscribe Sync Port
	ct:pal("Action_1"),
	nci_dci_actions:subscribe_re_port_sync_info(Radio1 ++ [{expectedSigNo, ?RICM_SUBSCRIBE_RE_PORT_SYNC_INFO_REJ},
														   {errorCode, 1},
														   {errorDescription, {regexp, "Invalid O&M link*"}}]),

	%% Reset CPRI Link
	ok = nci_dci_actions:reset_cpri_link(Radio1),
	ok = nci_dci_actions:reset_cpri_link_ind(Radio1),

	%% Check that NO BC/DC_FAULT_IND is generated
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id DCI_SSI8
%%
%% $Header
%%  Supervise the change of radio sync source port
%%
%% $Description
%%  Verify supervise the change of radio sync source port
%%  Only appicable for RICR verison 5.12.0 and later
%%
%% $Requirements
%%  N/A
%%
%% $External References
%%  -
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state starting
%%
%%  An RU is connected and ECP up for ruId 1
%%
%%  Radio has the capability of subscribe sync port
%%
%%
%% $Action_1
%%  Send a RICM_SUBSCRIBE_RE_PORT_SYNC_INFO_REQ with parameters:
%%
%%  ruId = 1
%%
%% $Result_1_A
%%  A RICM_SUBSCRIBE_RE_PORT_SYNC_INFO_CFM is received with parameters:
%%
%%  ruId = 1
%%
%% $Result_1_B
%%  A RICM_RE_PORT_SYNC_INFO_IND is received with parameters:
%%
%%  ruId = 1
%%
%%  rePortNo = 0
%%
%%  syncPort = 0
%%
%%  syncStatus = 1
%%
%%  selectedSyncPort = 0
%%
%% $Action_2
%%  Fake radio clock port change
%%
%% $Result_2
%%  A RICM_RE_PORT_SYNC_INFO_IND is received with parameters:
%%
%%  ruId = 1
%%
%%  rePortNo = 0
%%
%%  syncPort = 0
%%
%%  syncStatus = 0
%%
%%  selectedSyncPort = 1
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  2013-04-07, EJONUNA
%%
%% Revision history:
%%  2013-03-20, EWEIWXU
%%    First version
%%	2013-04-07, EWEIWXU
%%	  Updated after review
%%------------------------------------------------------------------------------
dci_ssi8() ->
	[{userdata,[{wp, ""},
				{requirement, "N/A"},
				{slogan, "Verify supervise the change of radio sync source port"},
				{hwConfig, hwConfigA}]}].

dci_ssi8(_Config) ->
	ct:pal("dci_ssi8"),

	%% Set state, make audit, establish BCI and DCI connections, subscribe faults
	set_state_and_connect( starting_lmc_loaded ),

	Radio1 = nci_ricm_utils:get_first_radio(),

	dci_ssi_pre(Radio1),

	%% Subscribe Sync Port
	ct:pal("Action_1"),
	nci_dci_actions:subscribe_re_port_sync_info(Radio1 ++ [{expectedSigNo, ?RICM_SUBSCRIBE_RE_PORT_SYNC_INFO_CFM}]),
	nci_dci_actions:re_port_sync_info_ind(Radio1 ++ [{rePortNo, 0},{syncPort,0},{syncStatus,1},{selectedSyncPort,0}]),

	%% Fake radio clock port change
	ct:pal("Action_2"),
	nci_rici_actions:sync_port_ind(Radio1),
	nci_dci_actions:re_port_sync_info_ind(Radio1 ++ [{rePortNo, 0},{syncPort,0},{syncStatus,0},{selectedSyncPort,1}]),

	%% Reset CPRI Link
	ok = nci_dci_actions:reset_cpri_link(Radio1),
	ok = nci_dci_actions:reset_cpri_link_ind(Radio1),

	%% Check that NO BC/DC_FAULT_IND is generated
	nci_common_utils:check_outstanding_faults(2000).
%%------------------------------------------------------------------------------
%% $Id DCI_SSI9
%%
%% $Header
%%  O&M link taken down
%%
%% $Description
%%  Verify subscribe sync port indication when O&M link goes down
%%  Only appicable for RICR verison 5.12.0 and later
%%
%% $Requirements
%%  N/A
%%
%% $External References
%%  -
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state starting
%%
%%  An RU is connected and ECP up for ruId 1
%%
%%  Radio has the capability of subscribe sync port
%%
%% $Action_1
%%  Send a RICM_SUBSCRIBE_RE_PORT_SYNC_INFO_REQ with parameters:
%%
%%  ruId = 1
%%
%% $Result_1_A
%%  A RICM_SUBSCRIBE_RE_PORT_SYNC_INFO_CFM is received with parameters:
%%
%%  ruId = 1
%%
%% $Result_1_B
%%  A RICM_RE_PORT_SYNC_INFO_IND is received with parameters:
%%
%%  ruId = 1
%%
%%  rePortNo = 0
%%
%%  syncPort = 0
%%
%%  syncStatus = 1
%%
%%  selectedSyncPort = 0
%%
%% $Action_2
%%  Send a RELEASE_RADIO_CTL_REQ
%%
%% $Result_2_A
%%  A RELEASE_RADIO_CTL_CFM is received
%%
%% $Result_2_B
%%  A RELEASE_RADIO_CTL_IND is received
%%
%% $Action_3
%%  Send a ADD_RADIO_CTL_REQ
%%
%% $Result_3_A
%%  A ADD_RADIO_CTL_CFM is received
%%
%% $Result_3_B
%%  A ADD_RADIO_CTL_IND is received with parameters:
%%
%%  connStatus = 1
%%
%%  huntPath = BXP_0_1
%%
%% $Action_4
%%  Send a RICM_SUBSCRIBE_RE_PORT_SYNC_INFO_REQ with parameters:
%%
%%  ruId = 1
%%
%% $Result_4_A
%%  A RICM_SUBSCRIBE_RE_PORT_SYNC_INFO_CFM is received with parameters:
%%
%%  ruId = 1
%%
%% $Result_4_B
%%  A RICM_RE_PORT_SYNC_INFO_IND is received with parameters:
%%
%%  ruId = 1
%%
%%  rePortNo = 0
%%
%%  syncPort = 0
%%
%%  syncStatus = 1
%%
%%  selectedSyncPort = 0
%%
%% $Action_5
%%  Fake radio clock port change
%% $Result_5
%%  A RICM_RE_PORT_SYNC_INFO_IND is received with parameters:
%%
%%  ruId = 1
%%
%%  rePortNo = 0
%%
%%  syncPort = 0
%%
%%  syncStatus = 0
%%
%%  selectedSyncPort = 1
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  2013-04-07, EJONUNA
%%
%% Revision history:
%%  2013-03-25, EWEIWXU
%%    First version
%%	2013-04-07, EWEIWXU
%%	  Updated after review
%%------------------------------------------------------------------------------
dci_ssi9() ->
	[{userdata,[{wp, ""},
				{requirement, "N/A"},
				{slogan, "Verify subscribe sync port indication when O&M link goes down"},
				{hwConfig, hwConfigA}]}].

dci_ssi9(_Config) ->
	ct:pal("dci_ssi9"),

	%% Set state, make audit, establish BCI and DCI connections, subscribe faults
	set_state_and_connect( starting_lmc_loaded ),

	Radio1 = nci_ricm_utils:get_first_radio(),
	RuLnhPath = proplists:get_value(ruLnhPath, Radio1),

	dci_ssi_pre(Radio1),

	%% Subscribe Sync Port
	ct:pal("Action_1"),
	nci_dci_actions:subscribe_re_port_sync_info(Radio1 ++ [{expectedSigNo, ?RICM_SUBSCRIBE_RE_PORT_SYNC_INFO_CFM}]),
	nci_dci_actions:re_port_sync_info_ind(Radio1 ++ [{rePortNo, 0},{syncPort,0},{syncStatus,1},{selectedSyncPort,0}]),

	%% Release Radio Control
	ct:pal("Action_2"),
	nci_dci_actions:release_radio_control(Radio1),
	nci_dci_actions:release_radio_control_ind(Radio1),
	nci_common_utils:coli_cmd("lhsh " ++ RuLnhPath ++ " lmclist", "failed to connect "),

	%% Add Radio Control
	ct:pal("Action_3"),
	nci_dci_actions:add_radio_control(Radio1 ++ [{expectedSigNo, ?RICM_ADD_RADIO_CTL_CFM}]),
	nci_dci_actions:radio_control_ind(Radio1 ++ [{connStatus, 1},{radioSoftware, application}]),

	%% Subscribe Sync Port
	ct:pal("Action_4"),
	nci_dci_actions:subscribe_re_port_sync_info(Radio1 ++ [{expectedSigNo, ?RICM_SUBSCRIBE_RE_PORT_SYNC_INFO_CFM}]),
	nci_dci_actions:re_port_sync_info_ind(Radio1 ++ [{rePortNo, 0},{syncPort,0},{syncStatus,1},{selectedSyncPort,0}]),

	%% Fake radio clock port change
	ct:pal("Action_5"),
	nci_rici_actions:sync_port_ind(Radio1),
	nci_dci_actions:re_port_sync_info_ind(Radio1 ++ [{rePortNo, 0},{syncPort,0},{syncStatus,0},{selectedSyncPort,1}]),

	%% Reset CPRI Link
	ok = nci_dci_actions:reset_cpri_link(Radio1),
	ok = nci_dci_actions:reset_cpri_link_ind(Radio1),

	%% Check that NO BC/DC_FAULT_IND is generated
	%% Check that no "RICM_RE_PORT_SYNC_INFO_IND" is generated
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id DCI_SSI10
%%
%% $Header
%%  RU disconnect/re-connect
%%  Manual Test case
%%
%% $Description
%%  Verify subscribe sync port indication when RU is re-connected after a disconnect
%%  Only appicable for RICR verison 5.12.0 and later
%%
%% $Requirements
%%  N/A
%%
%% $External References
%%  -
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state starting
%%
%%  An RU is connected and ECP up for ruId 1
%%
%%  Radio has the capability of subscribe sync port
%%
%% $Action_1
%%  Send a RICM_SUBSCRIBE_RE_PORT_SYNC_INFO_REQ with parameters:
%%
%%  ruId = 1
%%
%% $Result_1_A
%%  A RICM_SUBSCRIBE_RE_PORT_SYNC_INFO_CFM is received with parameters:
%%
%%  ruId = 1
%%
%% $Result_1_B
%%  A RICM_RE_PORT_SYNC_INFO_IND is received with parameters:
%%
%%  ruId = 1
%%
%%  rePortNo = 0
%%
%%  syncPort = 0
%%
%%  syncStatus = 1
%%
%%  selectedSyncPort = 0
%%
%% $Action_2
%%  Sleep for 180 seconds to Disconnect and Re-connect cable to RU
%%
%% $Result_2
%%  CPRI link and O&M link take down and come up
%%
%% $Action_3
%%  Fake radio clock port change
%%
%% $Result_3
%%  -
%%
%% $Action_4
%%  Send a RICM_SUBSCRIBE_RE_PORT_SYNC_INFO_REQ with parameters:
%%
%%  ruId = 1
%%
%% $Result_4_A
%%  A RICM_SUBSCRIBE_RE_PORT_SYNC_INFO_CFM is received with parameters:
%%
%%  ruId = 1
%%
%% $Result_4_B
%%  A RICM_RE_PORT_SYNC_INFO_IND is received with parameters:
%%
%%  ruId = 1
%%
%%  rePortNo = 0
%%
%%  syncPort = 0
%%
%%  syncStatus = 0
%%
%%  selectedSyncPort = 1
%%
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  2013-04-07, EJONUNA
%%
%% Revision history:
%%  2013-03-26, EWEIWXU
%%    First version
%%	2013-04-07, EWEIWXU
%%	  Updated after review
%%------------------------------------------------------------------------------
dci_ssi10() ->
	[{timetrap, {minutes, 10}},
	 {userdata,[{wp, ""},
				{requirement, "N/A"},
				{slogan, "Verify subscribe sync port indication when RU is re-connected after a disconnect"},
				{hwConfig, hwConfigA}]}].

dci_ssi10(_Config) ->
	ct:pal("dci_ssi10"),

	%% Set state, make audit, establish BCI and DCI connections, subscribe faults
	set_state_and_connect( starting_lmc_loaded ),

	Radio1 = nci_ricm_utils:get_first_radio(),

	dci_ssi_pre(Radio1),

	%% Subscribe Sync Port
	ct:pal("Action_1"),
	nci_dci_actions:subscribe_re_port_sync_info(Radio1 ++ [{expectedSigNo, ?RICM_SUBSCRIBE_RE_PORT_SYNC_INFO_CFM}]),
	nci_dci_actions:re_port_sync_info_ind(Radio1 ++ [{rePortNo, 0},{syncPort,0},{syncStatus,1},{selectedSyncPort,0}]),

	%%Disconnect and Re-connect cable to RU
	%%CPRI link and O&M link take down and come up
	ct:pal("Action_2"),
	ct:pal("Sleeping 3 minutes and disconnect and re-connect cable to RU"),
	timer:sleep(180*1000),
	ok = nci_dci_actions:cpri_link_ind(Radio1 ++ [{availStatus, 0}]),
	nci_dci_actions:radio_control_ind(Radio1 ++ [{connStatus, 0}]),
	ok = nci_dci_actions:cpri_link_ind(Radio1 ++ [{availStatus, 1}]),
	nci_dci_actions:radio_control_ind(Radio1 ++ [{connStatus, 1}]),

	%% Fake radio clock port change
	ct:pal("Action_3"),
	nci_rici_actions:sync_port_ind(Radio1),

	%% Subscribe Sync Port
	ct:pal("Action_4"),
	nci_dci_actions:subscribe_re_port_sync_info(Radio1 ++ [{expectedSigNo, ?RICM_SUBSCRIBE_RE_PORT_SYNC_INFO_CFM}]),
	nci_dci_actions:re_port_sync_info_ind(Radio1 ++ [{rePortNo, 0},{syncPort,0},{syncStatus,0},{selectedSyncPort,1}]),

	%% Reset CPRI Link
	ok = nci_dci_actions:reset_cpri_link(Radio1),
	ok = nci_dci_actions:reset_cpri_link_ind(Radio1),

	%% Check that NO BC/DC_FAULT_IND is generated
	%% Check that no "RICM_RE_PORT_SYNC_INFO_IND" is generated
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id DCI_SSI11
%%
%% $Header
%%  State starting
%%
%% $Description
%%  Unsubscribe sync port indication, main state starting
%%  Only appicable for RICR verison 5.12.0 and later
%%
%% $Requirements
%%  N/A
%%
%% $External References
%%  -
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state starting.
%%
%%  An RU is connected and ECP up for ruId 1
%%
%%  Radio has the capability of subscribe sync port
%%
%% $Action_1
%%  Send a RICM_UNSUBSCR_RE_PORT_SYNC_INFO_REQ with parameters:
%%
%%  ruId = 1
%%
%% $Result_1
%%  A RICM_UNSUBSCR_RE_PORT_SYNC_INFO_CFM is received with parameters:
%%
%%  ruId = 1
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  2013-04-07, EJONUNA
%%
%% Revision history:
%%  2013-04-02, EWEIWXU
%%    First version
%%------------------------------------------------------------------------------
dci_ssi11() ->
	[{userdata,[{wp, ""},
				{requirement, "N/A"},
				{slogan, "Verify Unsubscribe sync port indication, main state starting"},
				{hwConfig, hwConfigA}]}].

dci_ssi11(_Config) ->
	ct:pal("dci_ssi11"),

	%% Set state, make audit, establish BCI and DCI connections, subscribe faults
	set_state_and_connect( starting_lmc_loaded ),

	Radio1 = nci_ricm_utils:get_first_radio(),

	dci_ssi_pre(Radio1),

	%% Unsubscribe Sync Port
	ct:pal("Action_1"),
	nci_dci_actions:unsubscr_re_port_sync_info(Radio1 ++ [{expectedSigNo, ?RICM_UNSUBSCR_RE_PORT_SYNC_INFO_CFM}]),

	%% Reset CPRI Link
	ok = nci_dci_actions:reset_cpri_link(Radio1),
	ok = nci_dci_actions:reset_cpri_link_ind(Radio1),

	%% Check that NO BC/DC_FAULT_IND is generated
	nci_common_utils:check_outstanding_faults(2000).

%%##############################################################################
%% $ChapterH2 Timing Distribution
%%
%%
%% $End
%%##############################################################################

%%------------------------------------------------------------------------------
%% $Id DCI_STD1
%%
%% $Header
%%  Timing Distribution, Main State Starting
%%
%% $Description
%%  Test timing distribution when DU BC is in main state starting.
%%
%% $Requirements
%%  N/A
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  The DU BC is in state starting.
%%
%% $Action
%%  Send a RICM_START_TIMING_DISTRIBUTION_REQ.
%%
%% $Result
%%  A RICM_START_TIMING_DISTRIBUTION_CFM is received
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  2012-10-18, EEDAJA
%%
%% Revision history:
%%  2012-05-30, QMAGSED
%%    First version
%%
%%  2012-10-18, EEDAJA
%%    Minor changes after review.
%%
%%------------------------------------------------------------------------------
dci_std1() ->
	[{userdata,[{wp, ""},
				{requirement, "N/A"},
				{slogan, "Timing Distribution, Main State Starting"},
				{hwConfig, hwConfigA}]}].

dci_std1(_Config) ->
	dci_std( "dci_std1", starting_lmc_loaded ).


dci_std(Name, State) ->
	ct:pal(Name),

	% Set state, make audit, establish BCI and DCI connections, subscribe BCI faults
	set_state_and_connect( State ),

	Radio1 = nci_ricm_utils:get_first_radio(),
	RuLnhPath = proplists:get_value(ruLnhPath, Radio1),

	%% Start CPRI
	ok = nci_dci_actions:start_cpri_link(Radio1),
	ok = nci_dci_actions:cpri_link_ind(Radio1 ++ [{availStatus, 1}]),

	%% Add Radio Control
	nci_dci_actions:add_radio_control(Radio1 ++ [{expectedSigNo, ?RICM_ADD_RADIO_CTL_CFM}]),
	nci_dci_actions:radio_control_ind(Radio1 ++ [{connStatus, 1}]),

	nci_common_utils:coli_cmd("lhsh " ++ RuLnhPath ++ " lmclist", "SlotProt State"),

	nci_dci_actions:start_timing_distribution(Radio1),

	%% Reset CPRI Link
	ok = nci_dci_actions:reset_cpri_link(Radio1),
	ok = nci_dci_actions:reset_cpri_link_ind(Radio1),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id DCI_STD2
%%
%% $Header
%%  Timing Distribution, Main State Operational
%%
%% $Description
%%  Test timing distribution when DU BC is in main state Operational.
%%
%% $Requirements
%%  N/A
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state operational.
%%
%% $Action
%%  Send a RICM_START_TIMING_DISTRIBUTION_REQ.
%%
%% $Result
%%  A RICM_START_TIMING_DISTRIBUTION_CFM is received
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  2012-10-18, EEDAJA
%%
%% Revision history:
%%  2012-05-30, QMAGSED
%%    First version
%%
%%  2012-10-18, EEDAJA
%%    Minor changes after review.
%%
%%------------------------------------------------------------------------------
dci_std2() ->
	[{userdata,[{wp, ""},
				{requirement, "N/A"},
				{slogan, "Timing Distribution, Main State operational"},
				{hwConfig, hwConfigA}]}].

dci_std2(_Config) ->
	dci_std("dci_std2", operational).

%%------------------------------------------------------------------------------
%% $Id DCI_STD3
%%
%% $Header
%%  Timing Distribution, Main State Disabled
%%
%% $Description
%%  Test timing distribution when DU BC is in main state disabled.
%%
%% $Requirements
%%  N/A
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state disabled.
%%
%% $Action
%%  Send a RICM_START_TIMING_DISTRIBUTION_REQ.
%%
%% $Result
%%  A RICM_START_TIMING_DISTRIBUTION_CFM is received
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-05-30, QMAGSED
%%    First version
%%
%%  2013-07-02, EBACEMI
%%    Removed code that expects RICM_ADD_RADIO_CTL_IND after entering disabled state
%%
%%------------------------------------------------------------------------------
dci_std3() ->
	[{userdata,[{wp, ""},
				{requirement, "N/A"},
				{slogan, "Timing Distribution, Main State disabled"},
				{hwConfig, hwConfigA}]}].

dci_std3(_Config) ->
	ct:pal("dci_std3"),

	% Set state, make audit, establish BCI and DCI connections, subscribe BCI faults
	set_state_and_connect( operational ), % state will be changed later to disabled

	Radio1 = nci_ricm_utils:get_first_radio(),
	RuLnhPath = proplists:get_value(ruLnhPath, Radio1),

	%% Start CPRI
	ok = nci_dci_actions:start_cpri_link(Radio1),
	ok = nci_dci_actions:cpri_link_ind(Radio1 ++ [{availStatus, 1}]),

	%% Add Radio Control
	nci_dci_actions:add_radio_control(Radio1 ++ [{expectedSigNo, ?RICM_ADD_RADIO_CTL_CFM}]),
	nci_dci_actions:radio_control_ind(Radio1 ++ [{connStatus, 1}]),

	nci_common_utils:coli_cmd("lhsh " ++ RuLnhPath ++ " lmclist", "SlotProt State"),

	nci_bci_states:set_state([{state, disabled}]),

	nci_dci_actions:start_timing_distribution(Radio1 ++ [{expectedSigNo, ?RICM_START_TIMING_DISTRIBUTION_REJ}]),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id DCI_STD4
%%
%% $Header
%%  Timing Distribution, Unused address
%%
%% $Description
%%  Test timing distribution when DU BC is in main operational and no CPRI link is up.
%%
%% $Requirements
%%  N/A
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $History
%%  -										{
%%
%% $Precondition
%%  The DU BC is in state operational
%%
%% $Action
%%  Send a RICM_START_TIMING_DISTRIBUTION_REQ
%%
%% $Result
%%  A RICM_START_TIMING_DISTRIBUTION_CFM is received
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-10-25, EEDAJA
%%    First version
%%
%%------------------------------------------------------------------------------
dci_std4() ->
	[{userdata,[{wp, ""},
				{requirement, "-"},
				{slogan, "Timing Distribution, Unused address (Invalid ruId)"},
				{hwConfig, hwConfigA}]}].

dci_std4(_Config) ->
	ct:pal("dci_std4"),

	% Set state, make audit, establish BCI and DCI connections, subscribe BCI faults
	set_state_and_connect( operational ),

	Radio1 = nci_ricm_utils:get_first_radio(),
	RuLnhPath = proplists:get_value(ruLnhPath, Radio1),

	%% Start CPRI
	ok = nci_dci_actions:start_cpri_link(Radio1),
	ok = nci_dci_actions:cpri_link_ind(Radio1 ++ [{availStatus, 1}]),

	%% Add Radio Control
	nci_dci_actions:add_radio_control(Radio1 ++ [{expectedSigNo, ?RICM_ADD_RADIO_CTL_CFM}]),
	nci_dci_actions:radio_control_ind(Radio1 ++ [{connStatus, 1}]),

	nci_common_utils:coli_cmd("lhsh " ++ RuLnhPath ++ " lmclist", "SlotProt State"),

	nci_dci_actions:start_timing_distribution([{ruId,8},
												{expectedSigNo, ?RICM_START_TIMING_DISTRIBUTION_REJ},
												{errorDescription, {regexp, "ruId not in use*"}}]),
	%% Reset CPRI Link
	ok = nci_dci_actions:reset_cpri_link(Radio1),
	ok = nci_dci_actions:reset_cpri_link_ind(Radio1),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id DCI_STD5
%%
%% $Header
%%  Timing Distribution, No Radio Control
%%
%% $Description
%%  Test timing distribution when DU BC is in main state operational and no Radio Control is up
%%
%% $Requirements
%%  N/A
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state operational.
%%
%% $Action
%%  Send a RICM_START_TIMING_DISTRIBUTION_REQ.
%%
%% $Result
%%  A RICM_START_TIMING_DISTRIBUTION_CFM is received
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-10-25, EEDAJA
%%    First version
%%
%%------------------------------------------------------------------------------
dci_std5() ->
	[{userdata,[{wp, ""},
				{requirement, "-"},
				{slogan, "Timing Distribution, No Radio Control"},
				{hwConfig, hwConfigA}]}].

dci_std5(_Config) ->
	ct:pal("dci_std5"),

	% Set state, make audit, establish BCI and DCI connections, subscribe BCI faults
	set_state_and_connect( operational ),

	Radio1 = nci_ricm_utils:get_first_radio(),

	%% Start CPRI
	ok = nci_dci_actions:start_cpri_link(Radio1),
	ok = nci_dci_actions:cpri_link_ind(Radio1 ++ [{availStatus, 1}]),

	nci_dci_actions:start_timing_distribution([{ruId,8},
												{expectedSigNo, ?RICM_START_TIMING_DISTRIBUTION_REJ},
												{errorDescription, {regexp, "ruId not in use*"}}]),
	%% Reset CPRI Link
	ok = nci_dci_actions:reset_cpri_link(Radio1),
	ok = nci_dci_actions:reset_cpri_link_ind(Radio1),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%##############################################################################
%% $ChapterH2 Fault Indication
%%
%%
%% $End
%%##############################################################################

%%##############################################################################
%% $ChapterH2 Fault Indication
%%
%%
%% $End
%%##############################################################################

%%------------------------------------------------------------------------------
%% $Id DCI_FI1
%%
%% $Header
%%  Fault indication Not in operation due to high bit error rate
%%
%% $Description
%%  Verify Fault Indication Not in operation due to high bit error rate. 
%%  Fault indication should cease when bit error rate is turned off
%%
%% $Requirements
%%  CBD_RICM_LTE-LINK-FAULT_FU:1:C
%%  CBD_RICM_SUBSCRIBE-FAULT_FU:1:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  One CPRIC-NG in Sniffer Mode connected between DU and a Radio
%%
%% $Type
%%  Regression
%%
%% $Precondition
%%  The DU BC is in state starting.
%%  CPRI Link Started 
%%  DCI fault subscribtion performed
%%
%% $Action_1
%%  Start LOS BER with shellcommand "set_los_ber_emulator 1 0" on CPRI converter
%%
%% $Result_1a
%%  DC_FAULT_IND is received with parameters:
%%  * faultId = ELIB_CONST_FH_FAULT_ID_LF_STABILITY
%%  * faultDescription = "Temporary not in operation"
%%
%% $Result_1b
%%  DC_FAULT_CEASE_IND is received with parameters:
%%  * faultId = ELIB_CONST_FH_FAULT_ID_LF_STABILITY
%%
%% $Result_1c
%%  DC_FAULT_IND is received with parameters:
%%  * faultId = ELIB_CONST_FH_FAULT_ID_LINK_FAILURE
%%  * faultDescription = "Not in operation"
%%
%% $Result_1d
%%  START_CPRI_LINK_IND with parameters:
%%  * ruId = <according to configuration>
%%  * availStatus = 0
%%
%% $Action_2
%%  Cease LOS BER with shellcommand "set_los_ber_emulator 0 0" on CPRI converter
%%
%% $Result_2
%%  DC_FAULT_CEASE_IND is received with parameters:
%%  * faultId = ELIB_CONST_FH_FAULT_ID_LINK_FAILURE
%%
%% $Result_2
%%  START_CPRI_LINK_IND with parameters:
%%  * ruId = <according to configuration>
%%  * availStatus = 1
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  2013-07-12, EBACEMI
%%
%% Revision history:
%%  2013-07-19, QSATDHA
%%    First version
%%  2013-10-29, ejonuna
%%    Updated with library function for loss of signal due to high bit error rate
%%  2014-03-10, emasnok
%%    Added checks for new fault signal: "Temporary not in operation"
%%
%%------------------------------------------------------------------------------
dci_fi1() ->
	[{userdata,[{wp, ""},
				{requirement, "CBD_RICM_LTE-LINK-FAULT_FU:1:C, CBD_RICM_SUBSCRIBE-FAULT_FU:1:C"},
				{slogan, "Fault indication Not in operation due to high bit error rate"},
				{hwConfig, hwConfig_CPRI_Converter}]}].

dci_fi1(_Config) ->
	ct:pal("dci_fi1"),
	{Radio, CPRI_Converter} = dci_fi_pre(),

	nci_cpri_converter:set_los_ber_emulator(CPRI_Converter,?CPRI_CONVERTER_MODE_ENABLE,?CPRI_CONVERTER_PORT_A),
	
	%% Check for Fault Ind on CPRI Link

	FaultId1 = nci_dci_actions:fault_ind([{faultId, ?ELIB_CONST_FH_FAULT_ID_LF_STABILITY},
										  {faultDescription, {regexp, "Temporary not in operation*"}}]),
	
	ok = nci_dci_actions:fault_cease_ind([{faultId, FaultId1}]),


	FaultId2 = nci_dci_actions:fault_ind([{faultId, ?ELIB_CONST_FH_FAULT_ID_LINK_FAILURE},
										  {faultDescription, {regexp, "Not in operation*"}}]),

	ok = nci_dci_actions:cpri_link_ind(Radio ++ [{availStatus, 0}]),

	%% Disable Faults on CPRI Converter
	nci_cpri_converter:set_los_ber_emulator(CPRI_Converter,?CPRI_CONVERTER_MODE_DISABLE,?CPRI_CONVERTER_PORT_A),

	%% Check if Fault Ind is Ceased on CPRI Link
	ok = nci_dci_actions:fault_cease_ind([{faultId, FaultId2}]),
	ok = nci_dci_actions:cpri_link_ind(Radio ++ [{availStatus, 1}]),

	dci_fi_post(Radio, CPRI_Converter).


%%------------------------------------------------------------------------------
%% $Id DCI_FI2
%%
%% $Header
%%  Fault indication Not in operation due to disabled laser
%%
%% $Description
%%  Verify Fault Indication Not in operation due to disabled laser.
%%  The fault indication should cease when laser is enabled
%%
%% $Requirements
%%  CBD_RICM_LTE-LINK-FAULT_FU:1:C
%%  CBD_RICM_SUBSCRIBE-FAULT_FU:1:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  One CPRIC-NG in Sniffer Mode connected between DU and a Radio
%%
%% $Type
%%  Regression
%%
%% $Precondition
%%  The DU BC is in state starting.
%%  CPRI Link Started 
%%  DCI fault subscribtion performed
%%
%% $Action_1
%%  Start LOS LASER on CPRI converter with shellcommand "set_los_laser_emulator 1 0"
%%
%% $Result_1a
%%  DC_FAULT_IND is received with parameters:
%%  * faultId = ELIB_CONST_FH_FAULT_ID_LF_STABILITY
%%  * faultDescription = "Temporary not in operation"
%%
%% $Result_1b
%%  DC_FAULT_CEASE_IND is received with parameters:
%%  * faultId = ELIB_CONST_FH_FAULT_ID_LF_STABILITY
%%
%% $Result_1c
%%  DC_FAULT_IND is received with parameters:
%%  * faultId = ELIB_CONST_FH_FAULT_ID_LINK_FAILURE
%%  * faultDescription = "Not in operation"
%%
%% $Result_1d
%%  START_CPRI_LINK_IND with parameters:
%%  * ruId = <according to configuration>
%%  * availStatus = 0
%%
%% $Action_2
%%  Cease LOS LASER on CPRI converter with shellcommand "set_los_laser_emulator 0 0"
%%
%% $Result_2
%%  DC_FAULT_CEASE_IND is received with parameters:
%%  * faultId = ELIB_CONST_FH_FAULT_ID_LINK_FAILURE
%%
%% $Result_2
%%  START_CPRI_LINK_IND with parameters:
%%  * ruId = <according to configuration>
%%  * availStatus = 1
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%
%% Revision history:
%%  2013-10-29, ejonuna
%%    First version
%%  2014-03-10, emasnok
%%    Added checks for new fault signal: "Temporary not in operation"
%%
%%------------------------------------------------------------------------------
dci_fi2() ->
	[{userdata,[{wp, ""},
				{requirement, "CBD_RICM_LTE-LINK-FAULT_FU:1:C, CBD_RICM_SUBSCRIBE-FAULT_FU:1:C"},
				{slogan, "Fault indication Not in operation due to disabled laser"},
				{hwConfig, hwConfig_CPRI_Converter}]}].

dci_fi2(_Config) ->
	ct:pal("dci_fi1"),
	{Radio, CPRI_Converter} = dci_fi_pre(),
	nci_cpri_converter:set_los_laser_emulator(CPRI_Converter,?CPRI_CONVERTER_MODE_ENABLE,?CPRI_CONVERTER_PORT_A),
	
	%% Check for Fault Ind on CPRI Link

	FaultId1 = nci_dci_actions:fault_ind([{faultId, ?ELIB_CONST_FH_FAULT_ID_LF_STABILITY},
										  {faultDescription, {regexp, "Temporary not in operation*"}}]),
	
	ok = nci_dci_actions:fault_cease_ind([{faultId, FaultId1}]),


	FaultId2 = nci_dci_actions:fault_ind([{faultId, ?ELIB_CONST_FH_FAULT_ID_LINK_FAILURE},
										  {faultDescription, {regexp, "Not in operation*"}}]),

	ok = nci_dci_actions:cpri_link_ind(Radio ++ [{availStatus, 0}]),

	%% Disable Faults on CPRI Converter
	nci_cpri_converter:set_los_laser_emulator(CPRI_Converter,?CPRI_CONVERTER_MODE_DISABLE,?CPRI_CONVERTER_PORT_A),

	%% Check if Fault Ind is Ceased on CPRI Link
	ok = nci_dci_actions:fault_cease_ind([{faultId, FaultId2}]),
	ok = nci_dci_actions:cpri_link_ind(Radio ++ [{availStatus, 1}]),

	dci_fi_post(Radio, CPRI_Converter).

%%------------------------------------------------------------------------------
%% $Id DCI_FI3
%%
%% $Header
%%  Fault Indication Not in operation due to Loss of frame 
%%
%% $Description
%%  Verify Fault Indication Not in operation due to Loss of Frame is generated due to command 
%%  issued on CPRI-C. Fault cease indication should be generated when LOF is turned
%%  on CPRI-C
%%
%% $Requirements
%%  CBD_RICM_LTE-LINK-FAULT_FU:1:C
%%  CBD_RICM_SUBSCRIBE-FAULT_FU:1:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  One CPRIC-NG in Sniffer Mode connected between DU and a Radio
%%
%% $Type
%%  Regression
%%
%% $Precondition
%%  The DU BC is in state starting.
%%  CPRI Link started 
%%  DCI fault subscribtion performed
%%
%% $Action_1
%%  Start LOF with shellcommand "set_lof_emulator 1 0" on CPRI converter
%%
%% $Result_1a
%%  DC_FAULT_IND is received with parameters:
%%  * faultId = ELIB_CONST_FH_FAULT_ID_LF_STABILITY
%%  * faultDescription = "Temporary not in operation"
%%
%% $Result_1b
%%  DC_FAULT_CEASE_IND is received with parameters:
%%  * faultId = ELIB_CONST_FH_FAULT_ID_LF_STABILITY
%%
%% $Result_1c
%%  DC_FAULT_IND is received with parameters:
%%   * faultId = ELIB_CONST_FH_FAULT_ID_LINK_FAILURE
%%   * faultDescription = "Not in operation"
%%
%% $Result_1d
%%  START_CPRI_LINK_IND with parameters:
%%  * ruId = <according to configuration>
%%  * availStatus = 0
%%
%% $Action_2
%%  Cease LOF with shellcommand "set_lof_emulator 0 0" on CPRI converter
%%
%% $Result_2
%%  DC_FAULT_CEASE_IND is received with parameters:
%%  * faultId = ELIB_CONST_FH_FAULT_ID_LINK_FAILURE
%%
%% $Result_2
%%  START_CPRI_LINK_IND with parameters:
%%  * ruId = <according to configuration>
%%  * availStatus = 1
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  2013-07-12, EBACEMI
%%
%% Revision history:
%%  2013-07-19, QSATDHA
%%    First version
%%  2013-10-29, ejonuna
%%    Updated with library function for loss of signal due to loss of frame
%%  2014-03-10, emasnok
%%    Added checks for new fault signal: "Temporary not in operation"
%%
%%------------------------------------------------------------------------------
dci_fi3() ->
	[{userdata,[{wp, ""},
				{requirement, "CBD_RICM_LTE-LINK-FAULT_FU:1:C, CBD_RICM_SUBSCRIBE-FAULT_FU:1:C"},
				{slogan, "Fault Indication Not in operation due to Loss of frame"},
				{hwConfig, hwConfig_CPRI_Converter}]}].

dci_fi3(_Config) ->

	ct:pal("dci_fi3"),
	
	{Radio, CPRI_Converter} = dci_fi_pre(),

	nci_cpri_converter:set_lof_emulator(CPRI_Converter,?CPRI_CONVERTER_MODE_ENABLE,?CPRI_CONVERTER_PORT_A),
	
	%% Check for Fault Ind on CPRI Link
	FaultId1 = nci_dci_actions:fault_ind([{faultId, ?ELIB_CONST_FH_FAULT_ID_LF_STABILITY},
										  {faultDescription, {regexp, "Temporary not in operation*"}}]),
	
	ok = nci_dci_actions:fault_cease_ind([{faultId, FaultId1}]),

	FaultId2 = nci_dci_actions:fault_ind([{faultId, ?ELIB_CONST_FH_FAULT_ID_LINK_FAILURE},
										  {faultDescription, {regexp, "Not in operation*"}}]),
	ok = nci_dci_actions:cpri_link_ind(Radio ++ [{availStatus, 0}]),

	%% Disable Faults on CPRI Converter
	nci_cpri_converter:set_lof_emulator(CPRI_Converter,?CPRI_CONVERTER_MODE_DISABLE,?CPRI_CONVERTER_PORT_A),

	%% Check if Fault Ind is Ceased on CPRI Link
	ok = nci_dci_actions:fault_cease_ind([{faultId, FaultId2}]),
	ok = nci_dci_actions:cpri_link_ind(Radio ++ [{availStatus, 1}]),

	dci_fi_post(Radio, CPRI_Converter).

%%------------------------------------------------------------------------------
%% $Id DCI_FI4
%%
%% $Header
%%  Fault indication Not in operation due to Jitter Buffer Overflow
%%
%% $Description
%%  Verify Fault Indication due to Jitter Buffer Overflow by issuing commands on 
%%  CPRI-C. Fault cease indication should be received when JBO is turned off 
%% 
%% $Requirements
%%  CBD_RICM_LTE-LINK-FAULT_FU:1:C
%%  CBD_RICM_SUBSCRIBE-FAULT_FU:1:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  One CPRIC-NG in Sniffer Mode connected between DU and a Radio
%%
%% $Type
%%  Regression
%%
%% $Precondition
%%  The DU BC is in state starting.
%%  CPRI Link started 
%%  DCI fault subscribtion performed
%%
%% $Action_1
%%  Start JBO with shellcommand "set_jbo_emulator 1" on CPRI converter
%%
%% $Result_1a
%%  DC_FAULT_IND is received with parameters:
%%  * faultId = ELIB_CONST_FH_FAULT_ID_LF_STABILITY
%%  * faultDescription = "Temporary not in operation"
%%
%% $Result_1b
%%  DC_FAULT_CEASE_IND is received with parameters:
%%  * faultId = ELIB_CONST_FH_FAULT_ID_LF_STABILITY
%%
%% $Result_1c
%%  DC_FAULT_IND is received with parameters:
%%  * faultId = ELIB_CONST_FH_FAULT_ID_LINK_FAILURE
%%  * faultDescription = "Not in operation"
%%
%% $Result_1d
%%  START_CPRI_LINK_IND with parameters:
%%  * ruId = <according to configuration>
%%  * availStatus = 0
%%
%% $Action_2
%%  Cease JBO with shellcommand "set_jbo_emulator 0" on CPRI converter
%%
%% $Result_2
%%  DC_FAULT_CEASE_IND is received with parameters:
%%   faultId = ELIB_CONST_FH_FAULT_ID_LINK_FAILURE
%%
%% $Result_2
%%  START_CPRI_LINK_IND with parameters:
%%  * ruId = <according to configuration>
%%  * availStatus = 1
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  2013-07-12, EBACEMI
%%
%% Revision history:
%%  2013-07-19, QSATDHA
%%    First version
%%  2013-10-29, ejonuna
%%    Updated with library function for loss of signal due to jitter buffer overflow
%%  2014-03-10, emasnok
%%    Added checks for new fault signal: "Temporary not in operation"
%%
%%------------------------------------------------------------------------------
dci_fi4() ->
	[{userdata,[{wp, ""},
				{requirement, "CBD_RICM_LTE-LINK-FAULT_FU:1:C, CBD_RICM_SUBSCRIBE-FAULT_FU:1:C"},
				{slogan, "Fault indication Not in operation due to Jitter Buffer Overflow"},
				{hwConfig, hwConfig_CPRI_Converter}]}].

dci_fi4(_Config) ->

	ct:pal("dci_fi4"),
	{Radio, CPRI_Converter} = dci_fi_pre(),

	nci_cpri_converter:set_jbo_emulator(CPRI_Converter,?CPRI_CONVERTER_MODE_ENABLE),
	
	%% Check for Fault Ind on CPRI Link

	FaultId1 = nci_dci_actions:fault_ind([{faultId, ?ELIB_CONST_FH_FAULT_ID_LF_STABILITY},
										  {faultDescription, {regexp, "Temporary not in operation*"}}]),
	
	ok = nci_dci_actions:fault_cease_ind([{faultId, FaultId1}]),

	FaultId2 = nci_dci_actions:fault_ind([{faultId, ?ELIB_CONST_FH_FAULT_ID_LINK_FAILURE},
										  {faultDescription, {regexp, "Not in operation*"}}]),
	
	ok = nci_dci_actions:cpri_link_ind(Radio ++ [{availStatus, 0}]),

	%% Disable Faults on CPRI Converter
	nci_cpri_converter:set_jbo_emulator(CPRI_Converter,?CPRI_CONVERTER_MODE_DISABLE),

	%% Check if Fault Ind is Ceased on CPRI Link
	ok = nci_dci_actions:fault_cease_ind([{faultId, FaultId2}]),
	ok = nci_dci_actions:cpri_link_ind(Radio ++ [{availStatus, 1}]),

	dci_fi_post(Radio, CPRI_Converter).


%%------------------------------------------------------------------------------
%% $Id DCI_FI5
%%
%% $Header
%%  Fault indication High bit error rate on CPRI link
%%
%% $Description
%%  Verify Fault Indication High bit error rate on CPRI link by issuing commands on 
%%  CPRI-C. Using 1E-6 bit errors since the ELIB_CONST_FH_FAULT_ID_LF_STABILITY is triggered after 4096 bit errors.
%% 
%% $Requirements
%%  CBD_RICM_LTE-LINK-FAULT_FU:1:C
%%  CBD_RICM_SUBSCRIBE-FAULT_FU:1:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  One CPRIC-NG in Sniffer Mode connected between DU and a Radio
%%
%% $Type
%%  Regression
%%
%% $Precondition
%%  The DU BC is in state starting.
%%  CPRI Link and O&M started 
%%  DCI fault subscribtion performed
%%
%% $Action_2
%%  Start bit error in one direction with shellcommand "set_bit_error_emulator 3 6 0" on CPRI converter
%%
%% $Result_2
%%  DC_FAULT_IND is received with parameters:
%%  * faultId = ELIB_CONST_FH_FAULT_ID_LF_STABILITY
%%  * faultDescription = "High bit error rate on CPRI link*"
%%
%% $Action_3
%%  Disable bit error with shellcommand "set_bit_error_emulator 0 0 0" on CPRI converter
%%
%% $Action_4
%%  Start bit error in one the other direction with shellcommand "set_bit_error_emulator 3 6 1" on CPRI converter
%%
%% $Result_4
%%  DC_FAULT_IND is received with parameters:
%%  * faultId = ELIB_CONST_FH_FAULT_ID_LF_STABILITY
%%  * faultDescription = "High bit error rate on CPRI link*"
%%
%% $Action_5
%%  Disable bit error with shellcommand "set_bit_error_emulator 0 0 0" on CPRI converter
%%
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%
%% Revision history:
%%  2013-10-29, ejonuna
%%    First version
%%------------------------------------------------------------------------------
dci_fi5() ->
	[{userdata,[{wp, ""},
				{requirement, "CBD_RICM_LTE-LINK-FAULT_FU:1:C, CBD_RICM_SUBSCRIBE-FAULT_FU:1:C"},
				{slogan, "Fault indication High bit error rate on CPRI link"},
				{hwConfig, hwConfig_CPRI_Converter}]}].

dci_fi5(_Config) ->

	ct:pal("dci_fi5"),
	{Radio, CPRI_Converter} = dci_fi_pre(),
	nci_dci_actions:add_radio_control(Radio),
	nci_dci_actions:radio_control_ind(Radio ++ [{connStatus, 1},
										{radioSoftware, application}]),

	%%Test bit errors in one direction first
	nci_cpri_converter:set_bit_error_emulator(CPRI_Converter,?CPRI_CONVERTER_BIT_ERROR_UNIFORM_DISTRIBUTION,6,?CPRI_CONVERTER_PORT_A),
	
	%% Check for Fault Ind on CPRI Link
	nci_dci_actions:fault_ind([{faultId, ?ELIB_CONST_FH_FAULT_ID_LF_STABILITY},
					{faultDescription, {regexp, "High bit error rate on CPRI link*"}}]),

	%% Disable Faults on CPRI Converter. Note that the cease will occure after the reset of the cpri link since (else it takes 24h before the fault will be ceased).
	nci_cpri_converter:set_bit_error_emulator(CPRI_Converter,?CPRI_CONVERTER_BIT_ERROR_DISABLE,0,?CPRI_CONVERTER_PORT_A),

	%%Test bit errors in the other direction
	nci_cpri_converter:set_bit_error_emulator(CPRI_Converter,?CPRI_CONVERTER_BIT_ERROR_UNIFORM_DISTRIBUTION,6,?CPRI_CONVERTER_PORT_B),

	%% Check for Fault Ind on CPRI Link
	nci_dci_actions:fault_ind([{faultId, ?ELIB_CONST_FH_FAULT_ID_LF_STABILITY},
					{faultDescription, {regexp, "High bit error rate on CPRI link*"}}]),

	%% Disable Faults on CPRI Converter. Note that the cease will occure after the reset of the cpri link since (else it takes 24h before the fault will be ceased).
	nci_cpri_converter:set_bit_error_emulator(CPRI_Converter,?CPRI_CONVERTER_BIT_ERROR_DISABLE,0,?CPRI_CONVERTER_PORT_B),

	ok = nci_dci_actions:reset_cpri_link(Radio),
	ok = nci_dci_actions:reset_cpri_link_ind(Radio),

	ok = nci_dci_actions:start_cpri_link(Radio),
	ok = nci_dci_actions:cpri_link_ind(Radio ++ [{availStatus, 1}]),

	nci_dci_actions:add_radio_control(Radio),
	nci_dci_actions:radio_control_ind(Radio ++ [{connStatus, 1}]),

	ok = nci_dci_actions:fault_cease_ind([{faultId,?ELIB_CONST_FH_FAULT_ID_LF_STABILITY}]),
	ok = nci_dci_actions:fault_cease_ind([{faultId,?ELIB_CONST_FH_FAULT_ID_LF_STABILITY}]),

	dci_fi_post(Radio, CPRI_Converter).
		
%%------------------------------------------------------------------------------
%% $Id DCI_FI_L1_RESET
%%
%% $Header
%%  Fault indication when L1 reset
%%
%% $Description
%%  Verify that Fault Indication is received when L1 Reset is turned on/off 
%%  by issuing commands on CPRI-C
%%
%% $Requirements
%%  N/A
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  One CPRIC-NG in Sniffer Mode connected between DU and a Radio
%%
%% $Type
%%  Regression
%%
%% $Precondition
%%   The DU BC is in state starting.
%%   CPRI Link started 
%%   DCI fault subscription performed
%%
%% $Action_1
%%  Start L1 reset on CPRI converter with shellcommand " set_z130_override_emulator 1 0 0 0 0 1"
%%
%% $Result_1a
%%  DC_FAULT_IND is received with parameters:
%%  * faultId = ELIB_CONST_FH_FAULT_ID_LF_STABILITY
%%  * faultDescription = "Temporary not in operation"
%%
%% $Result_1b
%%  DC_FAULT_CEASE_IND is received with parameters:
%%  * faultId = ELIB_CONST_FH_FAULT_ID_LF_STABILITY
%%
%% $Result_1c
%%  DC_FAULT_IND is received with parameters:
%%  * faultId = ELIB_CONST_FH_FAULT_ID_LINK_FAILURE
%%  * faultDescription = "Not in operation"
%%
%% $Result_1d
%%  START_CPRI_LINK_IND with parameters:
%%  * ruId = <according to configuration>
%%  * availStatus = 0
%%
%% $Action_2
%%  Cease L1 reset on CPRI converter with shellcommand " set_z130_override_emulator 0 0 0 0 0 1"
%%
%% $Result_2
%%  DC_FAULT_CEASE_IND is received with parameters:
%%  * faultId = ELIB_CONST_FH_FAULT_ID_LINK_FAILURE
%%
%% $Result_2
%%  START_CPRI_LINK_IND with parameters:
%%  * ruId = <according to configuration>
%%  * availStatus = 1
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  2013-07-12, EBACEMI
%%
%% Revision history:
%%  2013-07-19, QSATDHA
%%    First version
%%  2013-11-05, ejonuna
%%    Updated with library function for Z130 error bits
%%  2014-03-10, emasnok
%%    Added checks for new fault signal: "Temporary not in operation"
%%
%%------------------------------------------------------------------------------
dci_fi_l1_reset() ->
	[{userdata,[{wp, ""},
				{requirement, "-"},
				{slogan, "Fault Indication when L1 Reset"},
				{hwConfig, hwConfig_CPRI_Converter}]}].

dci_fi_l1_reset(_Config) ->

	ct:pal("dci_fi_l1_reset"),
	{Radio, CPRI_Converter} = dci_fi_pre(), 

	nci_cpri_converter:set_z130_override_emulator(CPRI_Converter,
												  ?CPRI_CONVERTER_ERROR_BIT_SET_1,
												  ?CPRI_CONVERTER_ERROR_BIT_SET_0,
												  ?CPRI_CONVERTER_ERROR_BIT_SET_0,
												  ?CPRI_CONVERTER_ERROR_BIT_SET_0,
												  ?CPRI_CONVERTER_ERROR_BIT_SET_0,
												  ?CPRI_CONVERTER_PORT_BOTH),

	%% Check for Fault Ind on CPRI Link
	FaultId1 = nci_dci_actions:fault_ind([{faultId, ?ELIB_CONST_FH_FAULT_ID_LF_STABILITY},
										  {faultDescription, {regexp, "Temporary not in operation*"}}]),
	
	ok = nci_dci_actions:fault_cease_ind([{faultId, FaultId1}]),

	FaultId2 = nci_dci_actions:fault_ind([{faultId, ?ELIB_CONST_FH_FAULT_ID_LINK_FAILURE},
										  {faultDescription, {regexp, "Not in operation*"}}]),

	ok = nci_dci_actions:cpri_link_ind(Radio ++ [{typeOfUnit, '_'},{availStatus, 0}]),

	nci_cpri_converter:set_z130_override_emulator(CPRI_Converter,
												  ?CPRI_CONVERTER_ERROR_BIT_SET_0,
												  ?CPRI_CONVERTER_ERROR_BIT_SET_0,
												  ?CPRI_CONVERTER_ERROR_BIT_SET_0,
												  ?CPRI_CONVERTER_ERROR_BIT_SET_0,
												  ?CPRI_CONVERTER_ERROR_BIT_SET_0,
												  ?CPRI_CONVERTER_PORT_BOTH),

	ok = nci_dci_actions:cpri_link_ind(Radio ++ [{typeOfUnit, '_'},{availStatus, 1}]),
	ok = nci_dci_actions:fault_cease_ind([{faultId, FaultId2}]),

	dci_fi_post(Radio, CPRI_Converter).

%%
%%  DCI_FI Generic testcase
%%
dci_fi_pre() ->

	%% Set state, make audit, establish BCI and DCI connections, subscribe faults
	set_state_and_connect( starting_lmc_loaded ),

	%% Subscribe Faults DCI
	ok = nci_dci_actions:subscribe_faults([]),
	
	Radio = nci_ricm_utils:get_first_cpri_converter_connected_radio(),

	CPRI_Converter = nci_ricm_utils:get_cpri_converter(Radio),

	nci_cpri_converter:enable_emulator(CPRI_Converter),
	
	%% Start CPRI
	ok = nci_dci_actions:start_cpri_link(Radio),
	ok = nci_dci_actions:cpri_link_ind(Radio ++ [{availStatus, 1}]),
	{Radio, CPRI_Converter}.

dci_fi_post(Radio, CPRI_Converter) ->

	%% Reset CPRI
	ok = nci_dci_actions:reset_cpri_link(Radio),
	ok = nci_dci_actions:reset_cpri_link_ind(Radio),

	nci_cpri_converter:disable_emulator(CPRI_Converter),

	%% Check that NO BC/DC_FAULT_IND is generated
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id DCI_FI_REMOVE_CABLE
%%
%% $Header
%%  Removal of the optical cable
%%
%% $Description
%%  remove optical cable manual
%%
%% $Requirements
%%  CBD_RICM_LTE-LINK-FAULT_FU:1:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  A connection establish procedure has been performed.
%%
%%  The DU BC is in state starting.
%%
%%  Radio control for ruId 1, port 4 is added
%%
%% $Action
%%  Remove CPRI cable to RU
%%
%% $Result
%%  -
%%
%% $Action
%%  Check the T&E log with shellcommand "te log read"
%%
%% $Result
%%  The output contains "RICM_START_CPRI_LINK_IND availstatus 0"
%%
%% $Postcondition
%%  -
%%
%% $End
%%------------------------------------------------------------------------------

%%------------------------------------------------------------------------------
%% $Id DCI_FI_REMOVE_SFP
%%
%% $Header
%%  Removal of SFP, state starting
%%
%% $Description
%%  remove SFP manual
%%
%% $Requirements
%%  CBD_RICM_LTE-SFP-FAULT_FU:1:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state starting.
%%
%%  Radio control for ruId 1, port 4 is added
%%
%% $Action
%%  Remove CPRI cable to RU
%%
%% $Result
%%  -
%%
%% $Action
%%  Check the T&E log with shellcommand "te log read"
%%
%% $Result
%%  The output contains "RICM_START_CPRI_LINK_IND availstatus 0"
%%
%% $Postcondition
%%  -
%%
%% $End
%%------------------------------------------------------------------------------

%%------------------------------------------------------------------------------
%% $Id DCI_FI_TXFAULT_SFP
%%
%% $Header
%%  Faulty SFP info in HWLOG
%%
%% $Description
%%  TX Fault SFP used. Info logged in HWLOG.
%%
%% $Requirements
%%  CBD_RICM_LTE-SFP-FAULT_FU:1:C
%%
%%  CBD_RICM_SUBSCRIBE-FAULT_FU:2:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  Faulty SFP needs to be used
%%
%%  The DU BC is in state starting.
%%
%%  Radio control for ruId 1, port 4 is added
%%
%% $Action
%%  Test the connection with shellcommand "lhsh BXP_3_1 lmclist"
%%
%% $Result
%%  The shellcommand is successful
%%
%% $Action
%%  Change SFP on port 4 to an SFP with TX Fault
%%
%% $Result
%%  DC_FAULT_IND is received with parameters:
%%
%%  faultId = HW_FAULT
%%
%%  faultDescription = "No SFP, port 4"
%%
%% $Result
%%  DC_FAULT_IND is received with parameters:
%%
%%  faultId = HW_FAULT
%%
%%  faultDescription = "TX Fault, port 4"
%%
%% $Result
%%  DC_FAULT_CEASE_IND is received with parameters:
%%
%%%faultId = HW_FAULT
%%
%% $Result
%%  Check that SFP TX fault is in HW log the as the normal SFP information is written but with extra information "TX fault":
%%
%%  "200;SFP0#{portNo}
%%
%%  s+[
%%
%%  w
%%
%%  s&]+;prod
%%
%%  s+[
%%
%%  w-]+
%%
%%  s*;rev
%%
%%  s+
%%
%%  w+
%%
%%  s+;TX fault
%%
%%  s+"
%%
%% $Action
%%  Change SFP on port 4 to a working SFP
%%
%% $Result
%%  DC_FAULT_IND is received with parameters:
%%
%%  faultId = HW_FAULT
%%
%%  faultDescription = "No SFP, port 4"
%%
%% $Result
%%  DC_FAULT_CEASE_IND is received with parameters:
%%
%%  faultId = HW_FAULT
%%
%% $Result
%%  DC_FAULT_CEASE_IND is received with parameters:
%%
%%  faultId = HW_FAULT
%%
%% $Postcondition
%%  -
%%
%% $End
%%------------------------------------------------------------------------------

%%------------------------------------------------------------------------------
%% $Id DCI_FI_TXFAULT_SFP_RELOAD
%%
%% $Header
%%  Faulty SFP after reload
%%
%% $Description
%%  TX Fault SFP used. Info logged in HWLOG after restart.
%%
%% $Requirements
%%  CBD_RICM_LTE-SFP-FAULT_FU:1:C
%%
%%  CBD_RICM_SUBSCRIBE-FAULT_FU:2:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  Faulty SFP needs to be used
%%
%%  The DU BC is in state starting.
%%
%%  Ensure CPRI link is started (not up and running due to TX fault)
%%
%%  Erase HWLOG.
%%
%% $Action
%%  Restart the node.Load LMCEnsure CPRI link is started (not up and running due to TX fault).
%%
%% $Result
%%  Check that SFP TX fault is in HW log the as the normal SFP information is written but with extra information "TX fault":
%%
%%  "200;SFP0#{portNo}
%%
%%  s+[
%%
%%  w
%%
%%  s&]+;prod
%%
%%  s+[
%%
%%  w-]+
%%
%%  s*;rev
%%
%%  s+
%%
%%  w+
%%
%%  s+;TX fault
%%
%%  s+"
%%
%% $Postcondition
%%  -
%%
%% $End
%%------------------------------------------------------------------------------


%%------------------------------------------------------------------------------
%% $Id DCI_FI_NO_SFP
%%
%% $Header
%%  No SFP used
%%
%% $Description
%%  No SFP used
%%
%% $Requirements
%%  BD_RICM_SUBSCRIBE-FAULT_FU:2:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state starting.
%%
%%  No SFP on port 5
%%
%% $Action
%%  Send a START_CPRI_LINK_REQ with parameters:
%%
%%  ruId = 17
%%
%%  port = 5
%%
%%  cascade = 1
%%
%%  primary = 1
%%
%% $Result
%%  A START_CPRI_LINK_CFM is received with parameters:
%%
%%  ruId = 17
%%
%% $Result
%%  DC_FAULT_IND is received with parameters:
%%
%%  faultId = HW_FAULT
%%
%%  faultDescription = "No SFP, port 5"
%%
%% $Action
%%  Plug in an SFP in port 5
%%
%% $Result
%%  DC_FAULT_CEASE_IND is received with parameters:
%%
%%  faultId = HW_FAULT
%%
%%  additionalData = "No SFP, port 5"
%%
%% $Postcondition
%%  -
%%
%% $End
%%------------------------------------------------------------------------------

%%------------------------------------------------------------------------------
%% $Id DCI_FI_POWER_FAILURE_ON_RADIO
%%
%% $Header
%%  Fault ind during power failure
%%
%% $Description
%%  Fault indication when power failure on radio.
%%
%% $Requirements
%%  CBD_RICM_LTE-PFA-FAULT_FU:1:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state starting.
%%
%%  Radio control for ruId 1, port 4 is added
%%
%% $Action
%%  Simulate a RU power failure with shellcommand "lhsh BXP_3_1 wfpga 0x4C38 0
%%
%% $Result
%%  DC_FAULT_IND is received with parameters:
%%
%%  faultId = HW_FAULT
%%
%%  faultDescription = "Power failure alarm, port 5"
%%
%% $Postcondition
%%  -
%%
%% $End
%%------------------------------------------------------------------------------

%%------------------------------------------------------------------------------
%% $Id DCI_FI_DELAY_ERROR
%%
%% $Header
%%  Delay measurements Error
%%
%% $Description
%%  Delay Measurements Error
%%
%% $Requirements
%%  CBD_RICM_DCI_DELAY-VALUE_FU:1:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  CPRI converter. (set to 41 km)
%%
%%  The DU BC is in state starting.
%%
%%  Radio control for ruId 1, port 4 is added
%%
%% $Action
%%  Send a DC_SUBSCRIBE_FAULTS_REQ.
%%
%% $Result
%%  DC_SUBSCRIBE_FAULTS_CFM is received
%%
%% $Action
%%  Start simulating length with shellcommand "set_cable_length_emulator -m 410000 2" on CPRI converter
%%
%% $Result
%%  DC_FAULT_IND is received with parameters:
%%
%%  faultId = LINK_FAILURE
%%
%%  faultDescription = "Delay measurements error, port 4"
%%
%% $Result
%%  START_CPRI_LINK_IND with parameters:
%%
%%  ruId = 1
%%
%%  typeOfUnit = 0
%%
%%  availStatus = 0
%%
%% $Action
%%  Start simulating length with shellcommand "set_cable_length_emulator -m 400000 2" on CPRI converter
%%
%% $Result
%%  DC_FAULT_CEASE_IND is received with parameters:
%%
%%  faultId = LINK_FAILURE
%%
%% $Result
%%  START_CPRI_LINK_IND with parameters:
%%
%%  ruId = 1
%%
%%  typeOfUnit = 0
%%
%%  availStatus = 1
%%
%% $Postcondition
%%  -
%%
%% $End
%%------------------------------------------------------------------------------

%%##############################################################################
%% $ChapterH2 Reset Radio Control link
%%
%%
%% $End
%%##############################################################################

%%------------------------------------------------------------------------------
%% $Id DCI_RESET_RC1
%%
%% $Header
%%  Reset Radio Control, main state starting
%%
%% $Description
%%  Reset Radio Control, main state starting
%%
%% $Requirements
%%  CBD_RICM_DCI-RESET-RADIO-CONTROL-LINK_FU:1:H
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  At least one radio
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state starting.
%%
%%  CPRI Link is up
%%
%%  Radio control is up
%%
%% $Action
%%  Send a RICM_RESET_RADIO_CTL_REQ
%%
%% $Result
%%  RICM_RESET_RADIO_CTL_CFM is received.
%%
%%  Check that controlling is down.
%%
%%  Check that delay measurement is stopped.
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  2012-11-30, EJONUNA
%%
%% Revision history:
%%  2012-10-23, EEDAJA
%%    First version
%%  2012-11-30, EEDAJA
%%    Minor changes after review
%%  2012-12-18, EJONUNA
%%    Merged test case DCI_RESET_RC_CHECK_REBOOT_OF_RU to dci_reset_rc1 after review
%%  2014-02-18, EMASNOK
%%    Removed check for IBOOT_CPLD_UART_RESET in radio T&E.
%%  2014-03-10, EMASNOK
%%    Added checks for new fault signal: "Temporary not in operation"
%%
%%------------------------------------------------------------------------------
dci_reset_rc1() ->
	[{userdata,[{wp, ""},
				{requirement, "CBD_RICM_DCI-RESET-RADIO-CONTROL-LINK_FU:1:H"},
				{slogan, "Reset Radio Control, main state starting"},
				{hwConfig, hwConfigA}]}].

dci_reset_rc1(_Config) ->
	dci_reset_rc("dci_reset_rc1", starting_lmc_loaded).

dci_reset_rc( Name, State) ->
	ct:pal( Name ),

	Radio1 = nci_ricm_utils:get_first_radio(),
	RuLnhPath = proplists:get_value(ruLnhPath,Radio1),

	dci_reset_rc_rej_pre(Radio1,State), 

	%% Reset Radio Control
	nci_dci_actions:reset_radio_control(Radio1),

	ok = nci_dci_actions:cpri_link_ind(Radio1 ++[{availStatus, 0}]),

	FaultId1 = nci_dci_actions:fault_ind([{oseGwDeamon,?OSE_GW_DEAMON_1},
										  {faultId, ?ELIB_CONST_FH_FAULT_ID_LF_STABILITY},
										  {faultDescription, {regexp, "Temporary not in operation*"}}]),

	ok = nci_dci_actions:fault_cease_ind([{faultId, FaultId1}]),

	FaultId2 = nci_dci_actions:fault_ind([{oseGwDeamon,?OSE_GW_DEAMON_1},
										  {faultId, ?ELIB_CONST_FH_FAULT_ID_LINK_FAILURE},
										  {faultDescription, {regexp, "Not in operation*"}}]),
	
	ok = nci_dci_actions:cpri_link_ind(Radio1 ++ [{availStatus, 1}]),
	ok = nci_dci_actions:fault_cease_ind([{faultId, FaultId2}]),

	nci_common_utils:coli_cmd("lhsh " ++ RuLnhPath ++ " lmclist", "failed to connect to"),

	%% Get Delay
	nci_dci_actions:get_delay(Radio1 ++ [{expectedSigNo, ?RICM_GET_DELAY_REJ}]),
	%% Add Radio Control
	nci_dci_actions:add_radio_control(Radio1),

	nci_dci_actions:radio_control_ind(Radio1 ++ [{connStatus, 1},
										{radioSoftware, application}]),

	nci_common_utils:coli_cmd("lhsh " ++ RuLnhPath ++ " lmclist", "SlotProt State"),

	%% Get Delay
	nci_dci_actions:get_delay(Radio1),

	dci_reset_rc_rej_post(Radio1).

%%------------------------------------------------------------------------------
%% $Id DCI_RESET_RC2
%%
%% $Header
%%  Reset Radio Control, main state operational
%%
%% $Description
%%  Reset Radio Control, main state operational
%%
%% $Requirements
%%  CBD_RICM_DCI-RESET-RADIO-CONTROL-LINK_FU:1:H
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  At least one radio on any port
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state operational
%%
%%  CPRI Link is up
%%
%%  Radio control is up.
%%
%% $Action
%%  Send a RICM_RESET_RADIO_CTL_REQ
%%
%% $Result
%%  RICM_RESET_RADIO_CTL_CFM is received.
%%
%%  Check that controlling is down.
%%
%%  Check that delay measurement is stoped.
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  2012-11-30, EJONUNA
%%
%% Revision history:
%%  2012-10-23, EEDAJA
%%    First version
%%
%%  2012-11-30, EEDAJA
%%    Minor changes after review
%%
%%  2012-12-18, EJONUNA
%%    Merged test case DCI_RESET_RC_CHECK_REBOOT_OF_RU to dci_reset_rc2 after review
%%
%%  2014-02-18, EMASNOK
%%    Removed check for IBOOT_CPLD_UART_RESET in radio T&E.
%%
%%------------------------------------------------------------------------------
dci_reset_rc2() ->
	[{userdata,[{wp, ""},
				{requirement, "CBD_RICM_DCI-RESET-RADIO-CONTROL-LINK_FU:1:H"},
				{slogan, "Reset Radio Control, main state operational"},
				{hwConfig, hwConfigA}]}].

dci_reset_rc2(_Config) ->
	dci_reset_rc("dci_reset_rc2", operational).

%%------------------------------------------------------------------------------
%% $Id DCI_RESET_RC3
%%
%% $Header
%%  Reset Radio Control, main state disabled
%%
%% $Description
%%  Reset Radio Control, main state disabled
%%
%% $Requirements
%%  CBD_RICM_DCI-RESET-RADIO-CONTROL-LINK_FU:1:H
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  At least one radio on any port
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  CPRI Link is up
%%
%%  Radio control is added.
%%
%%  Set DU BC is in state disabled.
%%
%% $Action
%%  Send a RICM_RESET_RADIO_CTL_REQ
%%
%% $Result
%%  RICM_RESET_RADIO_CTL_REJ is received with parameters
%%
%%  errorDescription = "Invalid O&M state"
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  2012-12-17, EJONUNA
%%
%% Revision history:
%%  2012-10-23, EEDAJA
%%    First version
%%
%%  2012-12-18, EJONUNA
%%    Minor changes after review of test case DCI_RESET_RC_CHECK_REBOOT_OF_RU
%%
%%  2013-05-20, EYANWZH
%%   fix the defects.
%%
%%  2013-07-02, EBACEMI
%%    Removed code that expects RICM_ADD_RADIO_CTL_IND after entering disabled state
%%------------------------------------------------------------------------------
dci_reset_rc3() ->
	[{userdata,[{wp, ""},
				{requirement, "CBD_RICM_DCI-RESET-RADIO-CONTROL-LINK_FU:1:H"},
				{slogan, "Reset Radio Control, main state disabled"},
				{hwConfig, hwConfigA}]}].

dci_reset_rc3(_Config) ->
	ct:pal( "dci_reset_rc3" ),

	Radio = nci_ricm_utils:get_first_radio(),
	RuLnhPath = proplists:get_value(ruLnhPath,Radio),

	dci_reset_rc_rej_pre(Radio,starting_lmc_loaded),

	nci_bci_states:set_state([{state, disabled}]),

	%% Reset Radio Control
	nci_dci_actions:reset_radio_control(Radio ++ [
										{expectedSigNo, ?RICM_RESET_RADIO_CTL_REJ},
										{errorCode, 1},
										{errorDescription, {regexp, "Invalid O&M state*"}}]),

	{ok, Result} = coli:cmd(?SHELL_COMMAND, "lhsh " ++ RuLnhPath ++ " lmclist"),

	case re:run(Result,"failed to connect|lost contact") of
		{match,[_]} -> ok;
		_ -> ct:fail("returned wrong result")
	end,

	%% Check that NO BC/DC_FAULT_IND is generated
	nci_common_utils:check_outstanding_faults(2000).


%%------------------------------------------------------------------------------
%% $Id DCI_RESET_RC4
%%
%% $Header
%%  Reset Radio Control, unused ruId
%%
%% $Description
%%  Reset Radio Control, unused ruId
%%
%% $Requirements
%%  CBD_RICM_DCI-RESET-RADIO-CONTROL-LINK_FU:1:H
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  At least one radio on any port
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state starting.
%%
%%  CPRI Link is up
%%
%%  Radio control is up.
%%
%% $Action
%%  Send a RICM_RESET_RADIO_CTL_REQ with ruId that is not in used.
%%
%% $Result
%%  RICM_RESET_RADIO_CTL_REJ is received with parameters
%%
%%  errorDescription = "ruId not in use"
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  2012-12-14 EEDAJA
%%
%% Revision history:
%%  2012-12-03, EJONUNA
%%    First version
%%
%%------------------------------------------------------------------------------
dci_reset_rc4() ->
	[{userdata,[{wp, ""},
				{requirement, "CBD_RICM_DCI-RESET-RADIO-CONTROL-LINK_FU:1:H"},
				{slogan, "Reset Radio Control, unused ruId"},
				{hwConfig, hwConfigA}]}].

dci_reset_rc4(_Config) ->
	ct:pal("dci_reset_rc4"),
	Radio1 = nci_ricm_utils:get_first_radio(),
	dci_reset_rc_rej_pre(Radio1,starting_lmc_loaded),
	
	ct:pal("Action"),
	%% Reset Radio Control for unused ruId 65535
	nci_dci_actions:reset_radio_control([{ruId, 65535},{expectedSigNo,?RICM_RESET_RADIO_CTL_REJ},{errorDescription,{regexp, "ruId not in use*"}}]),

	dci_reset_rc_rej_post(Radio1).


dci_reset_rc_rej_pre(Radio,State) ->
	% Set state, make audit, establish BCI and DCI connections, subscribe BCI faults
	set_state_and_connect( State ),

	%% Subscribe Faults DCI
	ok = nci_dci_actions:subscribe_faults([]),

	%% Start CPRI
	ok = nci_dci_actions:start_cpri_link(Radio),

	ok = nci_dci_actions:cpri_link_ind(Radio),
	
	%% Add Radio Control
	nci_dci_actions:add_radio_control(Radio),

 	nci_dci_actions:radio_control_ind(Radio ++
										[{connStatus, 1},
										{radioSoftware,application}]),

	BXP = proplists:get_value(ruLnhPath,Radio),
	
	nci_common_utils:coli_cmd("lhsh " ++ BXP ++ " te log clear"),
	
	nci_common_utils:coli_cmd("lhsh " ++ BXP ++ " lmclist", "SlotProt State").
	
dci_reset_rc_rej_post(Radio) ->
	ok = nci_dci_actions:reset_cpri_link(Radio),

	ok = nci_dci_actions:reset_cpri_link_ind(Radio),

	%% Check that NO BC/DC_FAULT_IND is generated
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id DCI_RESET_RC6
%%
%% $Header
%%  Reset Radio Control, Invalid ruId
%%
%% $Description
%%  Reset Radio Control, Invalid ruId. Supported range is 1-65535.
%%
%% $Requirements
%%  CBD_RICM_DCI-RESET-RADIO-CONTROL-LINK_FU:1:H
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  At least one radio on any port
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state starting.
%%
%%  CPRI Link is up
%%
%%  Radio control is up.
%%
%% $Action_1
%%  Send a RICM_RESET_RADIO_CTL_REQ with ruId = 0.
%%
%% $Result_1
%%  RICM_RESET_RADIO_CTL_REJ is received with parameters
%%
%%  errorDescription = "Invalid ruId"
%%
%% $Action_2
%%  Send a RICM_RESET_RADIO_CTL_REQ with
%%
%%  ruId = 65535 (max supported value).
%%
%% $Result_2
%%  RICM_RESET_RADIO_CTL_CFM is received
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  2012-12-14 EEDAJA  
%%
%% Revision history:
%%  2012-12-04, EJONUNA
%%    First version
%%  2014-03-10, emasnok
%%    Added checks for new fault signal: "Temporary not in operation"
%%
%%------------------------------------------------------------------------------

dci_reset_rc6() ->
	[{userdata,[{wp, ""},
				{requirement, "CBD_RICM_DCI-RESET-RADIO-CONTROL-LINK_FU:1:H"},
				{slogan, "Reset Radio Control, Invalid ruId"},
				{hwConfig, hwConfigA}]}].

dci_reset_rc6(_Config) ->
	ct:pal("dci_reset_rc6"),
	Radio1 = nci_ricm_utils:get_first_radio(),
	RadioMaxRuId = proplists:delete(ruId,Radio1) ++ [{ruId,65535}],
	
	dci_reset_rc_rej_pre(RadioMaxRuId,starting_lmc_loaded),
	
	ct:pal("Action_1"),
	%% Reset Radio Control for invalid ruId 0
	nci_dci_actions:reset_radio_control([{ruId, 0},
										 {expectedSigNo,?RICM_RESET_RADIO_CTL_REJ},
										 {errorDescription,{regexp, "Invalid ruId*"}}]),

	ct:pal("Action_2"),
	%% Reset Radio Control for maximum value of ruId
	nci_dci_actions:reset_radio_control(RadioMaxRuId),
	
	ok = nci_dci_actions:cpri_link_ind(RadioMaxRuId ++[{availStatus, 0}]),
	
	FaultId1 = nci_dci_actions:fault_ind([{faultId, ?ELIB_CONST_FH_FAULT_ID_LF_STABILITY},
										  {faultDescription, {regexp, "Temporary not in operation*"}}]),
	
	ok = nci_dci_actions:fault_cease_ind([{faultId, FaultId1}]),

	FaultId2 = nci_dci_actions:fault_ind([{faultId, ?ELIB_CONST_FH_FAULT_ID_LINK_FAILURE},
										  {faultDescription, {regexp, "Not in operation*"}}]),

	ok = nci_dci_actions:cpri_link_ind(RadioMaxRuId ++ [{availStatus, 1}]),
	ok = nci_dci_actions:fault_cease_ind([{faultId,FaultId2}]),
	dci_reset_rc_rej_post(RadioMaxRuId).


%%------------------------------------------------------------------------------
%% $Id DCI_RESET_RC7
%%
%% $Header
%%  Reset Radio Control, Link already disconnected
%%
%% $Description
%%  Reset Radio Control, Link already disconnected.
%%
%% $Requirements
%%  CBD_RICM_DCI-RESET-RADIO-CONTROL-LINK_FU:1:H
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  At least one radio on any port
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state starting.
%%
%%  CPRI Link is up
%%
%%  Radio control is up.
%%
%% $Action_1
%%  Release radio control link.
%%
%% $Result_1
%%  Controllink is released
%%
%% $Action_2
%%  Send a RICM_RESET_RADIO_CTL_REQ.
%%
%% $Result_2
%%  RICM_RESET_RADIO_CTL_REJ is received with parameters errorDescription = "Link already disconnected"
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  2012-12-14 EEDAJA
%%
%% Revision history:
%%  2012-12-04, EJONUNA
%%    First version
%%
%%------------------------------------------------------------------------------
dci_reset_rc7() ->
	[{userdata,[{wp, ""},
				{requirement, "CBD_RICM_DCI-RESET-RADIO-CONTROL-LINK_FU:1:H"},
				{slogan, "Reset Radio Control, Link already disconnected"},
				{hwConfig, hwConfigA}]}].

dci_reset_rc7(_Config) ->
	ct:pal("dci_reset_rc7"),
	Radio = nci_ricm_utils:get_first_radio(),
	
	dci_reset_rc_rej_pre(Radio,starting_lmc_loaded),
	
	ct:pal("Action_1"),
	ok = nci_dci_actions:release_radio_control(Radio),
	ok = nci_dci_actions:release_radio_control_ind(Radio),
	
	ct:pal("Action_2"),
	nci_dci_actions:reset_radio_control(Radio ++ [{expectedSigNo,?RICM_RESET_RADIO_CTL_REJ},{errorDescription,{regexp, "Link already disconnected*"}}]),
	
	dci_reset_rc_rej_post(Radio).


%%------------------------------------------------------------------------------
%% $Id DCI_RESET_RC8
%%
%% $Header
%%  Reset Radio Control, DP not loaded
%%
%% $Description
%%  Reset Radio Control, DP not loaded
%%
%% $Requirements
%%  CBD_RICM_DCI-RESET-RADIO-CONTROL-LINK_FU:1:H
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  At least one radio on any port
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state starting.
%%
%%  Ensure LMC not loaded.
%%
%% $Action
%%  Send a RICM_RESET_RADIO_CTL_REQ.
%%
%% $Result
%%  RICM_RESET_RADIO_CTL_REJ is received with parameters errorDescription = "DP not loaded"
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  20xx-xx-xx, EYANWZH (Exxxxxx)
%%    First version
%%
%%------------------------------------------------------------------------------
dci_reset_rc8() ->
	[{userdata,[{wp, ""},
				{requirement, "CBD_RICM_DCI-RESET-RADIO-CONTROL-LINK_FU:1:H"},
				{slogan, "Reset Radio Control, DP not loaded"},
				{hwConfig, hwConfigA}]}].
		
dci_reset_rc8(_Config) ->
	ct:pal("dci_reset_rc8"),

	% Set state, make audit, establish BCI and DCI connections, subscribe faults
	set_state_and_connect( starting_lmc_not_loaded ),

	%% Subscribe Faults DCI
	ok = nci_dci_actions:subscribe_faults([]),
	
	Radio = nci_ricm_utils:get_first_radio(),
	
	ct:pal("Action_1"),
	nci_dci_actions:reset_radio_control(Radio ++ [{expectedSigNo,?RICM_RESET_RADIO_CTL_REJ},{errorDescription,{regexp, "DP not loaded"}}]),
	
	%% Check that NO BC/DC_FAULT_IND is generated
	nci_common_utils:check_outstanding_faults(2000).


%%##############################################################################
%% $ChapterH2 WP547
%% 
%% New parameter in ricmCarrierSetupReq - isSubBand = Yes, Subband used. (current radio) - isSubBand = NO, Fullband used. (Ottawa radio, and some BW for current radio (1.4 and 3 MHz)). Note! with CR166 implemented it is also possible to set Subband for, 1.4 and 3 MHz bandwith. 15MHz DL is not supported on Ottawa radio. If fullband is set then no reordering is used in DL. If subband is set then reordering is used in DL
%%
%% $End
%%##############################################################################

%%------------------------------------------------------------------------------
%% $Id DCI_CS_TEST_BW_AND_ISSUBBAND
%%
%% $Header
%%  Carrier setup
%%
%% $Description
%%  WP547 setup carriers with supported BW and supported isSubBand param.
%%
%% $Requirements
%%  CBD_RICM_DCI-IQ_FU:1:C
%%
%%  CBD_RICM_DCI-IQ_FU:2:C
%%
%% $External References
%%  -
%%
%% $HW Config
%%  At least one radio on any port
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state starting.
%%
%%  CPRI Link and O&M is setup for all the radios
%%
%%  No carriers setup
%%
%% $Action_1
%%  Send a CARRIER_SETUP_REQ with parameters:
%%
%%  ruId = 1, carrierId = 0, direction = UL, noOfSamples = 1, isSubBand = NO
%%
%% $Result_1
%%  A CARRIER_SETUP_CFM is received with parameters:
%%
%%  carrierId = 0
%%
%% $Action_2
%%  Send a CARRIER_SETUP_REQ with parameters:
%%
%%  ruId = 1, carrierId = 1, direction = DL, noOfSamples = 1, isSubBand = NO
%%
%% $Result_2
%%  A CARRIER_SETUP_CFM is received with parameters:
%%
%%  carrierId = 1
%%
% $Action_3
%%  Send a CARRIER_RELEASE_REQ with parameters:
%%
%%  carrierId = 0
%%
%% $Result_3
%%  A CARRIER_RELEASE_CFM is received with parameters:
%%
%%  carrierId = 0
%%
%% $Action_4
%%  Send a CARRIER_RELEASE_REQ with parameters:
%%
%%  carrierId = 1
%%
%% $Result_4
%%  A CARRIER_RELEASE_CFM is received with parameters:
%%
%%  carrierId = 1
%%
%% $Action_5
%%  Repeat Action_1 - Action_4 but with isSubBand = YES
%%
%% $Result_5
%%  Same as in Result_1 - Result_4
%%
%% $Action_6
%%  Repeat Action_1 - Action_5 but with noOfSamples = 2,4,6,8
%%
%% $Result_6
%%  Same as in Result_1 - Result_5
%%
%% $Action_7
%%  Repeat Action_1 - Action_6 for the rest radios
%%
%% $Result_7
%%  Same as in Result_1 - Result_6
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2013-07-30, EYANWZH
%%    First version
%%
%%------------------------------------------------------------------------------
dci_cs_test_bw_and_issubband() ->
	[{userdata,[{wp, ""},
				{requirement, "CBD_RICM_DCI-IQ_FU:1:C,CBD_RICM_DCI-IQ_FU:2:C"},
				{slogan, "Carrier setup"},
				{hwConfig, hwConfigA}]}].

dci_cs_test_bw_and_issubband(_Config) ->
	ct:pal("dci_cs_test_bw_and_issubband"),

	% Set state, make audit, establish BCI and DCI connections, subscribe faults
	set_state_and_connect(starting_lmc_loaded),

	%% Subscribe Faults DCI
	ok = nci_dci_actions:subscribe_faults([]),

	XioPortDL = case nci_common_utils:get_du() of
		dul -> 1;
		dus -> 5;
		mRBS_lte -> 5;
		_ -> 1
	end,

	Radios = nci_ricm_utils:get_all_radios(),

	lists:foreach(fun(Radio) ->

		%% Start CPRI
		ok = nci_dci_actions:start_cpri_link(Radio),
		ok = nci_dci_actions:cpri_link_ind(Radio),

		%% Add Radio Control
		nci_dci_actions:add_radio_control(Radio ++ [{expectedSigNo, ?RICM_ADD_RADIO_CTL_CFM}]),
		nci_dci_actions:radio_control_ind(Radio ++ [{connStatus, 1},{radioSoftware,application}])

	end,
	Radios),

	lists:foreach(fun(Radio) ->
		RuId = proplists:get_value(ruId,Radio),

		lists:foreach(fun(NoOfSamples) ->
			%%Fullband
			%% Add Carriers UL
			ok = nci_dci_actions:carrier_setup3([{ruId, RuId},
												{xioPort, 0},
												{direction, ?RICM_CARRIER_DIRECTION_UL},
												{carrierId, 0},
												{posA, 0},
												{noOfSamples, NoOfSamples},
												{isSubBand, ?ELIB_CONST_HWU_NO}]),
			%% Add Carriers DL
			ok = nci_dci_actions:carrier_setup3([{ruId, RuId},
												{xioPort, XioPortDL},
												{direction, ?RICM_CARRIER_DIRECTION_DL},
												{carrierId, 1},
												{posA, 0},
												{noOfSamples, NoOfSamples},
												{isSubBand, ?ELIB_CONST_HWU_NO}]),

			ok = nci_dci_actions:carrier_release(Radio ++ [{carrierId, 0}]),
			ok = nci_dci_actions:carrier_release(Radio ++ [{carrierId, 1}]),

			%%Subband
			%% Add Carriers UL
			ok = nci_dci_actions:carrier_setup3([{ruId, RuId},
												{xioPort, 0},
												{direction, ?RICM_CARRIER_DIRECTION_UL},
												{carrierId, 0},
												{posA, 0},
												{noOfSamples, NoOfSamples},
												{isSubBand, ?ELIB_CONST_HWU_YES}]),
			%% Add Carriers DL
			ok = nci_dci_actions:carrier_setup3([{ruId, RuId},
												{xioPort, XioPortDL},
												{direction, ?RICM_CARRIER_DIRECTION_DL},
												{carrierId, 1},
												{posA, 0},
												{noOfSamples, NoOfSamples},
												{isSubBand, ?ELIB_CONST_HWU_YES}]),

			ok = nci_dci_actions:carrier_release(Radio ++ [{carrierId, 0}]),
			ok = nci_dci_actions:carrier_release(Radio ++ [{carrierId, 1}])
		end,
		[1,2,4,6,8])
	end,
	Radios),

	reset_all_cpri_links(Radios),

	%% Check that NO BC/DC_FAULT_IND is generated
	nci_common_utils:check_outstanding_faults(2000).
%%------------------------------------------------------------------------------
%% $Id DCI_CS_FAULTCASE_WITH_ISSUBBAND_PARAM
%%
%% $Header
%%  Fault case in isSubBand
%%
%% $Description
%%  Faultcases using parameter in isSubBand
%%
%% $Requirements
%%  CBD_RICM_DCI-IQ_FU:1:C
%%
%%  CBD_RICM_DCI-IQ_FU:2:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  At least one radio on any port
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state starting.
%%
%%  CPRI Link and O&M is setup for all the radios
%%
%%  No carriers setup
%%
%% $Action_1
%%  Send a CARRIER_SETUP_REQ with parameters:
%%
%%  ruId = 1, carrierId = 0, direction = UL, xioPort = 0 , noOfSamples = 2, isSubBand = 2
%%
%% $Result_1
%%  A CARRIER_SETUP_REJ is received with parameters:
%%
%%  carrierId = 0
%%
%%  errorCode = UNSUCCESSFUL
%%
%%  carrierErrorCode = CARRIER_NO_ERROR
%%
%%  errorDescription = "Invalid subBand"
%%
%%  carrierId = 1
%%
%% $Action_2
%%  Send a CARRIER_SETUP_REQ with parameters:
%%
%%  ruId = 1, carrierId = 1, direction = DL, xioPort = 1(5 for dus41 and mrbs) , noOfSamples = 2, isSubBand = 2
%%
%%  carrierId = 1
%%
%% $Result_2
%%  A CARRIER_SETUP_REJ is received with parameters:
%%
%%  carrierId = 1
%%
%%  errorCode = UNSUCCESSFUL
%%
%%  carrierErrorCode = CARRIER_NO_ERROR
%%
%%  errorDescription = "Invalid subBand"
%%
%%  carrierId = 1
%%
%% $Action_3
%%  Repeat Action_1 and Action_2 for all the configured radios
%%
%% $Result_3
%%  Same as in Result_1 - Result_2
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2013-08-01, Eyanwzh
%%    First version
%%
%%------------------------------------------------------------------------------
dci_cs_faultcase_with_issubband_param() ->
	[{userdata,[{wp, ""},
				{requirement, "CBD_RICM_DCI-IQ_FU:1:C,CBD_RICM_DCI-IQ_FU:2:C"},
				{slogan, "Fault case in isSubBand"},
				{hwConfig, hwConfigA}]}].

dci_cs_faultcase_with_issubband_param(_Config) ->
	ct:pal("dci_cs_faultcase_with_issubband_param"),

	% Set state, make audit, establish BCI and DCI connections, subscribe faults
	set_state_and_connect(starting_lmc_loaded),

	%% Subscribe Faults DCI
	ok = nci_dci_actions:subscribe_faults([]),

	XioPortDL = case nci_common_utils:get_du() of
		dul -> 1;
		dus -> 5;
		mRBS_lte -> 5;
		_ -> 1
	end,

	Radios = nci_ricm_utils:get_all_radios(),

	lists:foreach(fun(Radio) ->

		%% Start CPRI
		ok = nci_dci_actions:start_cpri_link(Radio),
		ok = nci_dci_actions:cpri_link_ind(Radio),

		%% Add Radio Control
		nci_dci_actions:add_radio_control(Radio ++ [{expectedSigNo, ?RICM_ADD_RADIO_CTL_CFM}]),
		nci_dci_actions:radio_control_ind(Radio ++ [{connStatus, 1},{radioSoftware,application}])

	end,
	Radios),

	NoOfSamples = 2,
	lists:foreach(fun(Radio) ->

		RuId = proplists:get_value(ruId,Radio),

		%% Add Carriers UL
		ok = nci_dci_actions:carrier_setup3([{ruId, RuId},
											{xioPort, 0},
											{direction, ?RICM_CARRIER_DIRECTION_UL},
											{carrierId, 2*RuId - 2},
											{posA, (2*RuId-2) rem 30},
											{noOfSamples, NoOfSamples},
											{isSubBand, 2},
											{expectedSigNo, ?RICM_CARRIER_SETUP_REJ},
											{errorCode, 1},
											{errorDescription, {regexp, "Invalid subBand"}}]),
		%% Add Carriers DL
		ok = nci_dci_actions:carrier_setup3([{ruId, RuId},
											{xioPort, XioPortDL},
											{direction, ?RICM_CARRIER_DIRECTION_DL},
											{carrierId, 2*RuId - 1},
											{posA, (2*RuId-2) rem 30},
											{noOfSamples, NoOfSamples},
											{isSubBand, 2},
											{expectedSigNo, ?RICM_CARRIER_SETUP_REJ},
											{errorCode, 1},
											{errorDescription, {regexp, "Invalid subBand"}}])

	end,
	Radios),

	reset_all_cpri_links(Radios),

	%% Check that NO BC/DC_FAULT_IND is generated
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id DCI_CSMAX_RCL_CSMAX_FULLBAND
%%
%% $Header
%%  Max Allocation
%%
%% $Description
%%  wp547 fullband, Carrier Setup, Max Allocation - reset CPRI link - start CPRI link again and set up Max Allocation again.
%%
%% $Requirements
%%  CBD_RICM_DCI-RESET-CPRI-LINK_FU:1:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  CPRI links is started according to configuration
%%
%%  No carrier setup
%%
%% $Action_1
%%  Setup max carriers according to configuration with fullband
%%
%%  See Appendix for max carrier setup
%%
%% $Result_1
%%  Carriers setup successfully
%%  Check that the following registers are setup
%%  For DUL-20
%%  * Common Configuration register in XIO_I block (addr: 0x3f2)
%%  * Egress link configuration registers for UL (addr: 0x4c0-0x4c8) and DL (addr: 0x440-0x454) in IQ_X block
%%  * Ingress link configuration registers for UL (addr: 0x480-0x494) and DL (addr: 0x400-0x408) in IQ_X block
%%  * Configuration word in control memory for UL (addr: 0x600-0x5e) and DL (addr: 0x540-0x5fe) in IQ_X block
%%  For DUS-41 (DUXI)
%%  * Egress link configuration registers for UL (addr: 0x68c0-0x6910) and DL (addr: 0x6800-0x68af) in IQ_X block
%%  * Ingress link configuration registers for UL (addr: 0x6050-0x610f) and DL (addr: 0x6000-0x606f) in IQ_X block
%%  * Configuration word in control memory for UL (addr: 0x7600-0x7880) and DL (addr: 0x7000-0x75ff) in IQ_X block
%%
%% $Action_2
%%  Send a RESET_CPRI_LINK_REQ with parameters according to configuration
%%
%% $Result_2
%%  A RESET_CPRI_LINK_CFM is received with parameters according to configuration
%%  A RESET_CPRI_LINK_IND is received with parameters according to configuration
%%
%% $Action_3
%%  Send a START_CPRI_LINK_REQ with parameters according to configuration
%%
%% $Result_3
%%  A START_CPRI_LINK_CFM is received
%%  A START_CPRI_LINK_IND is received with parameters:
%%  availStatus = 1
%%
%% $Action_4
%%  Repeat Action_1
%%
%% $Result_4
%%  Same as in Result_1
%%
%% $Action_5
%%  Release all carriers
%%
%% $Result_5
%%  Carriers released successfully
%%
%% $Action_6
%%  Release cpri links
%%
%% $Result_6
%%  Cpri links released successfully
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2013-08-27, EYANWZH
%%    First version
%%
%%------------------------------------------------------------------------------
dci_csmax_rcl_csmax_fullband() ->
	[{userdata,[{wp, ""},
				{requirement, "CBD_RICM_DCI-RESET-CPRI-LINK_FU:1:C"},
				{slogan, "wp547 fullband, Carrier Setup, Max Allocation - reset CPRI link - start CPRI link again and set up Max Allocation again."},
				{hwConfig, hwConfigA}]}].

dci_csmax_rcl_csmax_fullband(_Config) ->
	dci_csmax_rcl_csmax("dci_csmax_rcl_csmax_fullband",[{bandtype,fullband}]).

%%------------------------------------------------------------------------------
%% $Id WP547_ONE_OTTAWA_AND_ONE_CURRENT_RADIO
%%
%% $Header
%%  Ottawa Radio and Current Radio
%%
%% $Description
%%  WP547, Carrier Setup, one port use isSubBand = NO (Ottawa radio) and a second port use isSubBand = YES (Current radio). Add Radio Controls to both RUs , main state
%%
%% $Requirements
%%  ?
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  ?
%%
%% $Action
%%  ?
%%
%% $Result
%%  ?
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%    First version
%%
%%------------------------------------------------------------------------------



%%##############################################################################
%% $ChapterH2 Misc
%%
%%
%% $End
%%##############################################################################

%%------------------------------------------------------------------------------
%% $Id RICM_SFP_HWLOG
%%
%% $Header
%%  Write SFP info on startup
%%
%% $Description
%%  Verify that SFP info is logged at startup.
%%
%% $Requirements
%%  CBD_RICM_SFP-SUPERV_FU:1:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  At least one SFP present
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  Node is cold restarted.
%%  The HW log is cleared.
%%  BCI state is started.
%%  DP LMC is loaded.
%%
%% $Action_1
%%  Read HW Log with shellcommand "dumpelg"
%%
%% $Result_1
%%  An info entry for each SFP that is connected can be found
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  2012-11-26, EEDAJA
%%
%% Revision history:
%%  2012-11-15, EYANWZH
%%    First version
%%
%%  2012-11-26, EEDAJA
%%    Changed to use nci_ricm_utils:get_first_radio()
%%
%%  2012-12-18, EEDAJA
%%    Increased timeout of coli after "reload" from 60sec to 120sec
%%
%%  2013-09-09, ejonuna
%%    Create a library function for sfp detection and removed pointless restarts of du in test case
%%
%%  2013-10-17, EBACEMI
%%    Updated to support IDL2 links
%%    Made the TC identical to the WCDMA version
%%
%%  2013-11-21, ERAASLI
%%    Added a 3 second delay to solve HR90887: "Log entry in HW log not found";
%%    "Trouble Report Rejected by EBACEMI at DIGNCISW Fault was in the test case, not RICM code".
%%
%%------------------------------------------------------------------------------
ricm_sfp_hwlog() ->
	[{userdata,[{wp, ""},
				{requirement, "CBD_RICM_SFP-SUPERV_FU:1:C"},
				{slogan, "Write SFP info on startup"},
				{hwConfig, hwConfigH}]}].

ricm_sfp_hwlog(_Config) ->
	ct:pal("ricm_sfp_hwlog"),
	
	{ok, session_up} = coli:subscribe_state(?SHELL_COMMAND),
	{ok, session_up} = osegw:subscribe_state(?OSE_GW_DEAMON_1),

	nci_common_utils:clear_dumpelg(?SHELL_COMMAND),

	nci_bci_states:cold_restart([]),
	nci_bci_states:set_state([{state, starting_lmc_loaded}]),

	%% Need 3s delay for RICM to write to the HWLOG.
	%% There is a 500ms time-out in RICM that needs to get
	%% "triggered" three times before RICM writes to the HWLOG.

	timer:sleep(3*1000),

	UsedPorts = nci_ricm_utils:get_all_used_ports(),

	ct:pal("Action_1"),
	lists:foreach(
		fun({portNo, PortNo}) ->
				ok = nci_ricm_utils:verify_sfp_in_hwlog(PortNo)
		end,
		UsedPorts),
	
	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id RICM_MEMORY_LEAK_TEST
%%
%% $Header
%%  Memory leak test.
%%
%% $Description
%%  Check for memory leaks
%%
%% $Requirements
%%  CBD_RICM_DCI-CONN-EST_FU:1:C
%%
%%  CBD_RICM_DCI_CAPABILITY_FU:1:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The Block ID for RICM is saved in varable $bid
%%
%% $Action_1
%%  Check signals owned by RICM with shellcommand "ps -wb"
%%
%% $Result_1
%%  Save owned signals in $sum
%%
%% $Action_2
%%  Send a BC_CONN_ESTABLISH_REQ, with parameters:
%%
%%  rotocolRev = BC_REV
%%
%% $Result_2
%%  A BC_CONN_ESTABLISH_CFM is received.
%%
%% $Action_3
%%  Send a BC_ENABLE_OPERATION_REQ.
%%
%% $Result_3
%%  A BC_ENABLE_OPERATION_CFM is received.
%%
%% $Action_4
%%  Send a BC_AUDIT_REQ.
%%
%% $Result_4
%%  A BC_AUDIT_CFM is received with parameters:
%%
%%   mainState = BC_MAIN_STATE_OPERATIONAL
%%
%% $Action_5
%%  Send a BC_ETH_SETUP_HW_IF_REQ with parameters:
%%
%%  Valid numOfEthHwifMacAddresses
%%
%%  Valid ethHwifMacAddressParam
%%
%%  Valid addressFilterMask
%%
%% $Result_5
%%  A BC_ETH_SETUP_HW_IF_CFM is received.
%%
%% $Action_6
%%  Send a BC_GET_CAPABILITIES_REQ.
%%
%% $Result_6
%%  A BC_GET_CAPABILITIES_CFM is received.
%%
%%  With two boardCapabilityIdentity information fields:
%%
%%  BC_CAP_LOADING_SUPPORT
%%
%%  BC_CAP_ETH_HW_IF_SUPPORT
%%
%%  BC_CAP_CLIMATE_CONTROL_SUPPORT
%%
%% $Action_7
%%  Send a BC_SET_VISUAL_INDICATION_REQ with parameters:
%%
%%  visualizedState = BC_VISUAL_STATE_RESET
%%
%% $Result_7
%%  A BC_SET_VISUAL_INDICATION_CFM is received.
%%
%% $Action_8
%%  Check the vii state.
%%
%% $Result_8
%%  The vii state indicates:
%%
%%  no visual indication
%%
%% $Action_9
%%  Send a BC_SET_VISUAL_INDICATION_REQ with parameters:
%%
%%  visualizedState= BC_VISUAL_STATE_MISSING_RESOURCE
%%
%% $Result_9
%%  A BC_SET_VISUAL_INDICATION_CFM is received.
%%
%% $Action_10
%%  Check the vii state.
%%
%% $Result_10
%%  The vii state indicates:
%%
%%  missing_resource = yes
%%
%% $Action_11
%%  Send a BC_SET_VISUAL_INDICATION_REQ with parameters:
%%
%%  visualizedState= BC_VISUAL_STATE_LOAD_TEST_IN_PROGRESS
%%
%% $Result_11
%%  A BC_SET_VISUAL_INDICATION_CFM is received.
%%
%% $Action_12
%%  Check the vii state.
%%
%% $Result_12
%%  The vii state indicates:
%%
%%  missing_resource = yes
%%
%%  load_start = yes
%%
%% $Action_13
%%  Send a BC_SET_VISUAL_INDICATION_REQ with parameters:
%%
%%  visualizedState= BC_VISUAL_STATE_MISSING_RESOURCE_END
%%
%% $Result_13
%%  A BC_SET_VISUAL_INDICATION_CFM is received.
%%
%% $Action_14
%%  Check the vii state.
%%
%% $Result_14
%%  The vii state indicates:
%%
%%  load_start = yes
%%
%% $Action_15
%%  Send a BC_SET_VISUAL_INDICATION_REQ with parameters:
%%
%%  visualizedState= BC_VISUAL_STATE_LOAD_TEST_IN_PROGRESS_END
%%
%% $Result_15
%%   A BC_SET_VISUAL_INDICATION_CFM is received.
%%
%% $Action_16
%%  Check the vii state.
%%
%% $Result_16
%%  The vii state indicates:
%%
%%  no visual indication
%%
%% $Action_17
%%  Send a BC_SET_VISUAL_INDICATION_REQ with parameters:
%%
%%  visualizedState = BC_VISUAL_STATE_BOARD_LOCKED
%%
%% $Result_17
%%  A BC_SET_VISUAL_INDICATION_CFM is received.
%%
%% $Action_18
%%  Check the vii state.
%%
%% $Result_18
%%  The vii state indicates:
%%
%%  board_locked = yes
%%
%% $Action_19
%%  Send a BC_SET_VISUAL_INDICATION_REQ with parameters:
%%
%%  visualizedState= BC_VISUAL_STATE_BOARD_UNLOCKED
%%
%% $Result_19
%%  A BC_SET_VISUAL_INDICATION_CFM is received.
%%
%% $Action_20
%%  Check the vii state.
%%
%% $Result_20
%%  The vii state indicates:
%%
%%  no visual indication
%%
%% $Action_21
%%  Send a BC_SET_VISUAL_INDICATION_REQ with parameters:
%%
%%  visualizedState = BC_VISUAL_STATE_FAULT
%%
%% $Result_21
%%  A BC_SET_VISUAL_INDICATION_CFM is received.
%%
%% $Action_22
%%  Check the vii state.
%%
%% $Result_22
%%  The vii state indicates:
%%
%%  fault = yes
%%
%% $Action_23
%%  Send a BC_SET_VISUAL_INDICATION_REQ with parameters:
%%
%%  visualizedState = BC_VISUAL_STATE_NO_FAULT
%%
%% $Result_23
%%  A BC_SET_VISUAL_INDICATION_CFM is received.
%%
%% $Action_24
%%  Check the vii state
%%
%% $Result_24
%%  The vii state indicates:
%%
%%  no visual indication
%%
%% $Action_25
%%  Send a BC_SET_VISUAL_INDICATION_REQ with parameters:
%%
%%  visualizedState = BC_VISUAL_STATE_SHUTDOWN
%%
%% $Result_25
%%  A BC_SET_VISUAL_INDICATION_CFM is received.
%%
%% $Action_26
%%  Check the vii state.
%%
%% $Result_26
%%  The vii state indicates:
%%
%%  shutdown = yes
%%
%% $Action_27
%%  Send a BC_SET_VISUAL_INDICATION_REQ with parameters:
%%
%%  visualizedState = BC_VISUAL_STATE_BOARD_BUSY
%%
%% $Result_27
%%  A BC_SET_VISUAL_INDICATION_CFM is received.
%%
%% $Action_28
%%  Check the vii state.
%%
%% $Result_28
%%  The vii state indicates:
%%
%%  board_busy = yes
%%
%%  shutdown = yes
%%
%% $Action_29
%%  Send a BC_SET_VISUAL_INDICATION_REQ with parameters:
%%
%%  visualizedState= BC_VISUAL_STATE_SHUTDOWN_END
%%
%% $Result_29
%%  A BC_SET_VISUAL_INDICATION_CFM is received.
%%
%% $Action_30
%%  Check the vii state.
%%
%% $Result_30
%%  The vii state indicates:
%%
%%  board_busy = yes
%%
%% $Action_31
%%  Send a BC_SET_VISUAL_INDICATION_REQ with parameters:
%%
%%  visualizedState = BC_VISUAL_STATE_RESET
%%
%% $Result_31
%%  A BC_SET_VISUAL_INDICATION_CFM is received.
%%
%% $Action_32
%%  Check the vii state.
%%
%% $Result_32
%%  The vii state indicates:
%%
%%  no visual indication
%%
%% $Action_33
%%  Send a BC_SET_VISUAL_INDICATION_REQ with parameters:
%%
%%  visualizedState = BC_VISUAL_STATE_NO_POWER
%%
%% $Result_33
%%  A BC_SET_VISUAL_INDICATION_CFM is received.
%%
%% $Action_34
%%  Check the vii state.
%%
%% $Result_34
%%  The vii state indicates:
%%
%%  no_power = yes
%%
%% $Action_35
%%  Send a BC_SET_VISUAL_INDICATION_REQ with parameters:
%%
%%  visualizedState= BC_VISUAL_STATE_POWER_PRESENT
%%
%% $Result_35
%%  A BC_SET_VISUAL_INDICATION_CFM is received.
%%
%% $Action_36
%%  Check the vii state.
%%
%% $Result_36
%%  The vii state indicates:
%%
%%  no visual indication
%%
%% $Action_37
%%  Send a BC_SET_VISUAL_INDICATION_REQ with parameters:
%%
%%  visualizedState= BC_VISUAL_STATE_BOOT_TEST_IN_PROGRESS
%%
%% $Result_37
%%  A BC_SET_VISUAL_INDICATION_CFM is received.
%%
%% $Action_38
%%  Check the vii state.
%%
%% $Result_38
%%  The vii state indicates:
%%
%%  boottest = yes
%%
%% $Action_39
%%  Send a BC_SET_VISUAL_INDICATION_REQ with parameters:
%%
%%  visualizedState= BC_VISUAL_STATE_BOOT_TEST_IN_PROGRESS_END
%%
%% $Result_39
%%  A BC_SET_VISUAL_INDICATION_CFM is received.
%%
%% $Action_40
%%  Check the vii state.
%%
%% $Result_40
%%  The vii state indicates:
%%
%%  no visual indication
%%
%% $Action_41
%%  Send a BC_TEMP_MEAS_START_REQ
%%
%% $Result_41
%%  A BC_TEMP_MEAS_START_CFM is received.
%%
%%  Check that BC_TEMP_MEAS_IND sends every second.
%%
%% $Action_42
%%  Send a DC_CONN_ESTABLISH_REQ, with parameters:
%%
%%  protocolRevBasic = DC_BASIC_REV
%%
%%  protocolRevSpecific = RICM_DCI_SPECIFIC_REV
%%
%% $Result_42
%%  A DC_CONN_ESTABLISH_CFM is received.
%%
%% $Action_43
%%  Send a START_CPRI_LINK_REQ with parameters  according to configuration
%%
%% $Result_43
%%  A START_CPRI_LINK_CFM is received with parameters according to configuration
%%  A START_CPRI_LINK_IND is received with parameters according to configuration
%%    and
%%  availStatus = 1
%%
%% $Action_44
%%  Send a ADD_RADIO_CTL_REQ to a configured RU
%%
%% $Result_44
%%  A ADD_RADIO_CTL_CFM is received with parameters according to configuration
%%  A ADD_RADIO_CTL_IND is received with parameters according to configuration
%%
%% $Action_45
%%  Test the connection with shellcommand "lhsh <BXP_ru> lmclist"
%%    Example "lhsh BXP_3_1 lmclist"
%%
%% $Result_45
%%  The shellcommand is successful
%%
%% $Action_46
%%  Send a GET_CAPABILITIES_REQ.
%%
%% $Result_46
%%  A GET_CAPABILITIES_CFM is received.
%%
%%  It has two capabilities of type CARDINALITY and with the following parameter values:
%%
%%  cardinality.numberOfDevices = 6
%%
%%  delays.clkDelayTrpBB = 4
%%
%%  delays.procDelayDl = 622 (Step 2) or 512 (Step 3)
%%
%% $Action_47
%%  Send a GET_DELAY_REQ with parameters according to configuration
%%
%% $Result_47
%%  A GET_DELAY_CFM is received with parameters according to configuration
%%    and
%%  linkDelayDl = <a value>
%%
%% $Action_48
%%  Send a CARRIER_SETUP_REQ with parameters:
%%
%%  carrierId = 1, direction = UL, samples = 2, bbModule = 0
%%
%% $Result_48
%%  A CARRIER_SETUP_CFM is received with parameters:
%%
%%  carrierId = 1
%%
%% $Action_49
%%  Send a CARRIER_SETUP_REQ with parameters:
%%
%%  carrierId = 17, direction = DL, samples = 2, bbModule = 0
%%
%% $Result_49
%%  A CARRIER_SETUP_CFM is received with parameters:
%%
%%  carrierId = 17
%%
%% $Action_50
%%  Send a CARRIER_SETUP_REQ with parameters:
%%
%%  carrierId = 2, direction = UL, samples = 2, bbModule = 0
%%
%% $Result_50
%%  A CARRIER_SETUP_CFM is received with parameters:
%%
%%  carrierId = 2
%%
%% $Action_51
%%  Send a CARRIER_SETUP_REQ with parameters:
%%
%%  carrierId = 18, direction = DL, samples = 2, bbModule = 0
%%
%% $Result_51
%%  A CARRIER_SETUP_CFM is received with parameters:
%%
%%  carrierId = 18
%%
%% $Action_52
%%  Send a CARRIER_RELEASE_REQ with parameters:
%%
%%  carrierId = 1
%%
%% $Result_52
%%  A CARRIER_RELEASE_CFM is received with parameters:
%%
%%  carrierId = 1
%%
%% $Action_53
%%  Send a CARRIER_RELEASE_REQ with parameters:
%%
%%  carrierId = 2
%%
%% $Result_53
%%  A CARRIER_RELEASE_CFM is received with parameters:
%%
%%  carrierId = 2
%%
%% $Action_54
%%  Send a CARRIER_RELEASE_REQ with parameters:
%%
%%  carrierId = 18
%%
%% $Result_54
%%  A CARRIER_RELEASE_CFM is received with parameters:
%%
%%  carrierId = 18
%%
%% $Action_55
%%  Send a CARRIER_RELEASE_REQ with parameters:
%%
%%  carrierId = 19
%%
%% $Result_55
%%  A CARRIER_RELEASE_CFM is received with parameters:
%%
%%  carrierId = 19
%%
%% $Action_56
%%  Send a RELEASE_RADIO_CTL_REQ with parameters:
%%
%%  ruId = 1
%%
%% $Result_56
%%  A RELEASE_RADIO_CTL_CFM is received with parameters according to configuration
%%
%% $Result
%%  A RELEASE_RADIO_CTL_IND is received with parameters according to configuration
%%
%% $Action_57
%%  Check connection with shellcommand "lhsh <BXP_ru> lmclist" according to configuration
%%    Example "lhsh BXP_3_1 lmclist"
%%
%% $Result_57
%%  The output should be the line "failed to connect to BXP_3_1"
%%
%% $Action_58
%%  Check for signals
%%
%% $Result_58
%%  No START_CPRI_LINK_IND should be received
%%
%% $Action_59
%%  Send a RESET_CPRI_LINK_REQ with parameters according to configuration
%%
%% $Result_59
%%  A RESET_CPRI_LINK_CFM is received with parameters according to configuration
%%  A RESET_CPRI_LINK_IND is received with parameters according to configuration
%%
%% $Action_60
%%  Check signals owned by RICM with shellcommand "ps -wb"
%%
%% $Result_60
%%  Give a warning if signals owned by RICM > $sum and save new value of owned signals in $sum
%%
%% $Action
%%  Repeat Action_2 - Action_60 for a long time
%%
%% $Result
%%  After a few rounds no warnings should be printed in Result_60
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  
%%
%% Revision history:
%%  20xx-xx-xx, 
%%    First version
%%
%%------------------------------------------------------------------------------

%%------------------------------------------------------------------------------
%% $Id bci_sm1
%%
%% $Header
%%  
%%
%% $Description
%%  
%%
%% $Requirements
%%  
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  -
%%
%% $Action
%%  
%%
%% $Result
%%  
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-10-02, EEDAJA
%%    First version
%%
%%------------------------------------------------------------------------------

bci_sm1() ->
	[{userdata,[{wp, ""}, {requirement, ""},{slogan, ""}]}].

bci_sm1(_Config) ->
	bci_sm("bci_sm1", starting_lmc_loaded).

bci_sm(Name,State) ->
	ct:pal(Name),

	% Set state, make audit, establish BCI and DCI connections, subscribe BCI faults
	set_state_and_connect( State ),

	%% Subscribe Faults DCI
	ok = nci_dci_actions:subscribe_faults([]),

	%% Select default MMI
	case Name of
		"bci_sm4" ->
			nci_bci_actions:bci_select_mmi([{mmiState, ?ELIB_BC_MMI_3000},
											{expectedSigNo, ?ELIB_BC_SELECT_MMI_REJ},
											{errorDescription,{regexp, "Invalid MMI state*"}}]);
		"bci_sm5" ->
			nci_bci_actions:bci_select_mmi([{mmiState, 16#ffff},
											{expectedSigNo, ?ELIB_BC_SELECT_MMI_REJ},
											{errorDescription,{regexp, "Invalid MMI state*"}}]);
		_ ->
			nci_bci_actions:bci_select_mmi([])
	end,

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id bci_sm2
%%
%% $Header
%%  
%%
%% $Description
%%  
%%
%% $Requirements
%%  
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  -
%%
%% $Action
%%  
%%
%% $Result
%%  
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-10-02, EEDAJA
%%    First version
%%
%%------------------------------------------------------------------------------

bci_sm2() ->
	[{userdata,[{wp, ""}, {requirement, ""},{slogan, ""}]}].

bci_sm2(_Config) ->
	bci_sm("bci_sm2", operational).

%%------------------------------------------------------------------------------
%% $Id bci_sm3
%%
%% $Header
%%  
%%
%% $Description
%%  
%%
%% $Requirements
%%  
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  -
%%
%% $Action
%%  
%%
%% $Result
%%  
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-10-04, EEDAJA
%%    First version
%%
%%------------------------------------------------------------------------------

bci_sm3() ->
	[{userdata,[{wp, ""}, {requirement, ""},{slogan, ""}]}].

bci_sm3(_Config) ->
	bci_sm("bci_sm3", disabled).

%%------------------------------------------------------------------------------
%% $Id bci_sm4
%%
%% $Header
%%  
%%
%% $Description
%%  
%%
%% $Requirements
%%  
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  -
%%
%% $Action
%%  
%%
%% $Result
%%  
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-10-04, EEDAJA
%%    First version
%%
%%------------------------------------------------------------------------------

bci_sm4() ->
	[{userdata,[{wp, ""}, {requirement, ""},{slogan, ""}]}].

bci_sm4(_Config) ->
	bci_sm("bci_sm4", operational).

%%------------------------------------------------------------------------------
%% $Id bci_sm5
%%
%% $Header
%%  
%%
%% $Description
%%  
%%
%% $Requirements
%%  
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  -
%%
%% $Action
%%  
%%
%% $Result
%%  
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-10-04, EEDAJA
%%    First version
%%
%%------------------------------------------------------------------------------

bci_sm5() ->
	[{userdata,[{wp, ""}, {requirement, ""},{slogan, ""}]}].

bci_sm5(_Config) ->
	bci_sm("bci_sm5", operational).


%%------------------------------------------------------------------------------
%% $Id CASC_GET_PORT_1
%%
%% $Header
%%  State Starting
%%
%% $Description
%%  Get port number of radio unit in state starting
%%
%% $Requirements
%%  CBD_RICM-DCI-CURRENT-PORT_FU:1:L
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  Ensure state is in starting, and DP loaded
%%  CPRI links are setup for the whole cascaded chain
%%  Radio control has been added for the whole cascaded chain
%%
%% $Action_1
%%  Send RICM_GET_CURRENT_RADIO_DATA_PORT_REQ
%%
%% $Result_1
%%  RICM_GET_CURRENT_RADIO_DATA_PORT_CFM is received
%%  Check is done that the received radio port matches with the test configuration
%%
%%  Action_1 and Result_1 are repeated for all the RUs in the cascaded chain
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  2012-12-18, EJONUNA
%%
%% Revision history:
%%  2012-12-10, EEDAJA
%%    First version
%%
%%------------------------------------------------------------------------------
casc_get_port_1() ->
	[{userdata,[ {wp, ""},
				{requirement, "CBD_RICM-DCI-CURRENT-PORT_FU:1:L"},
				{slogan, "Get port number of radio unit in state starting"},
				{hwConfig, hwConfigA}]}].

casc_get_port_1(_Config) ->
	casc_get_port("casc_get_port_1", starting_lmc_loaded ).

casc_get_port( Name, State ) ->

	ct:pal( Name ),

	% Set state, make audit, establish BCI and DCI connections, subscribe BCI faults
	set_state_and_connect( State ),

	%% Subscribe Faults DCI
	ok = nci_dci_actions:subscribe_faults([]),

	%% Get the cascading radios, or the first radio
	Radios2plus = nci_ricm_utils:get_first_cascaded_radios(),
	if (Radios2plus == []) ->
		Radios = [nci_ricm_utils:get_first_radio()];
	true ->
		Radios = Radios2plus
	end,
 	
  	%% Setup cascading cpri and O&M link
	ok = setup_casc_cpri_link(Radios),

	casc_get_port_no(Radios, Name),

	%% Reset CPRI Links
	[Radio|_] = Radios,  

	%% Release CPRI link on 1st radio
	ok = nci_dci_actions:reset_cpri_link(Radio),

	ok = nci_dci_actions:reset_cpri_link_ind(Radio),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

casc_get_port_no([], _Name) ->
	ok;
	
casc_get_port_no([Radios1|Restradios], Name) ->

	RuId = proplists:get_value(ruId,Radios1),
	{_, RuPortNo} = proplists:get_value(ruPortNo,Radios1),
	RuLnhPath = proplists:get_value(ruLnhPath,Radios1),
							
	%% Check radio loadmodule							
	Checklmc = "lhsh " ++ RuLnhPath ++ " lmclist",

	nci_common_utils:coli_cmd(Checklmc, "SlotProt State"),		
		
	case Name of
		"casc_get_port_5" ->
			%% Get Port
			ct:pal("Action_1"),
			nci_dci_actions:get_current_radio_data_port([{ruId, 99},
														{rePortNo, RuPortNo},
														{expectedSigNo, ?RICM_GET_CURRENT_RADIO_DATA_PORT_REJ},
														{errorCode, 1},
														{errorDescription, {regexp, "ruId not in use*"}}]);
		_ ->
			%% Get Port
			ct:pal("Action_1"),
			nci_dci_actions:get_current_radio_data_port([{ruId, RuId},
														{rePortNo, RuPortNo}])
	end,

	casc_get_port_no(Restradios, Name).

%%------------------------------------------------------------------------------
%% $Id CASC_GET_PORT_2
%%
%% $Header
%%  State Starting
%%
%% $Description
%%  Get port number of radio unit in state operational
%%
%% $Requirements
%%  CBD_RICM-DCI-CURRENT-PORT_FU:1:L
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  Ensure state is in starting, and DP loaded
%%  CPRI links are setup for the whole cascaded chain
%%  Radio control has been added for the whole cascaded chain
%%
%% $Action_1
%%  Send RICM_GET_CURRENT_RADIO_DATA_PORT_REQ
%%
%% $Result_1
%%  RICM_GET_CURRENT_RADIO_DATA_PORT_CFM is received
%%  Check is done that the received radio port matches with the test configuration
%%
%%  Action_1 and Result_1 are repeated for all the RUs in the cascaded chain
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  2012-12-18, EJONUNA
%%
%% Revision history:
%%  2012-12-10, EEDAJA
%%    First version
%%
%%------------------------------------------------------------------------------
casc_get_port_2() ->
	[{userdata,[{wp, ""},
				{requirement, "CBD_RICM-DCI-CURRENT-PORT_FU:1:L"},
				{slogan, "Get port number of radio unit in state operational"},
				{hwConfig, hwConfigA}]}].

casc_get_port_2(_Config) ->
	casc_get_port("casc_get_port_2", operational).

%%------------------------------------------------------------------------------
%% $Id CASC_GET_PORT_3
%%
%% $Header
%%  State Starting
%%
%% $Description
%%  Get port number of radio unit in state disabled
%%
%% $Requirements
%%  CBD_RICM-DCI-CURRENT-PORT_FU:1:L
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  Ensure state is in disabled
%%
%% $Action_1
%%  Send RICM_GET_CURRENT_RADIO_DATA_PORT_REQ
%%
%% $Result_1
%%  RICM_GET_CURRENT_RADIO_DATA_PORT_REJ is received
%%  with error "Invalid O&M state"
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  2012-12-18, EJONUNA
%%
%% Revision history:
%%  2012-12-10, EEDAJA
%%    First version
%%
%%------------------------------------------------------------------------------
casc_get_port_3() ->
	[{userdata,[{wp, ""},
				{requirement, "CBD_RICM-DCI-CURRENT-PORT_FU:1:L"},
				{slogan, "Get port number of radio unit in state disabled"},
				{hwConfig, hwConfigA}]}].

casc_get_port_3(_Config) ->
	ct:pal("casc_get_port_3"),

	% Set state, make audit, establish BCI and DCI connections, subscribe BCI faults
	set_state_and_connect( starting_lmc_loaded ),
	ok = nci_bci_actions:disable_operation([]),

	%% Subscribe Faults DCI
	ok = nci_dci_actions:subscribe_faults([]),

	Radio1 = nci_ricm_utils:get_first_radio(),

	%% Get Port
	ct:pal("Action_1"),
	nci_dci_actions:get_current_radio_data_port(Radio1 ++ [
												{expectedSigNo, ?RICM_GET_CURRENT_RADIO_DATA_PORT_REJ},
												{errorCode, 1},
												{errorDescription, {regexp, "Invalid O&M state*"}}]),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id CASC_GET_PORT_4
%%
%% $Header
%%  State Starting
%%
%% $Description
%%  Get port number of radio unit, DP not loaded
%%
%% $Requirements
%%  CBD_RICM-DCI-CURRENT-PORT_FU:1:L
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  Ensure state is in starting, and DP loaded
%%
%% $Action_1
%%  Send RICM_GET_CURRENT_RADIO_DATA_PORT_REQ
%%
%% $Result_1
%%  RICM_GET_CURRENT_RADIO_DATA_PORT_REJ is received
%%  with error "DP not loaded"
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  2012-12-18, EJONUNA
%%
%% Revision history:
%%  2012-12-10, EEDAJA
%%    First version
%%
%%------------------------------------------------------------------------------
casc_get_port_4() ->
	[{userdata,[{wp, ""},
				{requirement, "CBD_RICM-DCI-CURRENT-PORT_FU:1:L"},
				{slogan, "Get port number of radio unit, DP not loaded"},
				{hwConfig, hwConfigA}]}].

casc_get_port_4(_Config) ->
	ct:pal("casc_get_port_4"),

	% Set state, make audit, establish BCI and DCI connections, subscribe BCI faults
	set_state_and_connect( starting_lmc_not_loaded ),

	%% Subscribe Faults DCI
	ok = nci_dci_actions:subscribe_faults([]),

	Radio1 = nci_ricm_utils:get_first_radio(),

	%% Get Port
	ct:pal("Action_1"),
	nci_dci_actions:get_current_radio_data_port(Radio1 ++ [
												{expectedSigNo, ?RICM_GET_CURRENT_RADIO_DATA_PORT_REJ},
												{errorCode, 1},
												{errorDescription, {regexp, "DP not loaded*"}}]),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id CASC_GET_PORT_5
%%
%% $Header
%%  Invalid ruId
%%
%% $Description
%%  Get port number of radio unit, invalid ruId
%%
%% $Requirements
%%  CBD_RICM-DCI-CURRENT-PORT_FU:1:L
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Cascaded radio
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  Ensure state is in starting, invalid ruId
%%
%% $Action_1
%%  Send RICM_GET_CURRENT_RADIO_DATA_PORT_REQ
%%
%% $Result_1
%%  RICM_GET_CURRENT_RADIO_DATA_PORT_REJ is received
%%  with Error "ruId not in use"
%%
%%  Action_1 and Result_1 are repeated for all the RUs in the cascaded chain
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  2012-12-18, EJONUNA
%%
%% Revision history:
%%  2012-12-10, EEDAJA
%%    First version
%%
%%------------------------------------------------------------------------------
casc_get_port_5() ->
	[{userdata,[{wp, ""},
				{requirement, "CBD_RICM-DCI-CURRENT-PORT_FU:1:L"},
				{slogan, "Get port number of radio unit, invalid ruId"},
				{hwConfig, hwConfigA}]}].

casc_get_port_5(_Config) ->
	casc_get_port("casc_get_port_5", starting_lmc_loaded ).

%%------------------------------------------------------------------------------
%% $Id CASC_GET_REMOTE_PORT_1
%%
%% $Header
%%  State Starting
%%
%% $Description
%%  Get remote port number of radio unit in state starting
%%
%% $Requirements
%%  CBD_RICM-DCI-REMOTE-PORT_FU:1:N
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  Ensure state is in starting, and DP loaded
%%  CPRI links are setup for the whole cascaded chain
%%  Radio control has been added for the whole cascaded chain
%%
%% $Action_1
%%  Send RICM_GET_REMOTE_RADIO_DATA_PORT_REQ
%%
%% $Result_1
%%  RICM_GET_REMOTE_RADIO_DATA_PORT_CFM is received
%%  Check is done that the received remote radio port matches with the test configuration
%%
%%  Action_1 and Result_1 are repeated for all the RUs in the cascaded chain
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  2012-12-18, EJONUNA
%%
%% Revision history:
%%  2012-12-10, EEDAJA
%%    First version
%%
%%------------------------------------------------------------------------------
casc_get_remote_port_1() ->
	[{userdata,[{wp, ""},
				{requirement, "CBD_RICM-DCI-REMOTE-PORT_FU:1:N"},
				{slogan, "Get remote port number of radio unit in state starting"},
				{hwConfig, hwConfigA}]}].

casc_get_remote_port_1(_Config) ->
	casc_get_remote_port("casc_get_remote_port_1", starting_lmc_loaded ).

casc_get_remote_port( Name, State ) ->

	ct:pal( Name ),

	% Set state, make audit, establish BCI and DCI connections, subscribe BCI faults
	set_state_and_connect( State ),

	%% Subscribe Faults DCI
	ok = nci_dci_actions:subscribe_faults([]),

	%% Get the cascading radios, or the first radio
	Radios2plus = nci_ricm_utils:get_first_cascaded_radios(),
	if (Radios2plus == []) ->
		Radios = [nci_ricm_utils:get_first_radio()];
	true ->
		Radios = Radios2plus
	end,
 	
  	%% Setup cascading cpri and O&M link
	ok = setup_casc_cpri_link(Radios),

	casc_get_remote_port_no(Radios, Name),

	%% Reset CPRI Links
	[Radio|_] = Radios,  

	%% Reset CPRI link on 1st radio
	ok = nci_dci_actions:reset_cpri_link(Radio),

	ok = nci_dci_actions:reset_cpri_link_ind(Radio),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

casc_get_remote_port_no([], _Name) ->
	ok;
	
casc_get_remote_port_no([Radios1|Restradios], Name) ->

	RuId = proplists:get_value(ruId,Radios1),
	{_, RuPortNo} = proplists:get_value(ruPortNo,Radios1),
	case RuPortNo of
		0 ->
			RuRemotePortNo = 1;
		_ ->
			RuRemotePortNo = 0
	end,
	RuLnhPath = proplists:get_value(ruLnhPath,Radios1),
							
	%% Check radio loadmodule							
	Checklmc = "lhsh " ++ RuLnhPath ++ " lmclist",

	nci_common_utils:coli_cmd(Checklmc, "SlotProt State"),		
		
	case Name of
		"casc_get_remote_port_5" ->
			%% Get Port
			ct:pal("Action_1"),
			nci_dci_actions:get_remote_radio_data_port([{ruId, 99},
														{reRemotePortNo, RuRemotePortNo},
														{expectedSigNo, ?RICM_GET_REMOTE_RADIO_DATA_PORT_REJ},
														{errorCode, 1},
														{errorDescription, {regexp, "ruId not in use*"}}]);
		_ ->
			%% Get Port
			ct:pal("Action_1"),
			nci_dci_actions:get_remote_radio_data_port([{ruId, RuId},
														{reRemotePortNo, RuRemotePortNo}])
	end,

	casc_get_remote_port_no(Restradios, Name).

%%------------------------------------------------------------------------------
%% $Id CASC_GET_REMOTE_PORT_2
%%
%% $Header
%%  State Starting
%%
%% $Description
%%  Get remote port number of radio unit in state operational
%%
%% $Requirements
%%  CBD_RICM-DCI-REMOTE-PORT_FU:1:N
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  Ensure state is in starting, and DP loaded
%%  CPRI links are setup for the whole cascaded chain
%%  Radio control has been added for the whole cascaded chain
%%
%% $Action_1
%%  Send RICM_GET_REMOTE_RADIO_DATA_PORT_REQ
%%
%% $Result_1
%%  RICM_GET_REMOTE_RADIO_DATA_PORT_CFM is received
%%  Check is done that the received remote radio port matches with the test configuration
%%
%%  Action_1 and Result_1 are repeated for all the RUs in the cascaded chain
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  2012-12-18, EJONUNA
%%
%% Revision history:
%%  2012-12-10, EEDAJA
%%    First version
%%
%%------------------------------------------------------------------------------
casc_get_remote_port_2() ->
	[{userdata,[{wp, ""},
				{requirement, "CBD_RICM-DCI-REMOTE-PORT_FU:1:N"},
				{slogan, "Get remote port number of radio unit in state operational"},
				{hwConfig, hwConfigA}]}].

casc_get_remote_port_2(_Config) ->
	casc_get_remote_port("casc_get_remote_port_2", operational).

%%------------------------------------------------------------------------------
%% $Id CASC_GET_REMOTE_PORT_3
%%
%% $Header
%%  State Starting
%%
%% $Description
%%  Get remote port number of radio unit in state disabled
%%
%% $Requirements
%%  CBD_RICM-DCI-REMOTE-PORT_FU:1:N
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  Ensure state is in disabled
%%
%% $Action_1
%%  Send RICM_GET_REMOTE_RADIO_DATA_PORT_REQ
%%
%% $Result_1
%%  RICM_GET_REMOTE_RADIO_DATA_PORT_REJ is received
%%  with error "Invalid O&M state"
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  2012-12-18, EJONUNA
%%
%% Revision history:
%%  2012-12-10, EEDAJA
%%    First version
%%
%%------------------------------------------------------------------------------
casc_get_remote_port_3() ->
	[{userdata,[{wp, ""},
				{requirement, "CBD_RICM-DCI-REMOTE-PORT_FU:1:N"},
				{slogan, "Get remote port number of radio unit in state disabled"},
				{hwConfig, hwConfigA}]}].

casc_get_remote_port_3(_Config) ->
	ct:pal("casc_get_remote_port_3"),

	% Set state, make audit, establish BCI and DCI connections, subscribe BCI faults
	set_state_and_connect( starting_lmc_loaded ),
	ok = nci_bci_actions:disable_operation([]),

	%% Subscribe Faults DCI
	ok = nci_dci_actions:subscribe_faults([]),

	Radio1 = nci_ricm_utils:get_first_radio(),

	%% Get Port
	ct:pal("Action_1"),
	nci_dci_actions:get_remote_radio_data_port(Radio1 ++ [
												{expectedSigNo, ?RICM_GET_REMOTE_RADIO_DATA_PORT_REJ},
												{errorCode, 1},
												{errorDescription, {regexp, "Invalid O&M state*"}}]),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id CASC_GET_REMOTE_PORT_4
%%
%% $Header
%%  State Starting
%%
%% $Description
%%  Get remote port number of radio unit, DP not loaded
%%
%% $Requirements
%%  CBD_RICM-DCI-REMOTE-PORT_FU:1:N
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  Ensure state is in starting, and DP loaded
%%
%% $Action_1
%%  Send RICM_GET_REMOTE_RADIO_DATA_PORT_REQ
%%
%% $Result_1
%%  RICM_GET_REMOTE_RADIO_DATA_PORT_REJ is received
%%  with error "DP not loaded"
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  2012-12-18, EJONUNA
%%
%% Revision history:
%%  2012-12-10, EEDAJA
%%    First version
%%
%%------------------------------------------------------------------------------
casc_get_remote_port_4() ->
	[{userdata,[{wp, ""},
				{requirement, "CBD_RICM-DCI-REMOTE-PORT_FU:1:N"},
				{slogan, "Get remote port number of radio unit, DP not loaded"},
				{hwConfig, hwConfigA}]}].

casc_get_remote_port_4(_Config) ->
	ct:pal("casc_get_remote_port_4"),

	% Set state, make audit, establish BCI and DCI connections, subscribe BCI faults
	set_state_and_connect( starting_lmc_not_loaded ),

	%% Subscribe Faults DCI
	ok = nci_dci_actions:subscribe_faults([]),

	Radio1 = nci_ricm_utils:get_first_radio(),

	%% Get Port
	ct:pal("Action_1"),
	nci_dci_actions:get_remote_radio_data_port(Radio1 ++ [
												{expectedSigNo, ?RICM_GET_REMOTE_RADIO_DATA_PORT_REJ},
												{errorCode, 1},
												{errorDescription, {regexp, "DP not loaded*"}}]),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id CASC_GET_REMOTE_PORT_5
%%
%% $Header
%%  Invalid ruId
%%
%% $Description
%%  Get remote port number of radio unit, invalid ruId
%%
%% $Requirements
%%  CBD_RICM-DCI-REMOTE-PORT_FU:1:N
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Cascaded radio
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  Ensure state is in starting, invalid ruId
%%
%% $Action_1
%%  Send RICM_GET_REMOTE_RADIO_DATA_PORT_REQ
%%
%% $Result_1
%%  RICM_GET_REMOTE_RADIO_DATA_PORT_REJ is received
%%  with Error "ruId not in use"
%%
%%  Action_1 and Result_1 are repeated for all the RUs in the cascaded chain
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  2012-12-18, EJONUNA
%%
%% Revision history:
%%  2012-12-10, EEDAJA
%%    First version
%%
%%------------------------------------------------------------------------------
casc_get_remote_port_5() ->
	[{userdata,[{wp, ""},
				{requirement, "CBD_RICM-DCI-REMOTE-PORT_FU:1:N"},
				{slogan, "Get remote port number of radio unit, invalid ruId"},
				{hwConfig, hwConfigA}]}].

casc_get_remote_port_5(_Config) ->
	casc_get_remote_port("casc_get_remote_port_5", starting_lmc_loaded ).

%%------------------------------------------------------------------------------
%% $Id casc_set_timing_1
%%
%% $Header
%%  Set timing (sync bit)
%%
%% $Description
%%  Set timing in state starting
%%
%% $Requirements
%%  CBD_RICM_DCI-TIMING-STATUS_FU:1:L
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  CPRI link and radio control up for the cascaded chain.
%%
%% $Action_1
%%  Set timing sbit to zero
%%
%% $Result_1
%%  Status is stored in the FPGA register, and the new value written into the log
%%
%% $Action_2
%%  Set timing sbit to one
%%
%% $Result_2
%%  Status is stored in the FPGA register, and the new value written into the log
%%
%% $Action_3
%%  Set timing sbit to zero
%%
%% $Result_3
%%  Status is stored in the FPGA register, and the new value written into the log
%%
%% $Action_4
%%  Reset CPRI link, and set up CPRI link and radio control again
%%
%% $Result_4
%%  CPRI link reset, set up again and radio control up.
%%
%% $Action_5
%%  Set timing sbit to one
%%
%% $Result_5
%%  Status is stored in the FPGA register, and the new value written into the log
%%
%% $Action_6
%%  Set timing sbit to zero
%%
%% $Result_6
%%  Status is stored in the FPGA register, and the new value written into the log
%%
%% $Action_7
%%  Set timing sbit to one, to restore the correct value at the end of the test case
%%
%% $Result_7
%%  Status is stored in the FPGA register, and the new value written into the log
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  2013-01-16, ejonuna
%%
%% Revision history:
%%  2012-10-02, EEDAJA
%%    First version
%%
%%  2012-12-27, EEDAJA
%%    Changed the test case to be configuration-file dependent.
%%    Included register address calculation based on port number and DU type.
%%
%%  2013-05-20, EYANWZH
%%    Fix the test cases accoding to the result running on cascading radios.
%%
%%  2013-12-05, ejonuna
%%    Corrected test case to follow S bit setting sequence of test case header.
%%------------------------------------------------------------------------------

casc_set_timing_1() ->
	[{userdata,[{wp, "WP358"}, 
				{requirement, "CBD_RICM_DCI-TIMING-STATUS_FU:1:L"},
				{slogan, "Set timing for cascaded radio in state starting"},
				{hwConfig, hwConfigA}]}].

casc_set_timing_1(_Config) ->
		casc_set_timing( "casc_set_timing_1", starting_lmc_loaded).

casc_set_timing( Name, State ) ->
	ct:pal( Name ),

	% Set state, make audit, establish BCI and DCI connections, subscribe BCI faults
	set_state_and_connect( State ),

	%% Subscribe Faults DCI
	ok = nci_dci_actions:subscribe_faults([]),

	%% Get the cascading radios, or the first radio
	Radios2plus = nci_ricm_utils:get_first_cascaded_radios(),
	if (Radios2plus == []) ->
		Radios = [nci_ricm_utils:get_first_radio()];
	true ->
		Radios = Radios2plus
	end,

	%% Setup cascading cpri and O&M link
	ok = setup_casc_cpri_link(Radios),

	ct:pal("Action_1,2,3"),
	set_timing_for_radios(Radios, 0), %%0 == start S bit value

	%% Reset CPRI Link
	ct:pal("Action_4"),
	[Radio|_] = Radios,  

	ok = nci_dci_actions:reset_cpri_link(Radio),
	ok = nci_dci_actions:reset_cpri_link_ind(Radio),

  	%% Setup cascading cpri and O&M link
	ok = setup_casc_cpri_link(Radios),

	ct:pal("Action_5,6,7"),
	set_timing_for_radios(Radios, 1), %%1 == start S bit value

	%% Reset CPRI Link
	[Radio|_] = Radios,  

	ok = nci_dci_actions:reset_cpri_link(Radio),
	ok = nci_dci_actions:reset_cpri_link_ind(Radio),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).


set_timing_for_radios([],_) ->
 ok;

set_timing_for_radios([Radio1 | RestRadios],NextS_BitValue) ->

	PortNo = proplists:get_value(portNo,Radio1),
	RuLnhPath = proplists:get_value(ruLnhPath,Radio1),
							
	% Get address of the register 
	case nci_common_utils:get_du() of
		dul -> % dul20
			AddrCI_PROT_CONF = 16#1c00 + ((PortNo-1) * 16#40) + 16#1A;
		_ ->   % dus41 and mRBS
			AddrCI_PROT_CONF = 16#4000 + ((PortNo-1) * 16#100) + 16#48
	end,

	%% Check radio loadmodule							
	Checklmc = "lhsh " ++ RuLnhPath ++ " lmclist",
	nci_common_utils:coli_cmd(Checklmc, "SlotProt State"),		

	%% Set Timing
	ct:pal("Action_1"),
	S_BitAction1 = NextS_BitValue,
	ok = nci_dci_actions:set_timing_status([{sBit, S_BitAction1}]),

	%% Read and check value of FPGA register CI_PROT_CONF 
	CI_PROT_CONF_Action1 = 16#0302 + (16#40*S_BitAction1),
	CI_PROT_CONF_Action1 = nci_common_utils:rdfpga(AddrCI_PROT_CONF),

	%% need 1s delay for the Radio to set sbit
	timer:sleep(1*1000),
	S_BitAction1 = nci_common_utils:get_sbit(Radio1),

	%% Set Timing
	ct:pal("Action_2"),
	S_BitAction2 = (S_BitAction1 +1) rem 2,
	ok = nci_dci_actions:set_timing_status([{sBit, S_BitAction2}]),

	%% Read and check value of FPGA register CI_PROT_CONF 
	CI_PROT_CONF_Action2 = 16#0302 + (16#40*S_BitAction2),
	CI_PROT_CONF_Action2 = nci_common_utils:rdfpga(AddrCI_PROT_CONF),

	timer:sleep(1*1000),
	S_BitAction2 = nci_common_utils:get_sbit(Radio1),

	%% Set Timing
	ct:pal("Action_3"),
	S_BitAction3 = (S_BitAction2 +1) rem 2,
	ok = nci_dci_actions:set_timing_status([{sBit, S_BitAction3}]),

	%% Read and check value of FPGA register CI_PROT_CONF 
	CI_PROT_CONF_Action3 = 16#0302 + (16#40*S_BitAction3),
	CI_PROT_CONF_Action3 = nci_common_utils:rdfpga(AddrCI_PROT_CONF),

	timer:sleep(1*1000),
	S_BitAction3 = nci_common_utils:get_sbit(Radio1),

	set_timing_for_radios(RestRadios, NextS_BitValue).

%%------------------------------------------------------------------------------
%% $Id casc_set_timing_2
%%
%% $Header
%%  Set timing (sync bit)
%%
%% $Description
%%  Set timing in state operational
%%
%% $Requirements
%%  CBD_RICM_DCI-TIMING-STATUS_FU:1:L
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  CPRI link and radio control up.
%%
%% $Action_1
%%  Set timing sbit to zero
%%
%% $Result_1
%%  Status is stored in the FPGA register, and the new value written into the log
%%
%% $Action_2
%%  Set timing sbit to one
%%
%% $Result_2
%%  Status is stored in the FPGA register, and the new value written into the log
%%
%% $Action_3
%%  Set timing sbit to zero
%%
%% $Result_3
%%  Status is stored in the FPGA register, and the new value written into the log
%%
%% $Action_4
%%  Reset CPRI link, and set up CPRI link and radio control again
%%
%% $Result_4
%%  CPRI link reset, set up again and radio control up.
%%
%% $Action_5
%%  Set timing sbit to one
%%
%% $Result_5
%%  Status is stored in the FPGA register, and the new value written into the log
%%
%% $Action_6
%%  Set timing sbit to zero
%%
%% $Result_6
%%  Status is stored in the FPGA register, and the new value written into the log
%%
%% $Action_7
%%  Set timing sbit to one, to restore the correct value at the end of the test case
%%
%% $Result_7
%%  Status is stored in the FPGA register, and the new value written into the log
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  2013-01-16, ejonuna
%%
%% Revision history:
%%  2012-10-02, EEDAJA
%%    First version
%%
%%  2012-12-27, EEDAJA
%%    Changed the test case to be configuration-file dependent.
%%    Included register address calculation based on port number and DU type.
%%  2013-01-16, ejonuna
%%    Updated header to state operational after review 
%%  2013-12-05, ejonuna
%%    Corrected test case to follow S bit setting sequence of test case header.
%%------------------------------------------------------------------------------

casc_set_timing_2() ->
	[{userdata,[{wp, "WP358"}, 
				{requirement, "CBD_RICM_DCI-TIMING-STATUS_FU:1:L"},
				{slogan, "Set timing for cascaded radio in state operational"},
				{hwConfig, hwConfigA}]}].

casc_set_timing_2(_Config) ->
		casc_set_timing( "casc_set_timing_2", operational).

%%------------------------------------------------------------------------------
%% $Id casc_set_timing_3
%%
%% $Header
%%  Set timing (sync bit)
%%
%% $Description
%%  Set timing in state disabled
%%
%% $Requirements
%%  CBD_RICM_DCI-TIMING-STATUS_FU:1:L
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  CPRI link and radio control up.
%%
%% $Action_1
%%  Attempt to set timing sbit to zero
%%
%% $Result_1
%%  The request is rejected
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  2013-01-16, ejonuna
%%
%% Revision history:
%%  2012-12-27, EEDAJA
%%    First version
%%  2013-01-16, ejonuna
%%    Removed commented code after review
%%------------------------------------------------------------------------------

casc_set_timing_3() ->
	[{userdata,[{wp, "WP358"}, 
				{requirement, "CBD_RICM_DCI-TIMING-STATUS_FU:1:L"},
				{slogan, "Set timing for cascaded radio in state disabled"}]}].

casc_set_timing_3(_Config) ->
	ct:pal("casc_set_timing_3"),

	% Set state, make audit, establish BCI and DCI connections, subscribe BCI faults
	set_state_and_connect( starting_lmc_loaded ),
	nci_bci_states:set_state([{state, disabled}]),

	%% Subscribe Faults DCI
	ok = nci_dci_actions:subscribe_faults([]),

	%% Set Timing
	ct:pal("Action_1"),
	ok = nci_dci_actions:set_timing_status([{sBit, 0},
											{expectedSigNo, ?RICM_SET_TIMING_STATUS_REJ},
											{errorCode, 1},
											{errorDescription, {regexp, "Invalid O&M state*"}}]),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id casc_set_timing_4
%%
%% $Header
%%  Set timing (sync bit)
%%
%% $Description
%%  Set timing, DP not loaded
%%
%% $Requirements
%%  CBD_RICM_DCI-TIMING-STATUS_FU:1:L
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  -
%%
%% $Action_1
%%  Attempt to set timing when DP is not loaded
%%
%% $Result_1
%%  The request is rejected
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  2013-01-16, ejonuna
%%
%% Revision history:
%%  2012-12-27, EEDAJA
%%    First version
%%
%%------------------------------------------------------------------------------

casc_set_timing_4() ->
	[{userdata,[{wp, "WP358"}, 
				{requirement, "CBD_RICM_DCI-TIMING-STATUS_FU:1:L"},
				{slogan, "Set timing, DP not loaded"}]}].

casc_set_timing_4(_Config) ->
	ct:pal("casc_set_timing_4"),

	% Set state, make audit, establish BCI and DCI connections, subscribe BCI faults
	set_state_and_connect( starting_lmc_not_loaded ),

	%% Subscribe Faults DCI
	ok = nci_dci_actions:subscribe_faults([]),

	%% Set Timing
	ct:pal("Action_1"),
	ok = nci_dci_actions:set_timing_status([{sBit, 0},
											{expectedSigNo, ?RICM_SET_TIMING_STATUS_REJ},
											{errorCode, 1},
											{errorDescription, {regexp, "DP not loaded*"}}]),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id casc_set_timing_5
%%
%% $Header
%%  Set timing (sync bit)
%%
%% $Description
%%  Set timing, invalid sBit value
%%
%% $Requirements
%%  CBD_RICM_DCI-TIMING-STATUS_FU:1:L
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  CPRI link and radio control up.
%%
%% $Action_1
%%  Attempt to set timing sbit to invalid value (other than 0 or 1)
%%
%% $Result_1
%%  The request is rejected
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  2013-01-16, ejonuna
%%
%% Revision history:
%%  2012-12-27, EEDAJA
%%    First version
%%
%%------------------------------------------------------------------------------

casc_set_timing_5() ->
	[{userdata,[{wp, "WP358"}, 
				{requirement, "CBD_RICM_DCI-TIMING-STATUS_FU:1:L"},
				{slogan, "Set timing, invalid sBit value"},
				{hwConfig, hwConfigA}]}].  %%TODO: hwConfigB ??

casc_set_timing_5(_Config) ->
	ct:pal("casc_set_timing_5"),

	% Set state, make audit, establish BCI and DCI connections, subscribe BCI faults
	set_state_and_connect( starting_lmc_loaded ),

	%% Subscribe Faults DCI
	ok = nci_dci_actions:subscribe_faults([]),

	%% Get the cascading radios, or the first radio
	Radios2plus = nci_ricm_utils:get_first_cascaded_radios(),
	if (Radios2plus == []) ->
		Radios = [nci_ricm_utils:get_first_radio()];
	true ->
		Radios = Radios2plus
	end,

  	%% Setup cascading cpri and O&M link
	ok = setup_casc_cpri_link(Radios),

	%% Set Timing
	ct:pal("Action_1"),
	ok = nci_dci_actions:set_timing_status([{sBit, 2},
											{expectedSigNo, ?RICM_SET_TIMING_STATUS_REJ},
											{errorCode, 1},
											{errorDescription, {regexp, "S-bit value out of range*"}}]),

	%% Reset CPRI Link
	[Radio|_] = Radios,  

	ok = nci_dci_actions:reset_cpri_link(Radio),
	ok = nci_dci_actions:reset_cpri_link_ind(Radio),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id CASC_RELEASE_SETUP_RCL_1
%%
%% $Header
%%  Cascading radios, Setup Radio Control links again after Release Radio Control links.
%%
%% $Description
%%  Release Radio Control links to RUs from first to last in the cascading chain, then set up Radio Control links to them again.
%%
%% $Requirements
%%  CBD_RICM_DCI-RELEASE-RADIO-CTL_FU:1:C
%%
%% $External References
%%  -
%%
%% $HW Config
%%  At least 2 REs on any port
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state starting.
%%  DP is loaded.
%%  Subscribe DCI faults.
%%  CPRI & ECP is setup to the REs.
%%
%% $Action_1
%%  Send RICM_RELEASE_RADIO_CTL_REQ with parameters:
%%  * ruId = < first radoios >
%%
%% $Result_1a
%%  Received RICM_RELEASE_RADIO_CTL_CFM with parameters:
%%  * ruId = < first radoios >
%%
%% $Result_1b
%%  Received RICM_RELEASE_RADIO_CTL_IND with parameters:
%%  * ruId = < first radoios >
%%
%% $Action_2
%%  Check the ECP links for the first radio by command:
%%  lhsh < First RE lnh path > lmclist
%%
%% $Result_2
%%  Failed to connect to bxp for the first radio by looking in the screen printout for keywords:
%%  "failed to connect to < First RE lnh path >"
%%
%% $Action_3
%%  Check the ECP links for all the rest cascaded radios by command:
%%  lhsh < Casc RE lnh patf > lmclist
%%
%% $Result_3a
%%  Failed to connect to bxp for all the rest cascaded radios by looking in the screen printout for keywords:
%%  "failed to connect to < Casc RE lnh path >"
%%
%% $Result_3b
%%  Recevied RICM_ADD_RADIO_CTL_IND for all the rest cascaded radios with parameters:
%%  * ruId = < rest cascaded radoios>
%%  * connStatus = 0
%%
%% $Action_4
%%  Send RICM_ADD_RADIO_CTL_REQ with parameters:
%%  * ruId = < first radio>
%%
%% $Result_4a
%%  Received ADD_RADIO_CTL_CFM wit parameter:
%%  * ruId = < first radio>
%%
%% $Result_4b
%%  Received RADIO_CTL_IND with parameters:
%%  * ruId = < first radio>
%%  * connStatus = 1
%%
%% $Result_4c
%%  Recevied RICM_START_CPRI_LINK_IND for all the rest cascaded radios with parameters:
%%  * ruId = < rest cascaded radoios>
%%  * availStatus = 1
%%
%% $Result_4d
%%  Recevied RICM_ADD_RADIO_CTL_IND for all the rest cascaded radios with parameters:
%%  * ruId = < rest cascaded radoios>
%%  * connStatus = 1
%%
%% $Action_5
%%  Repeat from Action_1 to Action_4 for all cascaded radios.
%%
%% $Result_5
%%  Same result froam Result_1 to Result_4.
%%
%% $Postcondition
%%  CPRI links are down.
%%
%% $End
%%
%% Review:
%%  -
%%
%% Revision history:
%%  2013-07-24, EDEYICH
%%    First version
%%    The test case need the RICR revision is RICR_5.12.2 or later.
%%------------------------------------------------------------------------------
casc_release_setup_rcl_1() ->
	[{userdata,[{wp, ""},
				{requirement, "CBD_RICM_DCI-RELEASE-RADIO-CTL_FU:1:C"},
				{slogan, "Cascading radios, Setup Radio Control links again after Release Radio Control links."},
				{hwConfig, hwConfigB}]}].

casc_release_setup_rcl_1(_Config) ->
	ct:pal("casc_release_setup_rcl_1"),

	{ok, session_up} = coli:subscribe_state(?SHELL_COMMAND),
	{ok, session_up} = osegw:subscribe_state(?OSE_GW_DEAMON_1),

	% Set state, make audit, establish BCI and DCI connections, subscribe faults
	set_state_and_connect( starting_lmc_loaded ),

	%% Subscribe Faults DCI
	ok = nci_dci_actions:subscribe_faults([]),

	Radios = nci_ricm_utils:get_first_cascaded_radios(),

	lists:foreach(fun(RadioX) ->
		%% Start CPRI
		ok = nci_dci_actions:start_cpri_link(RadioX),
		ok = nci_dci_actions:cpri_link_ind(RadioX ++ [{typeOfUnit, '_'},{availStatus, 1}]),

		%% Add Radio Control
		nci_dci_actions:add_radio_control(RadioX ++ [{expectedSigNo, ?RICM_ADD_RADIO_CTL_CFM}]),
		nci_dci_actions:radio_control_ind(RadioX ++ [{connStatus, 1},{radioSoftware,application}])
	end,
	Radios),

	%% Reset and Setup Radio Control Link again on the Cascading Chain
	casc_release_radios_clt(Radios),

	%% Postcondition:Reset CPRI Link
	[Radio1|_] = Radios,

	ok = nci_dci_actions:reset_cpri_link(Radio1),
	ok = nci_dci_actions:reset_cpri_link_ind(Radio1),

	%% Check that NO DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).
%%------------------------------------------------------------------------------
casc_release_radios_clt([]) ->
	ok;
casc_release_radios_clt([Radio | RestRadios]) ->
	ct:pal("Action_1 & Result_1a"),
	nci_dci_actions:release_radio_control(Radio ++ [{expectedSigNo, ?RICM_RELEASE_RADIO_CTL_CFM}]),

	ct:pal("Result_1b"),
	nci_dci_actions:release_radio_control_ind(Radio),

	ct:pal("Action_2 & Result_2"),
	RuLnhPath = proplists:get_value(ruLnhPath,Radio),
	nci_common_utils:coli_cmd("lhsh " ++ RuLnhPath ++ " lmclist", "failed to connect to " ++ RuLnhPath),

	%% Check the ECP links for all the cascaded radios.
	lists:foreach(fun(Radio2) ->
		ct:pal("Action_3 & Result_3a"),
		RuLnhPath1 = proplists:get_value(ruLnhPath,Radio2),
		nci_common_utils:coli_cmd("lhsh " ++ RuLnhPath1 ++ " lmclist", "failed to connect to " ++ RuLnhPath1),

		ct:pal("Result_3b"),
		nci_dci_actions:radio_control_ind(Radio2 ++ [{connStatus, 0}])
	end,
	RestRadios),

	%% Add Radio Control for first RU again.
	ct:pal("Action_4 & Result_4a"),
	nci_dci_actions:add_radio_control(Radio ++ [{expectedSigNo, ?RICM_ADD_RADIO_CTL_CFM}]),

	ct:pal("Result_4b"),
	nci_dci_actions:radio_control_ind(Radio ++ [{connStatus, 1},{radioSoftware,application}]),

	%% The CPRI and ECP link of rest radio will recover.
	lists:foreach(fun(Radio2) ->
		ct:pal("Result_4c"),
		ok = nci_dci_actions:cpri_link_ind(Radio2 ++ [{availStatus, 1}]),

		ct:pal("Result_4d"),
		ok = nci_dci_actions:radio_control_ind(Radio2 ++ [{connStatus, 1},{radioSoftware,application}])
	end,
	RestRadios),

	casc_release_radios_clt(RestRadios).
%%------------------------------------------------------------------------------
%% $Id CASC_RELEASE_SETUP_RCL_2
%%
%% $Header
%%  State Starting
%%
%% $Description
%%  Verify add, release, add again radio control in state starting
%%
%% $Requirements
%%  CBD_RICM_DCI-RELEASE-RADIO-CTL_FU:1:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state starting.
%%
%% NOTE: All the following steps are repeated for all the configured radios
%%
%% $Action_1
%%  Send a START_CPRI_LINK_REQ
%%
%% $Result_1a
%%  An START_CPRI_LINK_CFM is received
%%
%% $Result_1b
%%  An CPRI_LINK_IND is received with
%%
%%  availableStatus = 1
%%
%% $Action_2
%%  Send an ADD_RADIO_CTL_REQ
%%
%% $Result_2a
%%  An ADD_RADIO_CTL_CFM is received
%%
%% $Result_2b
%%  An RADIO_CTL_IND is received with
%%
%%  connStatus = 1
%%
%% $Action_3
%%  Test the connection with shellcommand "lhsh BXP_3_1 lmclist"
%%
%% $Result_3
%%  The shellcommand is successful
%%
%% $Action_4
%%  Send an RELEASE_RADIO_CTL_REQ
%%
%% $Result_4a
%%  An RELEASE_RADIO_CTL_CFM is received
%%
%% $Result_4b
%%  An RADIO_CTL_IND is received with
%%
%%  connStatus = 0
%%
%% $Action_5
%%  Test the connection with shellcommand "lhsh BXP_3_1 lmclist"
%%
%% $Result_5
%%  The shellcommand is unsuccessful
%%
%% $Action_6
%%  Send an ADD_RADIO_CTL_REQ
%%
%% $Result_6a
%%  An ADD_RADIO_CTL_CFM is received
%%
%% $Result_6b
%%  An RADIO_CTL_IND is received with
%%
%%  connStatus = 1
%%
%% $Action_7
%%  Test the connection with shellcommand "lhsh BXP_3_1 lmclist"
%%
%% $Result_7
%%  The shellcommand is successful
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%%  2013-01-16, ejonuna
%%
%% Revision history:
%%  2013-01-04, EEDAJA
%%    First version
%%  2013-01-16, ejonuna
%%    Updated lhsh's huntpath after review
%%
%%------------------------------------------------------------------------------
casc_release_setup_rcl_2() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_RICM_DCI-RELEASE-RADIO-CTL_FU:1:C"},
				{slogan, "State Starting"},
				{hwConfig, hwConfigA}]}].

casc_release_setup_rcl_2(_Config) ->
	ct:pal("casc_release_setup_rcl_2"),

	% Set state, make audit, establish BCI and DCI connections, subscribe faults
	set_state_and_connect( starting_lmc_loaded ),

	%% Subscribe Faults DCI
	ok = nci_dci_actions:subscribe_faults([]),

	Radios = nci_ricm_utils:get_all_radios(),

	lists:foreach(fun(RadioX) ->

		%% Start CPRI
		ok = nci_dci_actions:start_cpri_link(RadioX),
		ok = nci_dci_actions:cpri_link_ind(RadioX ++ [{availStatus, 1}]),

		%% Add Radio Control
		nci_dci_actions:add_radio_control(RadioX ++ [{expectedSigNo, ?RICM_ADD_RADIO_CTL_CFM}]),
		nci_dci_actions:radio_control_ind(RadioX ++ [{connStatus, 1},{radioSoftware, application}]),

		RuLnhPath = proplists:get_value(ruLnhPath,RadioX),

		nci_common_utils:coli_cmd("lhsh " ++ RuLnhPath ++ " lmclist", "SlotProt State"),

		%% Release Radio Control
		nci_dci_actions:release_radio_control(RadioX ++ [{expectedSigNo, ?RICM_RELEASE_RADIO_CTL_CFM}]),
		nci_dci_actions:release_radio_control_ind(RadioX),

		timer:sleep(2000),

		%% Add Radio Control again
		nci_dci_actions:add_radio_control(RadioX ++ [{expectedSigNo, ?RICM_ADD_RADIO_CTL_CFM}]),
		nci_dci_actions:radio_control_ind(RadioX ++ [{connStatus, 1}]),

		nci_common_utils:coli_cmd("lhsh " ++ RuLnhPath ++ " lmclist", "SlotProt State")

	end,
	Radios),

	reset_all_cpri_links(Radios),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id casc_reset_cpri_1
%%
%% $Header
%% State Starting
%%
%% $Description
%% Cascading test , Verify reset CPRI link in state starting.
%% 
%% $Requirements
%%  CBD_RICM_LTE-START-CASCADED-CPRI_FU:2:N
%%  CBD_RICM_START-CASCADED-CPRI_FU:1:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state starting.
%%  DP is loaded
%%  Subscribe faults for both BCI and DCI
%%  CPRI link and O&M link is started according to configuration
%%
%% Repeat Action_1 ~ 8 for all radios
%% $Action_1
%%  Send a RICM_RESET_CPRI_LINK_REQ with parameters:
%%
%%  ruId = ruId of selected radio
%%
%% $Result_1A
%%  A RICM_RESET_CPRI_LINK_CFM is received with parameters:
%%
%%  ruId = ruId of selected radio
%% 
%% $Result_1B
%%  A RICM_RESET_CPRI_LINK_IND is received with parameters:
%%
%%  ruId = ruId of selected radio
%%
%% $Action_2
%%  Check the received signal.
%%
%% $Result_2
%%  No signal is received
%%
%% Repeat Action_3 & Action_4 for the selected radio in Action_1 and radios in the cascade chain with larger cascadeNo
%% $Action_3
%%  Send a RICM_START_CPRI_LINK_REQ
%%
%% $Result_3A
%%  A RICM_START_CPRI_LINK_CFM is received
%%
%% $Result_3B
%%  A RICM_START_CPRI_LINK_IND is received
%%
%% $Action_4
%%  Send a RICM_ADD_RADIO_CTL_REQ:
%%
%% $Result_4A
%%  A RICM_ADD_RADIO_CTL_CFM is received
%%
%% $Result_4B
%%  A RICM_ADD_RADIO_CTL_IND is received with Parameters:
%%
%%  connStatus = 1
%%
%%  huntPath = _
%%
%% Repeat Action_5 for all the cascaded radios:
%% $Action_5
%%  lhsh 000100/BXP_x_x lmclist
%%
%% $Result_5
%%  Radio is connected
%%
%% $Action_6
%%  lhsh 000100/BXP_x_x te log read
%%
%% $Result_6
%%  log "startRestartCause: IBOOT_CPLD_UART_RESET" is found
%%
%% $Action_7
%%  lhsh 000100/BXP_x_x te log clear
%%
%% $Result_7
%%  Radio te log is cleared
%%
%% $Postcondition
%%  Reset cpri link on all radios
%%
%% $End
%%
%% Review:
%%  2012-11-29, EJONUNA
%%
%% Revision history:
%%  2012-11-28, EYANWZH
%%    First version
%%  2012-12-03, EJINQIU
%%    Updated review comments
%%  2013-08-06, EDEYICH
%%    Updated by RICM FD(charpter 3.2.7)
%%
%%------------------------------------------------------------------------------
casc_reset_cpri_1() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_RICM_LTE-START-CASCADED-CPRI_FU:2:N, CBD_RICM_START-CASCADED-CPRI_FU:1:C"},
				{slogan, "Cascading test , Verify reset CPRI link in state starting"},
				{hwConfig, hwConfigB}]}].

casc_reset_cpri_1(_Config) ->
	casc_reset_cpri_1("casc_reset_cpri_1", starting_lmc_loaded).
	
casc_reset_cpri_1(Name, State) ->
	ct:pal(Name),

	% Set state, make audit, establish BCI and DCI connections, subscribe faults
	set_state_and_connect( State ),

	%% Subscribe Faults DCI
	ok = nci_dci_actions:subscribe_faults([]),

	%% Get the cascading radios, or the first radio
	Radios2plus = nci_ricm_utils:get_first_cascaded_radios(),
	
	if (Radios2plus == []) ->
		Radios = [nci_ricm_utils:get_first_radio()];
	true ->
		Radios = Radios2plus
	end,

  	%% Setup cascading cpri and O&M link
	ok = setup_casc_cpri_link(Radios),

	%% Reset and Setup link again on the Cascading Chain
	ok = casc_reset_cpri(Radios),	

	%% Reset CPRI Link
	[Radio|_] = Radios,  

	ok = nci_dci_actions:reset_cpri_link(Radio),

	ok = nci_dci_actions:reset_cpri_link_ind(Radio),

	%% Check that NO BC/DC_FAULT_IND is generated
	nci_common_utils:check_outstanding_faults(2000).

%%--------------------------------------------------------------------
%% setup_casc_cpri_link is used to setup cascading cpril and O&M link
%%--------------------------------------------------------------------
setup_casc_cpri_link(Radios) ->
	setup_casc_cpri_link(Radios, "_").
	
setup_casc_cpri_link([],_Radio_log_clear) ->
	ok;
	
setup_casc_cpri_link([Radio|RestRadios],Radio_log_clear) ->
	RuId = proplists:get_value(ruId, Radio),
	PortNo = proplists:get_value(portNo, Radio),
	CascadeNo = proplists:get_value(cascadeNo, Radio),
	RuLnhPath = proplists:get_value(ruLnhPath, Radio),

	ct:pal("Setup CPRI and O&M link on portNo ~p and cascadeNo ~p with ruId ~p~n", [PortNo, CascadeNo, RuId]),

	%% Start CPRI
	ok = nci_dci_actions:start_cpri_link(Radio),
	ok = nci_dci_actions:cpri_link_ind(Radio),

	%% Add Radio Control
	nci_dci_actions:add_radio_control(Radio),
	nci_dci_actions:radio_control_ind(Radio ++ [{connStatus, 1},
												{radioSoftware, application}]),

	case Radio_log_clear of
		radio_log_clear ->
			nci_common_utils:coli_cmd("lhsh " ++ RuLnhPath ++ " te log clear");
		"_" ->
			ok;
		_ ->
			ct:fail("invalid parameter")
	end,

	setup_casc_cpri_link(RestRadios, Radio_log_clear).

%%---------------------------------------------------------------------------------
%% casc_reset_cpri is used to reset cpri link and re-setup cpri and O&M link again 
%% on the cascading chain. Also in this function ,check radio restart reason (L1 reset)
%% on the radio log
%%--------------------------------------------------------------------------------
	
casc_reset_cpri([]) ->
	ok;
	
casc_reset_cpri([Radios1|Restradios]) ->
	
	ct:pal("Action_1"),
	ok = nci_dci_actions:reset_cpri_link(Radios1),
	ct:pal("Result_1B"),
	ok = nci_dci_actions:reset_cpri_link_ind(Radios1),
	
	ct:pal("Action_2"),	
	nci_common_utils:check_outstanding_faults(2000),

	ct:pal("Action_3,4,5"),
	ok = setup_casc_cpri_link([Radios1|Restradios]),

	RuLnhPath = proplists:get_value(ruLnhPath,Radios1),

	ct:pal("Action_6"),
	nci_common_utils:find_string_in_te_log_radio(?SHELL_COMMAND, "startRestartCause: IBOOT_CPLD_UART_RESET", RuLnhPath),

	ct:pal("Action_7"),
	nci_common_utils:clear_te_log_radio(?SHELL_COMMAND, RuLnhPath),

	casc_reset_cpri(Restradios).

%%------------------------------------------------------------------------------
%% $Id CASC_RESET_RADIO_1
%%
%% $Header
%% State Starting
%%
%% $Description
%% Cascading test , Verify reset radio control in state starting.
%% 
%% $Requirements
%%  CBD_RICM_LTE-START-CASCADED-CPRI_FU:2:N
%%  CBD_RICM_DCI-RESET-RADIO-CONTROL-LINK_FU:1:H
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Cascaded radios
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state starting.
%%  DP is loaded
%%  Subscribe faults for both BCI and DCI
%%  CPRI link and O&M link is started according to configuration
%%
%% $Action_1
%% Setup carriers on the radio on the chain
%% 
%% $Result_1
%% Carriers are setup .
%%
%% $Action_2
%%  Send a RICM_RESET_RADIO_CTL_REQ with parameters:
%%
%%  ruId = 1(first radio on the chain)
%%
%% $Result_2A
%%  A RICM_RESET_RADIO_CTL_CFM is received with parameters:
%%
%%  ruId = 1 
%% 
%% $Result_2B
%%  A RICM_RESET_RADIO_CTL_IND is received with parameters:
%%
%%  ruId = 1 
%%
%% $Action_3
%%  Check the received signal.
%%
%% $Result_3A
%%  A RICM_RESET_RADIO_CTL_IND is received with parameters:ruId = RuId(all the radio on the following chain)
%%
%% $Result_3B
%%  A RICM_START_CPRI_LINK_IND is received with parameters:availStatus = 0 for all the radio on the chain(from current to last)
%%
%% $Result_3C
%%  Receive the fault with indication : Temporary not in operation
%%
%% $Result_3D
%% The fault with indication : Temporary not in operation was ceased
%%
%% $Result_3E
%%  Receive the fault with indication : Not in operation
%%
%% $Result_3F
%%  A RICM_START_CPRI_LINK_IND is received with parameters:availStatus = 1 for the current radio
%%
%% $Result_3G
%% The fault with indication : Not in operation was ceased.
%%
%% $Action_4
%%  Send a RICM_ADD_RADIO_CTL_REQ with parameters:
%%
%%  ruId = 1
%%
% $Result_4A
%%  A RICM_ADD_RADIO_CTL_CFM is received with parameters:
%%
%%  ruId = 1 
%% 
%% $Result_4B
%%  A RICM_ADD_RADIO_CTL_IND is received with parameters:
%%
%%  ruId = 1 
%%
%% $Action_5
%% Check the received signal
%%
%% $Result_5
%% A RICM_START_CPRI_LINK_IND is received with parameters:availStatus = 1 for the next radio
%%
%% $Action_6
%% Send a RICM_ADD_RADIO_CTL_REQ for the next radio
%%
%% Result_6
%% RICM_ADD_RADIO_CTL_CFM and RICM_ADD_RADIO_CTL_IND are received for the next radio.
%%
%% $Action_7
%%  Repeat Action_5 and Action_6 for the radio on the following chain
%%
%% $Result_7
%% Same result as Result_5 and Result_6
%%
%% $Action_8
%%  Verify that the CPRI link to the radio is up by running lmclist command.
%%
%% $Result_8
%%  lmclist command returns a result.
%%
%% $Action_9
%% Setup carrier as Action_1
%%
%% $Result_9
%% carrier setup was reject with error : carrierId already in use 
%%
%% $Action_10
%% Repeat Action_2 to Action_9 for the radio on the following chain
%% 
%% $Result_10
%% Same result as Result_2 to Result_9.
%%
%% $Postcondition
%%  Reset cpri link on all radios
%%
%% $End
%%
%% Review:
%%  20xx-xx-xx, SIGNUM (Exxxxxx)
%%
%% Revision history:
%%  2012-12-27, Eyanwzh
%%    First version
%%  2013-07-04, EDEYICH
%%    Modify test case from updated RICM FD(chapter3.2.7),because of HQ80009
%%  2014-03-10, EMASNOK
%%    Added checks for new fault signal: "Temporary not in operation"
%%  2014-04-02, EMASNOK
%%    Added delay before restarting radio.
%%
%%------------------------------------------------------------------------------
casc_reset_radio_1() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_RICM_LTE-START-CASCADED-CPRI_FU:2:N, CBD_RICM_DCI-RESET-RADIO-CONTROL-LINK_FU:1:H"},
				{slogan, "Cascading test , Verify reset radio control in state starting"},
				{hwConfig, hwConfigB}]}].
	
casc_reset_radio_1(_Config) ->
	ct:pal("casc_reset_radio_1"),

	% Set state, make audit, establish BCI and DCI connections, subscribe faults
	set_state_and_connect( starting_lmc_loaded ),

	%% Subscribe Faults DCI
	ok = nci_dci_actions:subscribe_faults([]),

	%% Get the cascading radios, or the first radio
	Radios = nci_ricm_utils:get_first_cascaded_radios(),
 	
  	%% Setup cascading cpri and O&M link
	ok = setup_casc_cpri_link(Radios, radio_log_clear),
	
	ct:pal("Action_1"),
	%% Setup carrier 
	XioPortDL = case nci_common_utils:get_du() of
		dul -> 1;
		dus -> 6;
		mRBS_lte -> 6;
		_ -> 1
	end,
	
	NoOfSamples = 2,
	lists:foreach(fun(RadioItemValue) ->

		RuId = proplists:get_value(ruId,RadioItemValue),

		%% Add Carriers UL
		ok = nci_dci_actions:carrier_setup3(RadioItemValue ++ [
									{xioPort, 0},
									{direction, ?RICM_CARRIER_DIRECTION_UL},
									{carrierId, 2*RuId-2},
									{posA, (2*RuId-2) rem 30},
									{noOfSamples, NoOfSamples},
									{isSubBand, ?ELIB_CONST_HWU_YES}]),
		%% Add Carriers DL
		ok = nci_dci_actions:carrier_setup3(RadioItemValue ++ [
									{xioPort, XioPortDL},
									{direction, ?RICM_CARRIER_DIRECTION_DL},
									{carrierId, 2*RuId-1},
									{posA, (2*RuId-2) rem 30},
									{noOfSamples, NoOfSamples},
									{isSubBand, ?ELIB_CONST_HWU_YES}])
	end,
	Radios),	

	%% Action_2 to Action_10
	ok = casc_reset_radio(Radios),	

	%% Reset CPRI Link
	[Radio|_] = Radios,  

	ok = nci_dci_actions:reset_cpri_link(Radio),

	ok = nci_dci_actions:reset_cpri_link_ind(Radio),

	%% Check that NO BC/DC_FAULT_IND is generated
	nci_common_utils:check_outstanding_faults(2000).
%%--------------------------------------------------------------------------------
casc_reset_radio([]) ->
	ok;
	
casc_reset_radio([Radios1|Restradios]) ->
	nci_ricm_utils:workaround_HS24704(),
	
	ct:pal("Action_2"),
	%% Reset Radio Control
	ok = nci_dci_actions:reset_radio_control(Radios1),	
		
	ct:pal("Action_3"),
	lists:foreach(fun(RadioItemValue) ->
	
		ok = nci_dci_actions:radio_reset_control_ind(RadioItemValue)

	end,
	Restradios),	

	lists:foreach(fun(RadioItemValue) ->
	
		ok = nci_dci_actions:cpri_link_ind(RadioItemValue ++[{availStatus, 0}])
		
	end,
	[Radios1|Restradios]),	

	FaultId1 = nci_dci_actions:fault_ind([{oseGwDeamon,?OSE_GW_DEAMON_1},
										  {faultId, ?ELIB_CONST_FH_FAULT_ID_LF_STABILITY},
										  {faultDescription, {regexp, "Temporary not in operation*"}}]),

	ok = nci_dci_actions:fault_cease_ind([{faultId, FaultId1}]), 

	FaultId2 = nci_dci_actions:fault_ind([{oseGwDeamon,?OSE_GW_DEAMON_1},
								{faultId, ?ELIB_CONST_FH_FAULT_ID_LINK_FAILURE},
								{faultDescription, {regexp, "Not in operation*"}}]),  
								
	ok = nci_dci_actions:cpri_link_ind(Radios1 ++[{availStatus, 1}]),
	
	ok = nci_dci_actions:fault_cease_ind([{faultId,FaultId2}]), 

	nci_ricm_utils:workaround_HS24704(),
	
	ct:pal("Action_4"),

	nci_dci_actions:add_radio_control(Radios1 ++ [{expectedSigNo, ?RICM_ADD_RADIO_CTL_CFM}]),     
	nci_dci_actions:radio_control_ind(Radios1 ++ [{connStatus, 1}, {radioSoftware, application}]),
	
	ct:pal("Action_5,6,7"),
	lists:foreach(fun(RadioItemValue) ->

		ok = nci_dci_actions:cpri_link_ind(RadioItemValue ++[{availStatus, 1}]),

		nci_dci_actions:add_radio_control(RadioItemValue), 

		nci_dci_actions:radio_control_ind(RadioItemValue ++ [{connStatus, 1},{radioSoftware, application}])
	end,
	Restradios),
	
	ct:pal("Action_8"),
	RuLnhPath = proplists:get_value(ruLnhPath,Radios1),
	nci_common_utils:coli_cmd("lhsh " ++ RuLnhPath ++ " lmclist", "SlotProt State"),


	ct:pal("Action_9"),
	XioPortDL = case nci_common_utils:get_du() of
		dul -> 1;
		dus -> 6;
		mRBS_lte -> 6;
		_ -> 1
	end,
	
	NoOfSamples = 2,
	lists:foreach(fun(RadioItemValue) ->
		
		RuId = proplists:get_value(ruId,RadioItemValue),

		%% Add Carriers UL
		ok = nci_dci_actions:carrier_setup3(RadioItemValue ++ [
									{xioPort, 0},
									{direction, ?RICM_CARRIER_DIRECTION_UL},
									{carrierId, 2*RuId-2},
									{posA, (2*RuId-2) rem 30},
									{noOfSamples, NoOfSamples},
									{isSubBand, ?ELIB_CONST_HWU_YES},
									{expectedSigNo, ?RICM_CARRIER_SETUP_REJ},
									{errorCode, 1},
									{errorDescription, {regexp, "carrierId already in use*"}}]),
		%% Add Carriers DL
		ok = nci_dci_actions:carrier_setup3(RadioItemValue ++ [
									{xioPort, XioPortDL},
									{direction, ?RICM_CARRIER_DIRECTION_DL},
									{carrierId, 2*RuId-1},
									{posA, (2*RuId-2) rem 30},
									{noOfSamples, NoOfSamples},
									{isSubBand, ?ELIB_CONST_HWU_YES},
									{expectedSigNo, ?RICM_CARRIER_SETUP_REJ},
									{errorCode, 1},
									{errorDescription, {regexp, "carrierId already in use*"}}])
	end,
	[Radios1|Restradios]),	
	
	casc_reset_radio(Restradios).
	
%%------------------------------------------------------------------------------
%% $Id CASC_RESET_SECOND_RU
%%
%% $Header
%% State Starting
%%
%% $Description
%% Cascading test , Verify reset second radio control in state starting.
%% 
%% $Requirements
%%  CBD_RICM_LTE-START-CASCADED-CPRI_FU:2:N
%%  CBD_RICM_DCI-RESET-RADIO-CONTROL-LINK_FU:1:H
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Any
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state starting.
%%  DP is loaded
%%  Subscribe faults for both BCI and DCI
%%  CPRI link and O&M link is started according to configuration
%%
%% $Action_1
%% Restart the second radio with moshell cmd on the chain
%% 
%% $Result_1A
%% the second radio restart .
%%
%% $Action_2
%%  Check the received signal.
%%
%% $Result_2A
%%  A RICM_START_CPRI_LINK_IND is received with parameters:
%%
%%  ruId = 2
%%  status = 0
%%
%% $Result_2B
%%  A RICM_ADD_RADIO_CTL_IND is received with parameters:
%%
%%  ruId = 2 
%%  status = 0
%%
%% $Result_2C
%% Receive the fault with indication : Temporary not in operation
%%
%% $Result_2D
%% The fault with indication : Temporary not in operation was ceased
%%
%% $Result_2E
%% Receive the fault with indication : Not in operation
%%
%% $Result_2F
%%  A RICM_START_CPRI_LINK_IND is received with parameters:
%%
%%  ruId = 2
%%  status = 1
%%
%% $Result_2G
%%  A RICM_ADD_RADIO_CTL_IND is received with parameters:
%%
%%  ruId = 2 
%%  status = 1
%%
%% $Result_2H
%% The fault with indication : Not in operation was ceased.
%%
%% $Postcondition
%%  Reset cpri link on all radios
%%
%% $End
%%
%% Review:
%%  2013-01-05, eyanwzh
%%
%% Revision history:
%%  2013-01-05, EWENYWU
%%    First version
%%  2014-03-10, EMASNOK
%%    Added checks for new fault signal: "Temporary not in operation"
%%  2014-04-02, EMASNOK
%%    Added delay before restarting radio. Removed T&E checks.
%%
%%------------------------------------------------------------------------------
casc_reset_second_ru() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_RICM_LTE-START-CASCADED-CPRI_FU:2:N, CBD_RICM_DCI-RESET-RADIO-CONTROL-LINK_FU:1:H"},
				{slogan, "Cascading test , Verify reset second radio control in state starting"},
				{hwConfig, hwConfigB}]}].
	
casc_reset_second_ru(_Config) ->
	ct:pal("casc_reset_second_ru"),
	
	% Set state, make audit, establish BCI and DCI connections, subscribe faults
	set_state_and_connect( starting_lmc_loaded ),

	%% Subscribe Faults DCI
	ok = nci_dci_actions:subscribe_faults([]),
		
	%% Get the cascading radios, or the first radio
	Radios2plus = nci_ricm_utils:get_first_cascaded_radios(),
	
	Radios = Radios2plus,
	
	[FirstRadio|RestRadios] = Radios,
	[SecondRadio|_] = RestRadios,
 	
	%% Setup cascading cpri and O&M link
	ok = setup_casc_cpri_link(Radios, radio_log_clear),

	ct:pal("Action_1"),
	restart_ru(SecondRadio),
	
	%%check signals
	ct:pal("Action_2"),
	SecondRuId = proplists:get_value(ruId,SecondRadio),
	ok = nci_dci_actions:cpri_link_ind([{ruId, SecondRuId},	{availStatus, 0}]),
	
	ok = nci_dci_actions:radio_control_ind(SecondRadio ++ [{connStatus, 0}]),

	FaultId1 = nci_dci_actions:fault_ind([{oseGwDeamon,?OSE_GW_DEAMON_1},
										  {faultId, ?ELIB_CONST_FH_FAULT_ID_LF_STABILITY},
										  {faultDescription, {regexp, "Temporary not in operation*"}}]),

	ok = nci_dci_actions:fault_cease_ind([{faultId, FaultId1}]), 
	
	FaultId2 = nci_dci_actions:fault_ind([{oseGwDeamon,?OSE_GW_DEAMON_1},
										  {faultId, ?ELIB_CONST_FH_FAULT_ID_LINK_FAILURE},
										  {faultDescription, {regexp, "Not in operation*"}}]),
	


	ok = nci_dci_actions:cpri_link_ind([{ruId, SecondRuId}, {availStatus, 1}]),

	ok = nci_dci_actions:radio_control_ind(SecondRadio ++ [{connStatus, 1}]),
													
	ok = nci_dci_actions:fault_cease_ind([{faultId, FaultId2}]), 
	
	%% Reset CPRI Link 
	RuId = proplists:get_value(ruId,FirstRadio),
	 
	ok = nci_dci_actions:reset_cpri_link([{ruId, RuId}]),

	ok = nci_dci_actions:reset_cpri_link_ind([{ruId, RuId}]),
	
	%% Check that NO BC/DC_FAULT_IND is generated
	nci_common_utils:check_outstanding_faults(2000).


%%------------------------------------------------------------------------------
%% $Id dci_fct
%%
%% $Header
%%  State Starting - fault cease time difference
%%
%% $Description
%%  Verify the fault cease time differenc is valid. There isn't a real requirement on RICM for this 
%%  but since NC uses a 2.7 seconds timout after the link is up and create a alarm in case the link 
%%  fault isn't ceased we test using 2.5 seconds to have a little bit of margin.
%% 
%% $Requirements
%%
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  At least one RU
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state starting.
%%  DP is loaded
%%  Subscribe faults for both BCI and DCI
%%  CPRI link and O&M link is started according to configuration
%%
%% $Action_1
%%  Restart the first radio with moshell cmd on the chain
%% 
%% $Result_1a
%%  Radio restarted signaling.
%%
%% $Result_1b
%%  Time between RICM_ADD_RADIO_CTL_IND status 1 and FAULTCEASE_IND with indication 
%%  loss of signal is less then 2.5 seconds for the restarted radio.
%%
%% $Action_2
%%  Repeat Action1 for all radios connected on the chain
%%
%% $Result_2
%%  Same result for all radios configured on the chain
%%
%% $Postcondition
%%  
%%
%% $End
%%
%% Review:
%%
%%
%% Revision history:
%%  2014-03-11, ejonuna
%%    First version
%%
%%------------------------------------------------------------------------------

dci_fct() ->
	[{userdata,[{wp, ""},
				{requirement, ""},
				{slogan, "State Starting - fault cease time difference"},
				{hwConfig, hwConfigA}]}].

dci_fct(_Config) ->
	ct:pal("dci_fct"),
	
	set_state_and_connect(starting_lmc_loaded),

	%% Subscribe Faults DCI
	ok = nci_dci_actions:subscribe_faults([]),

	%% Get the cascading radios, or the first radio
	Radios2plus = nci_ricm_utils:get_first_cascaded_radios(),
	if (Radios2plus == []) ->
		Radios = [nci_ricm_utils:get_first_radio()];
	true ->
		Radios = Radios2plus
	end,

	%% Setup cascading cpri and O&M link
	ok = setup_casc_cpri_link(Radios),

	lists:foreach(
		fun(RadioItem) ->
				
				restart_ru(RadioItem),
	
				ct:pal("Action_1 & Result1a & Result1b"),
				
				cascade_restart_ru_post_signals(RadioItem, Radios, true)
		end,
		Radios),

	reset_all_cpri_links(Radios),
    
	%% Check that NO BC/DC_FAULT_IND is generated
	nci_common_utils:check_outstanding_faults(2000).


	
%%------------------------------------------------------------------------------
%% $Id CASC_CARRIER_1
%%
%% $Header
%% State Starting
%%
%% $Description
%% Cascading test , Set up carrier using the cascaded RUs
%% 
%% $Requirements
%% CBD_RICM_DCI-IQ_FU:1:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Cascaded radios
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state starting.
%%  DP is loaded
%%  Subscribe faults for both BCI and DCI
%%  CPRI link and O&M link is started according to configuration
%%
%% $Action_1
%% Send a CARRIER_SETUP_REQ with parameters:(on the first radio on the cascading chain)
%%  ruId = 1, carrierId = 1, direction = UL, xioport = 0, no_of_samples = 2
%%
%% $Result_1
%% A CARRIER_SETUP_CFM is received with parameters:
%%  carrierId = 1
%% 
%% $Action_2
%% Send a CARRIER_SETUP_REQ with parameters:(on the first radio on the cascading chain)
%%  ruId = 1, carrierId = 2, direction = DL, xioport = 1(6 for dus), no_of_samples = 2
%%
%% $Result_2
%%  A CARRIER_SETUP_CFM is received with parameters:
%%  carrierId = 2
%% 
%% $Action_3
%%  Repeat Action_1 to Action_2 on the radio from second to the last:
%%
%% $Result_3
%%  Same result as Result_1 to Result_2 :Carrier can be setup successfully.
%%
%% $Postcondition
%%  Reset cpri link on all radios
%%
%% $End
%%
%% Review:
%%  2013-01-15, EJONUNA
%%
%% Revision history:
%%  2012-12-28, Eyanwzh
%%    First version
%%  2013-01-16, EYANWZH
%%    Update for review comments:Add a pre function and restructured the test case to use function .
%%------------------------------------------------------------------------------
casc_carrier_1() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_RICM_DCI-IQ_FU:1:C"},
				{slogan, "Cascading test , Set up carrier using the cascaded RUs"},
				{hwConfig, hwConfigB}]}].

casc_carrier_1(_Config) ->
	ct:pal("casc_carrier_1"),
	
	Radios = carrier_pre(),
	
	%%All actions in this test case has been implemented in above function carrier_pre.
	
	%% Reset CPRI Link
	[Radio|_] = Radios,  

	ok = nci_dci_actions:reset_cpri_link(Radio),

	ok = nci_dci_actions:reset_cpri_link_ind(Radio),

	%% Check that NO BC/DC_FAULT_IND is generated
	nci_common_utils:check_outstanding_faults(2000).
%%------------------------------------------------------------------------------	
carrier_pre() ->

	% Set state, make audit, establish BCI and DCI connections, subscribe faults
	set_state_and_connect( starting_lmc_loaded ),

	%% Subscribe Faults DCI
	ok = nci_dci_actions:subscribe_faults([]),
	
	%% Get the cascading radios
	Radios = nci_ricm_utils:get_first_cascaded_radios(),
	
	%% Setup cascading cpri and O&M link
	ok = setup_casc_cpri_link(Radios, radio_log_clear),
	
	%% Setup carrier 
	XioPortDL = case nci_common_utils:get_du() of
		dul -> 1;
		dus -> 6;
		mRBS_lte -> 6;
		_ -> 1
	end,

	ct:pal("Action_1,2,3"),
	NoOfSamples = 2,
	lists:foreach(fun(RadioItemValue) ->
		
		RuId = proplists:get_value(ruId,RadioItemValue),

		%% Add Carriers UL
		ok = nci_dci_actions:carrier_setup3(RadioItemValue ++ [
									{xioPort, 0},
									{direction, ?RICM_CARRIER_DIRECTION_UL},
									{carrierId, 2*RuId-2},
									{posA, (2*RuId-2) rem 30},
									{noOfSamples, NoOfSamples},
									{isSubBand, ?ELIB_CONST_HWU_YES}]),
		%% Add Carriers DL
		ok = nci_dci_actions:carrier_setup3(RadioItemValue ++ [
									{xioPort, XioPortDL},
									{direction, ?RICM_CARRIER_DIRECTION_DL},
									{carrierId, 2*RuId-1},
									{posA, (2*RuId-2) rem 30},
									{noOfSamples, NoOfSamples},
									{isSubBand, ?ELIB_CONST_HWU_YES}])
	end,
	Radios),	
	
	Radios.

%%------------------------------------------------------------------------------------
%% $Id CASC_CARRIER_2
%%
%% $Header
%% State Starting
%%
%% $Description
%% Cascading test , Set up carrier using the cascaded RUs
%% 
%% $Requirements
%% CBD_RICM_DCI-IQ_FU:1:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Cascaded radios
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state starting.
%%  DP is loaded
%%  Subscribe faults for both BCI and DCI
%%  CPRI link and O&M link is started according to configuration
%%
%% $Action_1
%% Send a CARRIER_SETUP_REQ with parameters:(on the first radio on the cascading chain)
%%  ruId = 1, carrierId = 1, direction = UL, xioport = 0, no_of_samples = 2
%%
%% $Result_1
%% A CARRIER_SETUP_CFM is received with parameters:
%%  carrierId = 1
%% 
%% $Action_2
%% Send a CARRIER_SETUP_REQ with parameters:(on the first radio on the cascading chain)
%%  ruId = 1, carrierId = 2, direction = DL, xioport = 1(6 for dus), no_of_samples = 2
%%
%% $Result_2
%%  A CARRIER_SETUP_CFM is received with parameters:
%%  carrierId = 2
%% 
%% $Action_3
%%  Repeat Action_1 to Action_2 on the radio from second to the last:
%%
%% $Result_3
%%  Same result as Result_1 to Result_2 :Carrier can be setup successfully.
%%
%%$Action_4
%% Send a CARRIER_RELEASE_REQ with parameters:(on the first radio on the cascading chain)
%%  carrierId = 1
%%
%% $Result_4
%% A CARRIER_RELEASE_CFM is received with parameters:
%%  carrierId = 1
%%
%% $Action_5
%%  Repeat Action_4 on the radio from second to the last:
%%
%% $Result_5
%%  Same result as Result_4 :Carrier can be release successfully.
%%
%% $Action_6
%%  Repeat Action_1 to Action_3 on the radio from the first to the last:
%%
%% $Result_6
%%  Same result as Result_1 to Result_3 :Carrier can be setup again successfully.
%%
%% $Postcondition
%%  Reset cpri link on all radios
%%
%% $End
%%
%% Review:
%%  2013-01-15, EJONUNA
%%
%% Revision history:
%%  2012-12-31, EWENYWU
%%    First version
%%  2013-01=16, EYANWZH
%%    Update for review comments:restructure the test case to use pre function .
%%------------------------------------------------------------------------------
casc_carrier_2() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_RICM_LTE-START-CASCADED-CPRI_FU:2:N, CBD_RICM_DCI-RESET-RADIO-CONTROL-LINK_FU:1:H"},
				{slogan, "Cascading test , Set up carrier using the cascaded RUs"},
				{hwConfig, hwConfigB}]}].
	
casc_carrier_2(_Config) ->
	ct:pal("casc_carrier_2"),
	
	Radios = carrier_pre(),
	
	ct:pal("Action_4,5"),
	%% Release carrier 
	lists:foreach(fun(RadioItemValue) ->
		
		RuId = proplists:get_value(ruId,RadioItemValue),				
		%% Release Carriers UL
		ok = nci_dci_actions:carrier_release([{carrierId, 2*RuId - 2}]),
		%% Release Carriers DL
		ok = nci_dci_actions:carrier_release([{carrierId, 2*RuId - 1}])
	end,
	Radios),
	
	ct:pal("Action_6"),
	%% Setup carrier again
	XioPortDL = case nci_common_utils:get_du() of
		dul -> 1;
		dus -> 6;
		mRBS_lte -> 6;
		_ -> 1
	end,
	NoOfSamples = 2,
	lists:foreach(fun(RadioItemValue) ->
		
		RuId = proplists:get_value(ruId,RadioItemValue),	
				
		%% Add Carriers UL
		ok = nci_dci_actions:carrier_setup3([{ruId, RuId},
									{xioPort, 0},
									{direction, ?RICM_CARRIER_DIRECTION_UL},
									{carrierId, 2*RuId - 2},
									{posA, (2*RuId - 2) rem 30},
									{noOfSamples, NoOfSamples},
									{isSubBand, ?ELIB_CONST_HWU_YES}]),
		%% Add Carriers DL
		ok = nci_dci_actions:carrier_setup3([{ruId, RuId},
									{xioPort, XioPortDL},
									{direction, ?RICM_CARRIER_DIRECTION_DL},
									{carrierId, 2*RuId - 1},
									{posA, (2*RuId - 2) rem 30},
									{noOfSamples, NoOfSamples},
									{isSubBand, ?ELIB_CONST_HWU_YES}])
	end,
	Radios),

	%% Reset CPRI Link
	[Radio|_] = Radios,  

	ok = nci_dci_actions:reset_cpri_link(Radio),

	ok = nci_dci_actions:reset_cpri_link_ind(Radio),

	%% Check that NO BC/DC_FAULT_IND is generated
	nci_common_utils:check_outstanding_faults(2000).	
%%------------------------------------------------------------------------------
%% $Id CASC_CARRIER_3
%%
%% $Header
%% Reset Radio Control link does not release the setup carriers.
%%
%% $Description
%% Cascading test, setup carrier using the cascaded RUs. Reset Radio Control link and carriers shall not be released
%% 
%% $Requirements
%% CBD_RICM_DCI-IQ_FU:1:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Cascaded radios
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state starting.
%%  DP is loaded
%%  Subscribe faults for both BCI and DCI
%%  CPRI link and O&M link is started according to configuration
%%
%% $Action_1
%% Send a CARRIER_SETUP_REQ with parameters:(on the first radio on the cascading chain)
%%  ruId = 1, carrierId = 1, direction = UL, xioport = 0, no_of_samples = 2
%%
%% $Result_1
%% A CARRIER_SETUP_CFM is received with parameters:
%%  carrierId = 1
%% 
%% $Action_2
%% Send a CARRIER_SETUP_REQ with parameters:(on the first radio on the cascading chain)
%%  ruId = 1, carrierId = 2, direction = DL, xioport = 1(6 for dus), no_of_samples = 2
%%
%% $Result_2
%%  A CARRIER_SETUP_CFM is received with parameters:
%%  carrierId = 2
%% 
%% $Action_3
%%  Repeat Action_1 to Action_2 on the radio from second to the last:
%%
%% $Result_3
%%  Same result as Result_1 to Result_2 :Carrier can be setup successfully.
%%
%% $Action_4
%% Reset radio control from the last radio to the first radio
%%
%% $Result_4
%% Radio control on all the radios are reset .
%%
%% $Action_5
%% Setup carrier as Action_1 and Action_2
%%
%% $Result_5
%% carrier setup was reject with error : carrierId already in use 
%%
%% $Action_6
%% Repeat Action_5 for the radio on the following chain
%% 
%% $Result_6
%% Same result as Result_5.
%%
%% $Postcondition
%%  Reset cpri link on all radios
%%
%% $End
%%
%% Review:
%%  2013-01-15, EJONUNA
%%
%% Revision history:
%%  2012-12-31, Eyanwzh
%%    First version
%% 2013-01-16, EYANWZH
%%    Update for review comments:restructure the test case to use pre function .
%%------------------------------------------------------------------------------
casc_carrier_3() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_RICM_DCI-IQ_FU:1:C"},
				{slogan, "Cascading test, setup carrier using the cascaded RUs. Reset Radio Control link and carriers shall not be released"},
				{hwConfig, hwConfigB}]}].

casc_carrier_3(_Config) ->

	ct:pal("casc_carrier_3"),
	
	Radios = carrier_pre(),
	
	ct:pal("Action_4"),
	%%Reverse the radios
	Radiosrev = lists:reverse(Radios),

	%%Reset radio control from last radio to the first.
	casc_reset_radio_reverse(Radiosrev,[]),

	ct:pal("Action_5,6"),
	%%Setup carrier again.
	XioPortDL = case nci_common_utils:get_du() of
		dul -> 1;
		dus -> 6;
		mRBS_lte -> 6;
		_ -> 1
	end,
	NoOfSamples = 2,
	lists:foreach(fun(RadioItemValue) ->
		
		RuId = proplists:get_value(ruId,RadioItemValue),

		%% Add Carriers UL
		ok = nci_dci_actions:carrier_setup3(RadioItemValue ++ [
									{xioPort, 0},
									{direction, ?RICM_CARRIER_DIRECTION_UL},
									{carrierId, 2*RuId-2},
									{posA, (2*RuId-2) rem 30},
									{noOfSamples, NoOfSamples},
									{isSubBand, ?ELIB_CONST_HWU_YES},
									{expectedSigNo, ?RICM_CARRIER_SETUP_REJ},
									{errorCode, 1},
									{errorDescription, {regexp, "carrierId already in use*"}}]),
		%% Add Carriers DL
		ok = nci_dci_actions:carrier_setup3(RadioItemValue ++ [
									{xioPort, XioPortDL},
									{direction, ?RICM_CARRIER_DIRECTION_DL},
									{carrierId, 2*RuId-1},
									{posA, (2*RuId-2) rem 30},
									{noOfSamples, NoOfSamples},
									{isSubBand, ?ELIB_CONST_HWU_YES},
									{expectedSigNo, ?RICM_CARRIER_SETUP_REJ},
									{errorCode, 1},
									{errorDescription, {regexp, "carrierId already in use*"}}])
	end,
	Radios),
	
	%% Reset CPRI Link
	[Radio|_] = Radios,  

	ok = nci_dci_actions:reset_cpri_link(Radio),

	ok = nci_dci_actions:reset_cpri_link_ind(Radio),

	%% Check that NO BC/DC_FAULT_IND is generated
	nci_common_utils:check_outstanding_faults(2000).    
%%------------------------------------------------------------------------------
casc_reset_radio_reverse([],_Lastradios) ->
	ok;
	
casc_reset_radio_reverse([Radios1|Restradios],Lastradios) ->
	nci_ricm_utils:workaround_HS24704(),
	
	%% Reset Radio Control
	ok = nci_dci_actions:reset_radio_control(Radios1),	
		
	lists:foreach(fun(RadioItemValue) ->
	
		ok = nci_dci_actions:radio_reset_control_ind(RadioItemValue),
		
		RuLnhPath = proplists:get_value(ruLnhPath,RadioItemValue),
				
		nci_common_utils:coli_cmd("lhsh " ++ RuLnhPath ++ " lmclist", "failed to connect to")		

	end,
	Lastradios),	

	lists:foreach(fun(RadioItemValue) ->
	
						  ok = nci_dci_actions:cpri_link_ind(RadioItemValue ++[{availStatus, 0}])
		
	end,
	[Radios1|Lastradios]),	
	
	FaultId1 = nci_dci_actions:fault_ind([{oseGwDeamon,?OSE_GW_DEAMON_1},
										  {faultId, ?ELIB_CONST_FH_FAULT_ID_LF_STABILITY},
										  {faultDescription, {regexp, "Temporary not in operation*"}}]), 
	
	ok = nci_dci_actions:fault_cease_ind([{faultId, FaultId1}]), 

	FaultId2 = nci_dci_actions:fault_ind([{oseGwDeamon,?OSE_GW_DEAMON_1},
										  {faultId, ?ELIB_CONST_FH_FAULT_ID_LINK_FAILURE},
										  {faultDescription, {regexp, "Not in operation*"}}]),  
	
	ok = nci_dci_actions:cpri_link_ind(Radios1 ++ [{availStatus, 1}]),
	
	ok = nci_dci_actions:fault_cease_ind([{faultId, FaultId2}]),

	casc_reset_radio_reverse(Restradios,[Radios1|Lastradios]).

%%--------------------------------------------------------------------------------
%% $Id CASC_CARRIER_4
%%
%% $Header
%% Carrier can not be setup after reset cpri link.
%%
%% $Description
%% Cascading test, setup carrier using the cascaded RUs. Reset cpri link and then can not setup carriers again.
%% $Requirements
%% CBD_RICM_DCI-IQ_FU:1:C
%%
%% $External References 
%%  - 
%%
%% $HW Config
%%  Cascaded radios
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state starting.
%%  DP is loaded
%%  Subscribe faults for both BCI and DCI
%%  CPRI link and O&M link is started according to configuration
%%
%% $Action_1
%% Send a CARRIER_SETUP_REQ with parameters:(on the first radio on the cascading chain)
%%  ruId = 1, carrierId = 1, direction = UL, xioport = 0, no_of_samples = 2
%%
%% $Result_1
%% A CARRIER_SETUP_CFM is received with parameters:
%%  carrierId = 1
%% 
%% $Action_2
%% Send a CARRIER_SETUP_REQ with parameters:(on the first radio on the cascading chain)
%%  ruId = 1, carrierId = 2, direction = DL, xioport = 1(6 for dus), no_of_samples = 2
%%
%% $Result_2
%%  A CARRIER_SETUP_CFM is received with parameters:
%%  carrierId = 2
%% 
%% $Action_3
%%  Repeat Action_1 to Action_2 on the radio from second to the last:
%%
%% $Result_3
%%  Same result as Result_1 to Result_2 :Carrier can be setup successfully.
%%
%% $Action_4
%% Reset cpri link  from the last radio to the first radio
%%
%% $Result_4
%% Cpri link on all the radios are reset .
%%
%% $Action_5
%% Setup carrier as Action_1 and Action_2
%%
%% $Result_5
%% carrier setup was reject with error : ruId not in use 
%%
%% $Action_6
%% Repeat Action_5 for the radio on the following chain
%% 
%% $Result_6
%% Same result as Result_5.
%%
%% $Postcondition
%%  
%% $End
%%
%% Review:
%%  2013-01-15, EJONUNA
%%
%% Revision history:
%%  2013-01-04, Eyanwzh
%%    First version
%%  2013-01-16, EYANWZH
%%    Update for review comments:restructure the test case to use pre function.
%%  2013-07-01, EWENYWU
%%    Update for mRBS regression: update the parameter of RADIO from huntPathRu to ruLnhPath.
%%------------------------------------------------------------------------------
casc_carrier_4() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_RICM_DCI-IQ_FU:1:C"},
				{slogan, "Cascading test, setup carrier using the cascaded RUs. Reset cpri link and then can not setup carriers again."},
				{hwConfig, hwConfigB}]}].

casc_carrier_4(_Config) ->
	ct:pal("casc_carrier_4"),
	
	Radios = carrier_pre(),
	
	ct:pal("Action_4"),  
	%%Reverse the radios
	Radiosrev = lists:reverse(Radios),
	
	%%Reset cpri link from last radio to the first.
	lists:foreach(fun(RadioItemValue) ->
		
		ok = nci_dci_actions:reset_cpri_link(RadioItemValue),

		ok = nci_dci_actions:reset_cpri_link_ind(RadioItemValue),
		
		RuLnhPath = proplists:get_value(ruLnhPath, RadioItemValue),

		nci_common_utils:coli_cmd("lhsh " ++ RuLnhPath ++ " lmclist", "failed to connect to")
	end,
	Radiosrev),

	ct:pal("Action_5,6"),
	%%Setup carrier again.
	XioPortDL = case nci_common_utils:get_du() of
		dul -> 1;
		dus -> 6;
		mRBS_lte -> 6;
		_ -> 1
	end,
	NoOfSamples = 2,
	ErrorDesc = nci_common_utils:convert_string_to_list("ruId not in use", ?ELIB_CONST_HWU_MAX_ERROR_DESCRIPTION_STRINGLENGTH),	
	lists:foreach(fun(RadioItemValue) ->
		
		RuId = proplists:get_value(ruId,RadioItemValue),

		%% Add Carriers UL
		ok = nci_dci_actions:carrier_setup3(RadioItemValue ++ [
									{xioPort, 0},
									{direction, ?RICM_CARRIER_DIRECTION_UL},
									{carrierId, 2*RuId-2},
									{posA, (2*RuId-2) rem 30},
									{noOfSamples, NoOfSamples},
									{isSubBand, ?ELIB_CONST_HWU_YES},
									{expectedSigNo, ?RICM_CARRIER_SETUP_REJ},
									{errorCode, 1},
									{errorDescription, ErrorDesc}]),
		%% Add Carriers DL
		ok = nci_dci_actions:carrier_setup3(RadioItemValue ++ [
									{xioPort, XioPortDL},
									{direction, ?RICM_CARRIER_DIRECTION_DL},
									{carrierId, 2*RuId-1},
									{posA, (2*RuId-2) rem 30},
									{noOfSamples, NoOfSamples},
									{isSubBand, ?ELIB_CONST_HWU_YES},
									{expectedSigNo, ?RICM_CARRIER_SETUP_REJ},
									{errorCode, 1},
									{errorDescription, ErrorDesc}])
	end,
	Radios),
	
	%% Check that NO BC/DC_FAULT_IND is generated     
	nci_common_utils:check_outstanding_faults(2000).


%%oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
%% $ChapterH1 Appendix
%% 
%% $End
%%oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo

%%##############################################################################
%% $ChapterH2 Carrier Setup
%%
%%
%% $End
%%##############################################################################

%%------------------------------------------------------------------------------
%% $Id max_carrier_setup
%%
%% $Header
%%  Max Carrier Setup
%%
%% $Description
%%  Purpose Allocates all slots.
%%
%% $Action
%%  Send a CARRIER_SETUP_REQ with parameters:
%%
%%  carrierId = 0, direction = UL, bandwidth = 20 MHz, bbModule = 0
%%
%% $Result CARRIER_SETUP_CFM is received with parameters:
%%
%%  carrierId = 0
%%
%% $Action
%%  Send a CARRIER_SETUP_REQ with parameters:
%%
%%  carrierId = 1, direction = DL, bandwidth = 10 MHz, bbModule = 0
%%
%% $Result
%%  A CARRIER_SETUP_CFM is received with parameters:
%%
%%  carrierId = 1
%%
%% $Action
%%  Send a CARRIER_SETUP_REQ with parameters:
%%
%%  carrierId = 2, direction = UL, bandwidth = 3 MHz, bbModule = 0
%%
%% $Result 3 CARRIER_SETUP_CFM is received with parameters:
%%
%%  carrierId = 2
%%
%% $Action
%%  Send a CARRIER_SETUP_REQ with parameters:
%%
%%  carrierId = 3, direction = DL, bandwidth = 1.4 MHz, bbModule = 0
%%
%% $Result 4 A CARRIER_SETUP_CFM is received with parameters:
%%
%%  carrierId = 3
%%
%% $Action
%%  Send a CARRIER_SETUP_REQ with parameters:
%%
%%  carrierId = 4, direction = UL, bandwidth = 15 MHz, bbModule = 0
%%
%% $Result
%%  A CARRIER_SETUP_CFM is received with parameters:
%%
%%  carrierId = 4
%%
%% $Action
%%  Send a CARRIER_SETUP_REQ with parameters:
%%
%%  carrierId = 5, direction = DL, bandwidth = 10 MHz, bbModule = 0
%%
%% $Result
%%  A CARRIER_SETUP_CFM is received with parameters:
%%
%%  carrierId = 5
%% 
%% $Action
%%  Send a CARRIER_SETUP_REQ with parameters:
%%
%%  carrierId = 6, direction = UL, bandwidth = 3.2 MHz, bbModule = 0
%%
%% $Result
%%  A CARRIER_SETUP_CFM is received with parameters:
%%
%%  carrierId = 6
%%
%% $Action
%%  Send a CARRIER_SETUP_REQ with parameters:
%%
%%  carrierId = 7, direction = DL, bandwidth = 1.6 MHz, bbModule = 0
%%
%% $Result
%%  A CARRIER_SETUP_CFM is received with parameters:
%%
%%  carrierId = 7
%%
%% $Action
%%  Send a CARRIER_SETUP_REQ with parameters:
%%
%%  carrierId = 8, direction = UL, bandwidth = 5 MHz, bbModule = 0
%%
%% $Result
%%  A CARRIER_SETUP_CFM is received with parameters:
%%
%%  carrierId = 8
%%
%% $Action
%%  Send a CARRIER_SETUP_REQ with parameters:
%%
%%  carrierId = 9, direction = DL, bandwidth = 15 MHz, bbModule = 0
%%
%% $Result
%%  A CARRIER_SETUP_CFM is received with parameters:
%%
%%  carrierId = 9
%%
%% $Action
%%  Send a CARRIER_SETUP_REQ with parameters:
%%
%%  carrierId = 10, direction = UL, bandwidth = 15 MHz, bbModule = 0
%%
%% $Result
%%  A CARRIER_SETUP_CFM is received with parameters:
%%
%%  carrierId = 10
%%
%% $Action
%%  Send a CARRIER_SETUP_REQ with parameters:
%%
%%  carrierId = 11, direction = DL, bandwidth = 5 MHz, bbModule = 0
%%
%% $Result
%%  A CARRIER_SETUP_CFM is received with parameters:
%%
%%  carrierId = 11
%%
%% $Action
%%  Send a CARRIER_SETUP_REQ with parameters:
%%
%%  carrierId = 12, direction = UL, bandwidth = 3 MHz, bbModule = 0
%%
%% $Result
%%  A CARRIER_SETUP_CFM is received with parameters:
%%
%%  carrierId = 12
%%
%% $Action
%%  Send a CARRIER_SETUP_REQ with parameters:
%%
%%  carrierId = 13, direction = DL, bandwidth = 1.6 MHz, bbModule = 0
%%
%% $Result
%%  A CARRIER_SETUP_CFM is received with parameters:
%%
%%  carrierId = 13
%%
%% $Action
%%  Send a CARRIER_SETUP_REQ with parameters:
%%
%%  carrierId = 14, direction = UL, bandwidth = 1.6 MHz, bbModule = 0
%%
%% $Result
%%  A CARRIER_SETUP_CFM is received with parameters:
%%
%%  carrierId = 14
%%
%% $Action
%%  Send a CARRIER_SETUP_REQ with parameters:
%%
%%  carrierId = 15, direction = DL, bandwidth = 20 MHz, bbModule = 0
%%
%% $Result
%%  A CARRIER_SETUP_CFM is received with parameters:
%%
%%  CarrierId = 15
%%
%% $Action
%%  Send a CARRIER_SETUP_REQ with parameters:
%%
%%  carrierId = 16, direction = UL, bandwidth = 10 MHz, bbModule = 0
%%
%% $Result
%%  A CARRIER_SETUP_CFM is received with parameters:
%%
%%  carrierId = 16
%%
%% $Action
%%  Send a CARRIER_SETUP_REQ with parameters:
%%
%%  carrierId = 17, direction = DL, bandwidth = 3 MHz, bbModule = 0
%%
%% $Result
%%  A CARRIER_SETUP_CFM is received with parameters:
%%
%%  carrierId = 17
%%
%% $Action
%%  Send a CARRIER_SETUP_REQ with parameters:
%%
%%  carrierId = 18, direction = UL, bandwidth = 15 MHz, bbModule = 0
%%
%% $Result
%%  A CARRIER_SETUP_CFM is received with parameters:
%%
%%  carrierId = 18
%%
%% $Action
%%  Send a CARRIER_SETUP_REQ with parameters:
%%
%%  carrierId = 19, direction = DL, bandwidth = 15 MHz, bbModule = 0
%%
%% $Result
%%  A CARRIER_SETUP_CFM is received with parameters:
%%
%%  carrierId = 19
%%
%% $Action
%%  Send a CARRIER_SETUP_REQ with parameters:
%%
%%  carrierId = 20, direction = UL, bandwidth = 10 MHz, bbModule = 0
%%
%% $Result
%%  A CARRIER_SETUP_CFM is received with parameters:
%%
%%  carrierId = 20
%%
%% $Action
%%  Send a CARRIER_SETUP_REQ with parameters:
%%
%%  carrierId = 21, direction = DL, bandwidth = 20 MHz, bbModule = 0
%%
%% $Result
%%  A CARRIER_SETUP_CFM is received with parameters:
%%
%%  carrierId = 21
%%
%% $Action
%%  Send a CARRIER_SETUP_REQ with parameters:
%%
%%  carrierId = 22, direction = UL, bandwidth = 1.6 MHz, bbModule = 0
%%
%% $Result
%%  A CARRIER_SETUP_CFM is received with parameters:
%%
%%  carrierId = 22
%%
%% $Action
%%  Send a CARRIER_SETUP_REQ with parameters:
%%
%%  carrierId = 23, direction = DL, bandwidth = 5 MHz, bbModule = 0
%%
%% $Result
%%  A CARRIER_SETUP_CFM is received with parameters:
%%
%%  carrierId = 23
%%
%% $Action
%%  Send a CARRIER_SETUP_REQ with parameters:
%%
%%  carrierId = 24, direction = UL, bandwidth = 1.6 MHz, bbModule = 0
%%
%% $Result
%%  A CARRIER_SETUP_CFM is received with parameters:
%%
%%  carrierId = 24
%%
%% $Action
%%  Send a CARRIER_SETUP_REQ with parameters:
%%
%%  carrierId = 25, direction = DL, bandwidth = 1.6 MHz, bbModule = 0
%%
%% $Result
%%  A CARRIER_SETUP_CFM is received with parameters:
%%
%%  carrierId = 25
%%
%% $Action
%%  Send a CARRIER_SETUP_REQ with parameters:
%%
%%  carrierId = 26, direction = UL, bandwidth = 1.4 MHz, bbModule = 0
%%
%% $Result
%%  A CARRIER_SETUP_CFM is received with parameters:
%%
%%  carrierId = 26
%%
%% $Action
%%  Send a CARRIER_SETUP_REQ with parameters:
%%
%%  carrierId = 27, direction = DL, bandwidth = 1.6 MHz, bbModule = 0
%%
%% $Result
%%  A CARRIER_SETUP_CFM is received with parameters:
%%
%%  carrierId = 27
%%
%% $Action
%%  Send a CARRIER_SETUP_REQ with parameters:
%%
%%  carrierId = 28, direction = UL, bandwidth = 1.6 MHz, bbModule = 0
%%
%% $Result
%%  A CARRIER_SETUP_CFM is received with parameters:
%%
%%  carrierId = 28
%%
%% $Action
%%  Send a CARRIER_SETUP_REQ with parameters:
%%
%%  carrierId = 29, direction = DL, bandwidth = 1.6 MHz, bbModule = 0
%%
%% $Result
%%  A CARRIER_SETUP_CFM is received with parameters:
%%
%%  carrierId = 29
%%
%% $Action
%%  Send a CARRIER_SETUP_REQ with parameters:
%%
%%  carrierId = 30, direction = DL, bandwidth = 1.6 MHz, bbModule = 0
%%
%% $Result 
%%  A CARRIER_SETUP_CFM is received with parameters:
%%
%%  carrierId = 30
%%
%% $End
%%##############################################################################




%%------------------------------------------------------------------------------
%% $Id RICM_ZUC
%%
%% $Header
%%  Zuc enabled 
%%
%% $Description
%%   Verifies that zuc have been loaded 
%%
%% $Requirements
%%  N/A
%%  
%%
%% $HW config
%%  DUS41
%%
%% $Priority
%%  -
%%
%% $Type
%%  daily, regression
%%
%% $History
%%  -
%%
%% $Precondition
%%  The DU BC is in state starting
%%
%% $Action_1
%%  Read xio_if_2 XIO_TYPE_D_STATUS bank 0 register in the DUXI ACC with shell command "rdfpga 0x105008" (Actual address 0xF0305008)
%%
%% $Result_1
%%  bit 30:31 link_state must be 0x1 (LINK EN state) 
%%
%% $Action_2
%%  Read xio_if_6 XIO_TYPE_D_STATUS bank 1 register in the DUXI ACC with shell command "rdfpga 0x105108" (Actual address 0xF0305108)
%%
%% $Result_2
%%  bit 30:31 link_state must be 0x1 (LINK EN state)
%% 
%% $Action_3
%%  Read TRX_XI2_STATUS register in the DUXI ACC with shell command "rdfpga 0x1005a4" (Actual address 0xF03005a4)
%%
%% $Result_3
%%  bit 20:23 trx_configured must be 1 (Default config, XIO normal operation) and bit 29 tx_ready must be 1 (configured, released and ready for usage)
%%
%% $Action_4
%%  Read TRX_XI6_STATUS register in the DUXI ACC with shell command "rdfpga 0x1005e4" (Actual address 0xF03005e4)
%%
%% $Result_4
%%  bit 20:23 trx_configured must be 1 (Default config, XIO normal operation) and bit 29 tx_ready must be 1 (configured, released and ready for usage)
%% 
%%  -
%%
%% $End
%%
%% Review:
%% -
%%
%% Revision history:
%%   2012-11-21 EJONUNA
%%     First version
%%
%%------------------------------------------------------------------------------


ricm_zuc() ->
	[{userdata,[{wp, ""}, 
			{requirement, ""},
			{slogan, ""}]}].

ricm_zuc(_Config) ->

	{ok, session_up} = coli:subscribe_state(?SHELL_COMMAND),
	{ok, session_up} = osegw:subscribe_state(?OSE_GW_DEAMON_1),

	nci_bci_states:set_state([{state, starting_lmc_loaded}]),

	16#01 = nci_common_utils:rdfpga(16#105008) band 16#03, %LINK EN state
	
	16#01 = nci_common_utils:rdfpga(16#105108) band 16#03, %LINK EN state

	TRX_XI2_STATUS = nci_common_utils:rdfpga(16#1005a4),
	
	16#04 = TRX_XI2_STATUS band 16#04,%%tx_ready
	16#0100 = TRX_XI2_STATUS band 16#0F00, %%trx_configured: Default config XIO normal operation

	TRX_XI6_STATUS = nci_common_utils:rdfpga(16#1005e4),
	
	16#04 = TRX_XI6_STATUS band 16#04,%%tx_ready
	16#0100 = TRX_XI6_STATUS band 16#0F00, %%trx_configured: Default config XIO normal operation

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%-----------------------------------------------------------------------------
%%
%%  MULTILINK CPRI
%%
%%-----------------------------------------------------------------------------

%%------------------------------------------------------------------------------
%% $Id DCI_SASR1
%%
%% $Header
%%  Multilink CPRI - Subscribe AxC slot range - State starting
%%
%% $Description
%%  Starts CPRI link with multilink CPRI request then subscribe to AxC slot
%%  range in state starting
%%
%% $Requirements
%%  TBD
%%
%% $HW config
%%  At least one radio
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  The DU BC is in state starting
%%  DP LMC is loaded
%%  DCI connection establish performed
%%
%% $Action_1
%%  Send a RICM_START_CPRI_LINK3_REQ, with parameters:
%%  * masterUnitId
%%  * masterUnitPort
%%  * assignLinkId
%%  * assignSlaveUnitId
%%
%% $Result_1
%%  A RICM_START_CPRI_LINK3_CFM is received
%%
%% $Result_1a
%%  A RICM_START_CPRI_LINK3_IND is received with correct
%%  * linkId
%%  * linkSpeed
%%
%% $Action_2
%%  Send a RICM_SUBSCRIBE_AXC_SLOT_RANGE_REQ, with parameter:
%%  * linkId
%%
%% $Result_2
%%  A RICM_SUBSCRIBE_AXC_SLOT_RANGE_CFM is received with correct
%%  * linkId
%%
%% $Result_2a
%%  A RICM_AXC_SLOT_RANGE_IND is received with correct
%%  * linkId
%%  * slots
%%
%% $Action_3
%%  Repeat Action_1 and Action_2 for all radios
%%
%% $Result_3
%%  Result_1, 1a, 2, 2a
%%
%% $Action_4
%%  Stop CPRI link by sending RICM_STOP_CPRI_LINK_REQ
%%
%% $Result_4
%%  A RICM_STOP_CPRI_LINK_CFM is received
%%
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Revision history:
%%  2014-05-27, QSATDHA
%%    First version
%%
%%------------------------------------------------------------------------------
dci_sasr1() ->
	[{userdata,[{wp, ""},
				{requirement, "TBD"},
				{slogan, "Multilink CPRI - Subscribe AxC slot range - State starting"}]}].

dci_sasr1(_Config) ->
	ct:pal("dci_sasr1"),
	dci_sasr( starting_lmc_loaded ).

%%------------------------------------------------------------------------------
%% $Id DCI_SASR2
%%
%% $Header
%%  Multilink CPRI - Subscribe AxC slot range - State operational
%%
%% $Description
%%  Starts CPRI link with multilink CPRI request then subscribe to AxC slot
%%  range in state operational
%%
%% $Requirements
%%  TBD
%%
%% $HW config
%%  At least one radio
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  The DU BC is in state operational
%%  DP LMC is loaded
%%  DCI connection establish performed
%%
%% $Action_1
%%  Send a RICM_START_CPRI_LINK3_REQ, with parameters:
%%  * masterUnitId
%%  * masterUnitPort
%%  * assignLinkId
%%  * assignSlaveUnitId
%%
%% $Result_1
%%  A RICM_START_CPRI_LINK3_CFM is received
%%
%% $Result_1a
%%  A RICM_START_CPRI_LINK3_IND is received with correct
%%  * linkId
%%  * linkSpeed
%%
%% $Action_2
%%  Send a RICM_SUBSCRIBE_AXC_SLOT_RANGE_REQ, with parameter:
%%  * linkId
%%
%% $Result_2
%%  A RICM_SUBSCRIBE_AXC_SLOT_RANGE_CFM is received with correct
%%  * linkId
%%
%% $Result_2a
%%  A RICM_AXC_SLOT_RANGE_IND is received with correct
%%  * linkId
%%  * slots
%%
%% $Action_3
%%  Repeat Action_1 and Action_2 for all radios
%%
%% $Result_3
%%  Result_1, 1a, 2, 2a
%%
%% $Action_4
%%  Stop CPRI link by sending RICM_STOP_CPRI_LINK_REQ
%%
%% $Result_4
%%  A RICM_STOP_CPRI_LINK_CFM is received
%%
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Revision history:
%%  2014-05-27, QSATDHA
%%    First version
%%
%%------------------------------------------------------------------------------
dci_sasr2() ->
	[{userdata,[{wp, ""},
				{requirement, "TBD"},
				{slogan, "Multilink CPRI - Subscribe AxC slot range - State operational"}]}].

dci_sasr2(_Config) ->
	ct:pal("dci_sasr2"),
	dci_sasr( operational ).

dci_sasr(State) ->

	%% Set state, make audit, establish BCI and DCI connections, subscribe faults
	set_state_and_connect( State ),

	%% Subscribe Faults DCI
	ok = nci_dci_actions:subscribe_faults([]),

	Radios = nci_ricm_utils:get_all_radios(),

	%% Setup CPRI links and subscribe to AxC slot range
	subscribe_axc_slot_range(Radios),

	%% Reset CPRI Link
	stop_cpri_links(Radios),

	%% Check for unexpected signals
	nci_common_utils:check_outstanding_faults().

%%------------------------------------------------------------------------------
%% $Id DCI_SASR3
%%
%% $Header
%%  Multilink CPRI - Subscribe AxC slot range - State disabled
%%
%% $Description
%%  Starts CPRI link with multilink CPRI request then subscribe to AxC slot
%%  range in state disabled
%%
%% $Requirements
%%  TBD
%%
%% $HW config
%%  At least one radio
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  The DU BC is in state disabled
%%  DP LMC is loaded
%%  DCI connection establish performed
%%
%% $Action_1
%%  Send a RICM_SUBSCRIBE_AXC_SLOT_RANGE_REQ, with parameters:
%%  * linkId = 1
%%
%% $Result_1
%%  A RICM_SUBSCRIBE_AXC_SLOT_RANGE_REJ is received with:
%%  * errorCode = ?ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL
%%	* errorDescription = "Invalid O&M state"
%%
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Revision history:
%%  2014-05-27, QSATDHA
%%    First version
%%
%%------------------------------------------------------------------------------
dci_sasr3() ->
	[{userdata,[{wp, ""},
				{requirement, "TBD"},
				{slogan, "Multilink CPRI - Subscribe AxC slot range - State disabled"}]}].

dci_sasr3(_Config) ->
	ct:pal("dci_sasr3"),

	%% Set state, make audit, establish BCI and DCI connections, subscribe faults
	set_state_and_connect( starting_lmc_loaded ),
	set_state_and_connect( disabled ),

	%% Subscribe Faults DCI
	ok = nci_dci_actions:subscribe_faults([]),

	%% Subscribe to AxC slot range
	nci_dci_actions:subscribe_axc_slot_range([{linkId, 1},
											  {expectedSigNo, ?RICM_SUBSCRIBE_AXC_SLOT_RANGE_REJ},
											  {errorCode, ?ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL},
											  {errorDescription, {regexp, "Invalid O&M state*"}}]),


	%% Check for unexpected signals
	nci_common_utils:check_outstanding_faults().

%%------------------------------------------------------------------------------
%% $Id DCI_SASR4
%%
%% $Header
%%  Multilink CPRI - Subscribe AxC slot range - State DP not loaded
%%
%% $Description
%%  Starts CPRI link with multilink CPRI request then subscribe to AxC slot
%%  range in state DP not loaded
%%
%% $Requirements
%%  TBD
%%
%% $HW config
%%  At least one radio
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  The DU BC is in state DP not loaded
%%  DP LMC is loaded
%%  DCI connection establish performed
%%
%% $Action_1
%%  Send a RICM_SUBSCRIBE_AXC_SLOT_RANGE_REQ, with parameters:
%%  * linkId = 1
%%
%% $Result_1
%%  A RICM_SUBSCRIBE_AXC_SLOT_RANGE_REJ is received with:
%%  * errorCode = ?ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL
%%  * errorDescription = "DP not loaded"
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Revision history:
%%  2014-05-27, QSATDHA
%%    First version
%%
%%------------------------------------------------------------------------------
dci_sasr4() ->
	[{userdata,[{wp, ""},
				{requirement, "TBD"},
				{slogan, "Multilink CPRI - Subscribe AxC slot range - State DP not loaded"}]}].

dci_sasr4(_Config) ->
	ct:pal("dci_sasr4"),

	%% Set state, make audit, establish BCI and DCI connections, subscribe faults
	set_state_and_connect( starting_lmc_not_loaded ),

	%% Subscribe Faults DCI
	ok = nci_dci_actions:subscribe_faults([]),

	%% Subscribe to AxC slot range
	nci_dci_actions:subscribe_axc_slot_range([{linkId, 1},
											  {expectedSigNo, ?RICM_SUBSCRIBE_AXC_SLOT_RANGE_REJ},
											  {errorCode, ?ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL},
											  {errorDescription, {regexp, "DP not loaded*"}}]),


	%% Check for unexpected signals
	nci_common_utils:check_outstanding_faults().

%%------------------------------------------------------------------------------
%% $Id DCI_SASR5
%%
%% $Header
%%  Multilink CPRI - Subscribe AxC slot range - Invalid linkId
%%
%% $Description
%%  Starts CPRI link with multilink CPRI request then subscribe to AxC slot
%%  range with invalid linkId (state starting)
%%
%% $Requirements
%%  TBD
%%
%% $HW config
%%  At least one radio
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  The DU BC is in state starting
%%  DP LMC is loaded
%%  DCI connection establish performed
%%
%%
%% $Action_1
%%  Send a RICM_SUBSCRIBE_AXC_SLOT_RANGE_REQ, with parameter:
%%  * linkId = 0
%%
%% $Result_1
%%  A RICM_SUBSCRIBE_AXC_SLOT_RANGE_REJ is received with
%%  * errorCode        = ?ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL
%%  * errorDescription = Invalid linkId
%%
%% $Action_2
%%  Send a RICM_SUBSCRIBE_AXC_SLOT_RANGE_REQ, with parameter:
%%  * linkId = 255
%%
%% $Result_2
%%  A RICM_SUBSCRIBE_AXC_SLOT_RANGE_REJ is received with
%%  * errorCode        = ?ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL
%%  * errorDescription = linkId not in use
%%
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Revision history:
%%  2014-05-27, QSATDHA
%%    First version
%%
%%------------------------------------------------------------------------------
dci_sasr5() ->
	[{userdata,[{wp, ""},
				{requirement, "TBD"},
				{slogan, "Multilink CPRI - Subscribe AxC slot range - Invalid linkId"}]}].

dci_sasr5(_Config) ->
	ct:pal("dci_sasr5"),

	%% Set state, make audit, establish BCI and DCI connections, subscribe faults
	set_state_and_connect( starting_lmc_loaded ),

	%% Subscribe Faults DCI
	ok = nci_dci_actions:subscribe_faults([]),

	%% Subscribe AxC slot range with LinkId outside 1-0xFFFF range
	LinkId1 = 0,
	nci_dci_actions:subscribe_axc_slot_range([{linkId, LinkId1},
											  {expectedSigNo, ?RICM_SUBSCRIBE_AXC_SLOT_RANGE_REJ},
											  {errorCode, ?ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL},
											  {errorDescription, {regexp, "Invalid linkId*"}}]),

	%% Subscribe AxC slot range with LinkId within 1-0xFFFF range for a link which is not started
	LinkId2 = 255,
	nci_dci_actions:subscribe_axc_slot_range([{linkId, LinkId2},
											  {expectedSigNo, ?RICM_SUBSCRIBE_AXC_SLOT_RANGE_REJ},
											  {errorCode, ?ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL},
											  {errorDescription, {regexp, "linkId not in use*"}}]),

	%% Check for unexpected signals
	nci_common_utils:check_outstanding_faults().


subscribe_axc_slot_range(Radios) ->

	ct:pal("subscribe_axc_slot_range()"),

	start_cpri_and_oam_links(Radios),

	lists:foreach(
		fun(Radio) ->
				%% Subscribe AxC slot range
				nci_dci_actions:subscribe_axc_slot_range(Radio),

				LinkSpeed = proplists:get_value(ruSpeed, Radio),

				Slots = case LinkSpeed of
							'2.5G' ->
								[0,0,0,0,0,0,0,0,0,0,0,0,0,0,16#ff,16#ff];
							'5G' ->
								[0,0,0,0,0,0,0,0,0,0,0,0,16#ff,16#ff,16#ff,16#ff];
							'10G' ->
								[0,0,0,0,0,0,0,0,16#ff,16#ff,16#ff,16#ff,16#ff,16#ff,16#ff,16#ff];
							_ ->
								ct:fail("Unsupported link speed")
						end,

				nci_dci_actions:axc_slot_range_ind(Radio ++ [{slots, Slots}])
		end,
		Radios).


%%------------------------------------------------------------------------------
%% $Id DCI_SDUID1
%%
%% $Header
%%  Multilink CPRI - Set DU Unit Id - State starting
%%
%% $Description
%%  Sets DU unit id in state starting
%%
%% $Requirements
%%  TBD
%%
%% $HW config
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  The DU BC is in state starting
%%  DP LMC is loaded
%%  DCI connection establish performed
%%
%% $Action_1
%%  Send a RICM_SET_DU_UNIT_ID_REQ, with parameters:
%%  * unitId = ?UNIT_ID_DU1
%%
%% $Result_1
%%  A RICM_SET_DU_UNIT_ID_CFM is received
%%
%% $Action_2
%%  Send a RICM_SET_DU_UNIT_ID_REQ again, with parameters:
%%  * unitId = ?UNIT_ID_DU1
%%
%% $Result_2
%%  A RICM_SET_DU_UNIT_ID_CFM is received
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Revision history:
%%  2014-06-03, QSATDHA
%%    First version
%%
%%------------------------------------------------------------------------------
dci_sduid1() ->
	[{userdata,[{wp, ""},
				{requirement, "TBD"},
				{slogan, "Multilink CPRI - Set DU Unit Id - State starting"}]}].

dci_sduid1(_Config) ->
	dci_sduid("dci_sduid1", starting_lmc_loaded ).

%%------------------------------------------------------------------------------
%% $Id DCI_SDUID2
%%
%% $Header
%%  Multilink CPRI -  Set DU Unit Id - State operational
%%
%% $Description
%%  Sets DU unit id in state operational
%%
%% $Requirements
%%  TBD
%%
%% $HW config
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  The DU BC is in state operational
%%  DP LMC is loaded
%%  DCI connection establish performed
%%
%% $Action_1
%%  Send a RICM_SET_DU_UNIT_ID_REQ, with parameters:
%%  * UnitId
%%
%% $Result_1
%%  A RICM_SET_DU_UNIT_ID_CFM is received
%%
%%
%% $Action_2
%%  Send a RICM_SET_DU_UNIT_ID_REQ again, with parameters:
%%  * unitId = ?UNIT_ID_DU1
%%
%% $Result_2
%%  A RICM_SET_DU_UNIT_ID_CFM is received
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Revision history:
%%  2014-06-03, QSATDHA
%%    First version
%%
%%------------------------------------------------------------------------------
dci_sduid2() ->
	[{userdata,[{wp, ""},
				{requirement, "TBD"},
				{slogan, "Multilink CPRI -  Set DU Unit Id - State operational"}]}].

dci_sduid2(_Config) ->
	dci_sduid( "dci_sduid2", operational ).

dci_sduid(Name, State) ->

	ct:pal(Name),

	LogString = string:concat("Test case ", string:to_upper(Name)),

	%% Restart RICM to reset previous DU unit id
	ok = nci_bci_actions:restartboard_fwd([{traceInformation, LogString}]),

	%% Set state, make audit, establish BCI and DCI connections
	set_state_and_connect( State ),

	%% Subscribe Faults DCI
	ok = nci_dci_actions:subscribe_faults([]),

	%% Set DU unit id
	nci_dci_actions:set_du_unit_id([{unitId, ?UNIT_ID_DU1}]),

	%% Set DU unit id again
	nci_dci_actions:set_du_unit_id([{unitId, ?UNIT_ID_DU1}]),

	%% Check for unexpected signals
	nci_common_utils:check_outstanding_faults().

%%------------------------------------------------------------------------------
%% $Id DCI_SDUID3
%%
%% $Header
%%  Multilink CPRI -  Set DU Unit Id - State disabled
%%
%% $Description
%%  Sets DU unit id in state disabled
%%
%% $Requirements
%%  TBD
%%
%% $HW config
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  The DU BC is in state disabled
%%  DP LMC is loaded
%%  DCI connection establish performed
%%
%% $Action_1
%%  Send a  RICM_SET_DU_UNIT_ID_REQ, with parameters:
%%  * unitId = ?UNIT_ID_DU1
%%
%% $Result_1
%%  A RICM_SET_DU_UNIT_ID_REJ is received with:
%%  * errorCode = ?ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL
%%  * errorDescription = "Invalid O&M state"
%%
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Revision history:
%%  2014-06-03, QSATDHA
%%    First version
%%
%%------------------------------------------------------------------------------
dci_sduid3() ->
	[{userdata,[{wp, ""},
				{requirement, "TBD"},
				{slogan, "Multilink CPRI -  Set DU Unit Id - State disabled"}]}].

dci_sduid3(_Config) ->
	ct:pal("dci_sduid3"),

	LogString = string:concat("Test case ", string:to_upper("dci_sduid3")),

	%% Restart RICM to reset previous DU unit id
	ok = nci_bci_actions:restartboard_fwd([{traceInformation, LogString}]),

	%% Set state, make audit, establish BCI and DCI connections, subscribe faults
	set_state_and_connect( starting_lmc_loaded ),
	set_state_and_connect( disabled ),

	%% Subscribe Faults DCI
	ok = nci_dci_actions:subscribe_faults([]),

	%% Set DU unit id
	nci_dci_actions:set_du_unit_id([{unitId, ?UNIT_ID_DU1},
									{expectedSigNo, ?RICM_SET_DU_UNIT_ID_REJ},
									{errorCode, ?ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL},
									{errorDescription, {regexp, "Invalid O&M state*"}}]),


	%% Check for unexpected signals
	nci_common_utils:check_outstanding_faults().

%%------------------------------------------------------------------------------
%% $Id DCI_SDUID4
%%
%% $Header
%%  Multilink CPRI -  Set DU Unit Id - State DP not loaded
%%
%% $Description
%%  Sets du unit id in state DP not loaded
%%
%% $Requirements
%%  TBD
%%
%% $HW config
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  The DU BC is in state DP not loaded
%%  DCI connection establish performed
%%
%% $Action_1
%%  Send a RICM_SET_DU_UNIT_ID_REQ, with parameters:
%%  * unitId = ?UNIT_ID_DU1
%%
%% $Result_1
%%  A RICM_SET_DU_UNIT_ID_CFM is received
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Revision history:
%%  2014-06-03, QSATDHA
%%    First version
%%
%%------------------------------------------------------------------------------
dci_sduid4() ->
	[{userdata,[{wp, ""},
				{requirement, "TBD"},
				{slogan, "Multilink CPRI -  Set DU Unit Id - DP not loaded"}]}].

dci_sduid4(_Config) ->
	ct:pal("dci_sduid4"),


	LogString = string:concat("Test case ", string:to_upper("dci_sduid4")),

	%% Restart RICM to reset previous DU unit id
	ok = nci_bci_actions:restartboard_fwd([{traceInformation, LogString}]),


	%% Set state, make audit, establish BCI and DCI connections, subscribe faults
	set_state_and_connect( starting_lmc_not_loaded ),

	%% Subscribe Faults DCI
	ok = nci_dci_actions:subscribe_faults([]),

	%% Set DU unit id, it does not matter DP is loaded or not
	nci_dci_actions:set_du_unit_id([{unitId, ?UNIT_ID_DU1}]),

	%% Check for unexpected signals
	nci_common_utils:check_outstanding_faults().

%%------------------------------------------------------------------------------
%% $Id DCI_SDUID5
%%
%% $Header
%%  Multilink CPRI -  Set DU Unit Id - Illegal unitId
%%
%% $Description
%%  Sets DU unit id with illegal unitId (state starting)
%%
%% $Requirements
%%  TBD
%%
%% $HW config
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  The DU BC is in state starting
%%  DP LMC is loaded
%%  DCI connection establish performed
%%
%%
%% $Action_1
%%  Send a RICM_SET_DU_UNIT_ID_REQ, with parameter:
%%  * unitId = 0
%%
%% $Result_1
%%  A RICM_SET_DU_UNIT_ID_REJ is received with
%%  * errorCode        = ?ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL
%%  * errorDescription = Illegal unitId
%%
%% $Action_2
%%  Send a RICM_SET_DU_UNIT_ID_REQ, with parameter:
%%  * unitId = ?UNIT_ID_DU1
%%
%% $Result_2
%%  A RICM_SET_DU_UNIT_ID_CFM is received
%%
%% $Action_3
%%  Send a RICM_SET_DU_UNIT_ID_REQ, with parameter:
%%  * unitId = 255
%%
%% $Result_3
%%  A RICM_SET_DU_UNIT_ID_REJ is received with
%%  * errorCode        = ?ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL
%%  * errorDescription = Different unitId already set.
%%
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Revision history:
%%  2014-06-03, QSATDHA
%%    First version
%%
%%------------------------------------------------------------------------------
dci_sduid5() ->
	[{userdata,[{wp, ""},
				{requirement, "TBD"},
				{slogan, "Multilink CPRI - Set DU Unit Id - Illegal unitId"}]}].

dci_sduid5(_Config) ->
	ct:pal("dci_sduid5"),

	LogString = string:concat("Test case ", string:to_upper("dci_sduid5")),

	%% Restart RICM to reset previous DU unit id
	ok = nci_bci_actions:restartboard_fwd([{traceInformation, LogString}]),

	%% Set state, make audit, establish BCI and DCI connections, subscribe faults
	set_state_and_connect( starting_lmc_loaded ),

	%% Subscribe Faults DCI
	ok = nci_dci_actions:subscribe_faults([]),

	%% Set DU unit id with illegal UnitId outside 1-0xFFFF range
	UnitId1 = 0,
	nci_dci_actions:set_du_unit_id([{unitId, UnitId1},
									{expectedSigNo, ?RICM_SET_DU_UNIT_ID_REJ},
									{errorCode, ?ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL},
									{errorDescription, {regexp, "Illegal unitId*"}}]),

	%% Set DU unit id in the valid range 1-0xFFFF
	nci_dci_actions:set_du_unit_id([{unitId, ?UNIT_ID_DU1}]),

	%% Set a different DU unit id in the range 1-0xFFFF
	UnitId2 = 255,
	nci_dci_actions:set_du_unit_id([{unitId, UnitId2},
									{expectedSigNo, ?RICM_SET_DU_UNIT_ID_REJ},
									{errorCode, ?ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL},
									{errorDescription, {regexp, "Different unitId already set.*"}}]),

	%% Check for unexpected signals
	nci_common_utils:check_outstanding_faults().

%%------------------------------------------------------------------------------
%% $Id DCI_IDL2_INIT
%%
%% $Header
%%  IDL2 Link - Initialization test case
%%
%% $Description
%%  Starts all IDL2 links from DU1 and makes sure they are loaded with type3 software.
%%  This is a prerequisite for all type3-type3 test cases.
%%
%% $Requirements
%%  TBD
%%
%% $HW config
%%  At least one IDL2 link
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  The DU BC is in state starting
%%  DP LMC is loaded
%%  DCI connection establish performed
%%
%% $Action_1
%%  Start all IDL2 links.
%%
%% $Result_1
%%  All IDL2 links are started.
%%
%% $Action_2
%%  Perform BCI connection establish to RICM on all leaf nodes.
%%  Allow 3 min for each hunt to succeed.
%%
%% $Result_2
%%  BCI connection establish is successful.
%%
%% $Action_3
%%  In most cases any potential PMDs from leaf nodes will already have been
%%  transfered to the branch mode at this point. But in case they haven't, 
%%  we give CS some more time by adding a 15 second delay.
%%
%% $Result_3
%%  -
%%
%% $Action_4
%%  Stop all IDL2 links.
%%
%% $Result_4
%%  All IDL2 links are stopped.
%%
%% $Action_5
%%  Clean the signal queue for any excess RICM_START_IDL2_LINK_IND signals.
%%
%% $Result_5
%%  All RICM_START_IDL2_LINK_IND are removed from the signal queue.
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%% -
%%
%% Revision history:
%%   2013-10-30 ebacemi
%%     First version
%%   2013-11-06 ebacemi
%%     Improved the TC by removing the 2min delay and adding a 3min timeout to the hunt in BCI conn establish
%%
%%------------------------------------------------------------------------------
dci_idl2_init() ->
	[{userdata,[{wp, ""},
				{requirement, "TBD"},
				{slogan, "IDL2 Link - Initialization test case"},
				{hwConfig, hwConfigIDL2_A}]}].

dci_idl2_init(_Config) ->
	ct:pal("dci_idl2_init"),

	subscribe_states(),

	LineRate = ?IDL2_LINE_RATE_2_5G,
	PacketRatio = 1,

	nci_bci_states:set_state([{state, starting_lmc_loaded}]),

	ok = nci_dci_actions:conn_establish([]),

	IDL2Links = nci_ricm_utils:get_all_idl2_links(),

	ct:pal("Action_1"),
	lists:foreach(
		fun(IDL2Link) ->
				ok = nci_dci_actions:start_idl2_link(IDL2Link ++ [{packetRatio, PacketRatio},
																  {lineRate, LineRate}]),

				{ok, _} = nci_dci_actions:idl2_link_ind(IDL2Link ++ [{packetRatio, PacketRatio},
																	 {lineRate, '_'},
																	 {availStatus, ?RICM_IDL2_LINK_AVAILABLE}])
				%% No need to wait for time sync here since we're only interested in getting the
				%% linx communication up to the leaf DUs.
		end,
		IDL2Links),

	ct:pal("Action_2"),
	lists:foreach(
		fun(IDL2Link) ->
				BcServer = proplists:get_value(farEndDuLnhPath, IDL2Link) ++ "/" ++ ?BC_SERVER,

				nci_bci_actions:conn_establish([{bcServer, BcServer},
												{huntTimeout, 180*1000}])
		end,
		IDL2Links),

	ct:pal("Action_3"),
	ct:pal("15 second delay allowing CS to finish transfer PMDs"),
	timer:sleep(15*1000),

	ct:pal("Action_4"),
	lists:foreach(
		fun(IDL2Link) ->
				ok = nci_dci_actions:stop_idl2_link(IDL2Link),

				wait_for_leaf(false)
		end,
		IDL2Links),

	ct:pal("Action_5"),
	nci_common_utils:clean_signal_queue([?RICM_START_IDL2_LINK_IND]),

	%% Check for unexpected signals
	nci_common_utils:check_outstanding_faults().


%%------------------------------------------------------------------------------
%% $Id DCI_IDL2_START1
%%
%% $Header
%%  IDL2 Link - Start IDL2 Link (2.5G) State Starting LMC Loaded
%%
%% $Description
%%  Verifies that it is possible to start a 2.5G speed IDL2 link using
%%  the RICM_START_IDL2_LINK_REQ signal in state starting.
%%
%% $Requirements
%%  TBD
%%
%% $HW config
%%  At least one 2.5G IDL2 link
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  The DU BC is in state starting
%%  DP LMC is loaded
%%  DCI connection establish performed
%%  Subscribe DCI faults
%%
%% $Action_1
%%  Send RICM_START_IDL2_LINK_REQ with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%  * farEndDuId = <read from config file>
%%  * farEndPortNo = <read from config file>
%%  * packetRatio = 1
%%  * lineRate = IDL2_LINE_RATE_2.5G
%%
%% $Result_1
%%  RICM_START_IDL2_LINK_CFM is received with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%
%% $Action_2
%%  Wait for a RICM_START_IDL2_LINK_IND signal.
%%
%% $Result_2
%%  RICM_START_IDL2_LINK_IND is received with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%  * packetRatio = 1
%%  * lineRate = <don't care>
%%  * availStatus = RICM_IDL2_LINK_AVAILABLE
%%
%% $Action_3
%%  Read the lineRate from Result_2 and verify that it is not
%%  higher than the one specified in Action_1.
%%
%% $Result_3
%%  The lineRate in Result_2 is correct.
%%
%% $Action_4
%%  When the leaf DU is type3:
%%  Wait for a RICM_START_IDL2_LINK_IND signal.
%%
%% $Result_4
%%  RICM_START_IDL2_LINK_IND is received with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%  * packetRatio = 1
%%  * lineRate = <same as in Result_2>
%%  * availStatus = RICM_IDL2_LINK_AVAILABLE_SYNC
%%
%% $Action_5
%%  Call verify_idl2_link_up on Branch node to verify that 
%%  CPRI registers have correct values.
%%
%% $Result_5
%%  Registers have correct values.
%%
%% $Action_6
%%  Call verify_idl2_link_up on Leaf node to verify that 
%%  CPRI registers have correct values.
%%
%% $Result_6
%%  Registers have correct values.
%%
%% $Action_7
%%  Send RICM_STOP_IDL2_LINK_REQ with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%
%% $Result_7
%%  RICM_STOP_IDL2_LINK_CFM is received with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%
%% $Action_8
%%  Call verify_idl2_link_down on Branch node to verify that 
%%  CPRI registers have correct values.
%%
%% $Result_8
%%  Registers have correct values.
%%
%% $Action_9
%%  Call verify_idl2_link_down on Leaf node to verify that 
%%  CPRI registers have correct values.
%%
%% $Result_9
%%  Registers have correct values.
%%
%% $Action_10
%%  Repeat Action_1 to Action_9 for the remaining IDL2 links
%%
%% $Result_10
%%  -
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%% -
%%
%% Revision history:
%%   2013-04-29 ebacemi
%%     First version
%%
%%   2013-07-08 ebacemi
%%     Renamed to dci_idl2_start1
%%
%%   2013-08-19 ebacemi
%%     Line rate should not be higher than the specified one
%%
%%   2014-01-20 ebacemi
%%     Updated for WP6.1
%%
%%------------------------------------------------------------------------------
dci_idl2_start1() ->
	[{userdata,[{wp, ""},
				{requirement, "TBD"},
				{slogan, "IDL2 Link - Start IDL2 Link (2.5G) State Starting LMC Loaded"},
			    {hwConfig, hwConfigIDL2_A}]}].

dci_idl2_start1(_Config) ->
	ct:pal("dci_idl2_start1"),
	idl2_link_setup(?IDL2_LINE_RATE_2_5G, starting_lmc_loaded).

%%------------------------------------------------------------------------------
%% $Id DCI_IDL2_START2
%%
%% $Header
%%  IDL2 Link - Start IDL2 Link (2.5G) State Operational
%%
%% $Description
%%  Verifies that it is possible to start a 2.5G speed IDL2 link using
%%  the RICM_START_IDL2_LINK_REQ signal in state operational.
%%
%% $Requirements
%%  TBD
%%
%% $HW config
%%  At least one 2.5G IDL2 link
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  The DU BC is in state operational
%%  DP LMC is loaded
%%  DCI connection establish performed
%%  Subscribe DCI faults
%%
%% $Action_1
%%  Send RICM_START_IDL2_LINK_REQ with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%  * farEndDuId = <read from config file>
%%  * farEndPortNo = <read from config file>
%%  * packetRatio = 1
%%  * lineRate = IDL2_LINE_RATE_2_5G
%%
%% $Result_1
%%  RICM_START_IDL2_LINK_CFM is received with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%
%% $Action_2
%%  Wait for a RICM_START_IDL2_LINK_IND signal.
%%
%% $Result_2
%%  RICM_START_IDL2_LINK_IND is received with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%  * packetRatio = 1
%%  * lineRate = <don't care>
%%  * availStatus = RICM_IDL2_LINK_AVAILABLE
%%
%% $Action_3
%%  Read the lineRate from Result_2 and verify that it is not
%%  higher than the one specified in Action_1.
%%
%% $Result_3
%%  The lineRate in Result_2 is correct.
%%
%% $Action_4
%%  When the leaf DU is type3:
%%  Wait for a RICM_START_IDL2_LINK_IND signal.
%%
%% $Result_4
%%  RICM_START_IDL2_LINK_IND is received with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%  * packetRatio = 1
%%  * lineRate = <same as in Result_2>
%%  * availStatus = RICM_IDL2_LINK_AVAILABLE_SYNC
%%
%% $Action_5
%%  Call verify_idl2_link_up on Branch node to verify that 
%%  CPRI registers have correct values.
%%
%% $Result_5
%%  Registers have correct values.
%%
%% $Action_6
%%  Call verify_idl2_link_up on Leaf node to verify that 
%%  CPRI registers have correct values.
%%
%% $Result_6
%%  Registers have correct values.
%%
%% $Action_7
%%  Send RICM_STOP_IDL2_LINK_REQ with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%
%% $Result_7
%%  RICM_STOP_IDL2_LINK_CFM is received with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%
%% $Action_8
%%  Call verify_idl2_link_down on Branch node to verify that 
%%  CPRI registers have correct values.
%%
%% $Result_8
%%  Registers have correct values.
%%
%% $Action_9
%%  Call verify_idl2_link_down on Leaf node to verify that 
%%  CPRI registers have correct values.
%%
%% $Result_9
%%  Registers have correct values.
%%
%% $Action_10
%%  Repeat Action_1 to Action_9 for the remaining IDL2 links
%%
%% $Result_10
%%  -
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%% -
%%
%% Revision history:
%%   2013-07-08 ebacemi
%%     First version
%%
%%   2013-08-19 ebacemi
%%     Line rate should not be higher than the specified one
%%
%%   2014-01-20 ebacemi
%%     Updated for WP6.1
%%
%%------------------------------------------------------------------------------
dci_idl2_start2() ->
	[{userdata,[{wp, ""},
				{requirement, "TBD"},
				{slogan, "IDL2 Link - Start IDL2 Link (2.5G) State Operational"},
			    {hwConfig, hwConfigIDL2_A}]}].

dci_idl2_start2(_Config) ->
	ct:pal("dci_idl2_start2"),
	idl2_link_setup(?IDL2_LINE_RATE_2_5G, operational).

%%------------------------------------------------------------------------------
%% $Id DCI_IDL2_START3
%%
%% $Header
%%  IDL2 Link - Start IDL2 Link (2.5G) State Disabled
%%
%% $Description
%%  Verifies that it is not possible to start a 2.5G speed IDL2 link using
%%  the RICM_START_IDL2_LINK_REQ signal in state disabled.
%%
%% $Requirements
%%  TBD
%%
%% $HW config
%%  Any
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  The DU BC is in state disabled
%%  DP LMC is loaded
%%  DCI connection establish performed
%%  Subscribe DCI faults
%%
%% $Action_1
%%  Send RICM_START_IDL2_LINK_REQ with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%  * farEndDuId = <read from config file>
%%  * farEndPortNo = <read from config file>
%%  * packetRatio = 1
%%  * lineRate = IDL2_LINE_RATE_2_5G
%%
%% $Result_1
%%  RICM_START_IDL2_LINK_REJ is received with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%  * errorCode = UNSUCCESSFUL
%%  * errorDescription = "Invalid O&M state"
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%% -
%%
%% Revision history:
%%   2013-07-08 ebacemi
%%     First version
%%
%%------------------------------------------------------------------------------
dci_idl2_start3() ->
	[{userdata,[{wp, ""}, 
				{requirement, "TBD"},
				{slogan, "IDL2 Link - Start IDL2 Link (2.5G) State Disabled"}]}].

dci_idl2_start3(_Config) ->
	ct:pal("dci_idl2_start3"),
	dci_idl2_start_rej(disabled, "Invalid O&M state").

%%------------------------------------------------------------------------------
%% $Id DCI_IDL2_START4
%%
%% $Header
%%  IDL2 Link - Start IDL2 Link (2.5G) State Starting LMC Not Loaded
%%
%% $Description
%%  Verifies that it is not possible to start a 2.5G speed IDL2 link using
%%  the RICM_START_IDL2_LINK_REQ signal in state starting LMC not loaded.
%%
%% $Requirements
%%  TBD
%%
%% $HW config
%%  Any
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  The DU BC is in state starting
%%  DP LMC is not loaded
%%  DCI connection establish performed
%%  Subscribe DCI faults
%%
%% $Action_1
%%  Send RICM_START_IDL2_LINK_REQ with parameters: 
%%  * nearEndDuId = 1
%%  * nearEndPortNo = 3
%%  * farEndDuId = 2
%%  * farEndPortNo = 3
%%  * packetRatio = 1
%%  * lineRate = IDL2_LINE_RATE_2_5G
%%
%% $Result_1
%%  RICM_START_IDL2_LINK_REJ is received with parameters: 
%%  * nearEndDuId = 1
%%  * nearEndPortNo = 3
%%  * errorCode = UNSUCCESSFUL
%%  * errorDescription = "DP not loaded"
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%% -
%%
%% Revision history:
%%   2013-07-08 ebacemi
%%     First version
%%
%%------------------------------------------------------------------------------
dci_idl2_start4() ->
	[{userdata,[{wp, ""}, 
				{requirement, "TBD"},
				{slogan, "IDL2 Link - Start IDL2 Link (2.5G) State Starting LMC Not Loaded"}]}].

dci_idl2_start4(_Config) ->
	ct:pal("dci_idl2_start4"),
	dci_idl2_start_rej(starting_lmc_not_loaded, "DP not loaded").

dci_idl2_start_rej(State, ErrorDescription) ->
	subscribe_states(),

	case State of
		disabled ->
			%% Need to load DP LMC before going to disabled state
			nci_bci_states:set_state([{state, starting_lmc_loaded}]);
		_ ->
			ok
	end,

	nci_bci_states:set_state([{state, State}]),

	ok = nci_dci_actions:conn_establish([]),
	ok = nci_dci_actions:subscribe_faults([]),

	ct:pal("Action_1"),
	ok = nci_dci_actions:start_idl2_link([{nearEndDuId, 1}, 
										  {nearEndPortNo, 3},
										  {farEndDuId, 2},
										  {farEndPortNo, 3},
										  {packetRatio, 1},
										  {lineRate, ?IDL2_LINE_RATE_2_5G},
										  {expectedSigNo, ?RICM_START_IDL2_LINK_REJ},
										  {errorCode, ?ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL},
										  {errorDescription, {regexp, ErrorDescription}}]),

	%% Check for unexpected signals
	nci_common_utils:check_outstanding_faults().


%%------------------------------------------------------------------------------
%% $Id DCI_IDL2_START5
%%
%% $Header
%%  IDL2 Link - Start IDL2 Link (5G)
%%
%% $Description
%%  Verifies that it is possible to start a 5G speed IDL2 link using
%%  the RICM_START_IDL2_LINK_REQ signal.
%%
%% $Requirements
%%  TBD
%%
%% $HW config
%%  At least one 5G IDL2 link
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  The DU BC is in state starting
%%  DP LMC is loaded
%%  DCI connection establish performed
%%  Subscribe DCI faults
%%
%% $Action_1
%%  Send RICM_START_IDL2_LINK_REQ with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%  * farEndDuId = <read from config file>
%%  * farEndPortNo = <read from config file>
%%  * packetRatio = 1
%%  * lineRate = 2
%%
%% $Result_1
%%  RICM_START_IDL2_LINK_CFM is received with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%
%% $Action_2
%%  Wait for a RICM_START_IDL2_LINK_IND signal.
%%
%% $Result_2
%%  RICM_START_IDL2_LINK_IND is received with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%  * packetRatio = 1
%%  * lineRate = <don't care>
%%  * availStatus = RICM_IDL2_LINK_AVAILABLE
%%
%% $Action_3
%%  Read the lineRate from Result_2 and verify that it is not
%%  higher than the one specified in Action_1.
%%
%% $Result_3
%%  The lineRate in Result_2 is correct.
%%
%% $Action_4
%%  When the leaf DU is type3:
%%  Wait for a RICM_START_IDL2_LINK_IND signal.
%%
%% $Result_4
%%  RICM_START_IDL2_LINK_IND is received with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%  * packetRatio = 1
%%  * lineRate = <same as in Result_2>
%%  * availStatus = RICM_IDL2_LINK_AVAILABLE_SYNC
%%
%% $Action_5
%%  Call verify_idl2_link_up on Branch node to verify that 
%%  CPRI registers have correct values.
%%
%% $Result_5
%%  Registers have correct values.
%%
%% $Action_6
%%  Call verify_idl2_link_up on Leaf node to verify that 
%%  CPRI registers have correct values.
%%
%% $Result_6
%%  Registers have correct values.
%%
%% $Action_7
%%  Send RICM_STOP_IDL2_LINK_REQ with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%
%% $Result_7
%%  RICM_STOP_IDL2_LINK_CFM is received with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%
%% $Action_8
%%  Call verify_idl2_link_down on Branch node to verify that 
%%  CPRI registers have correct values.
%%
%% $Result_8
%%  Registers have correct values.
%%
%% $Action_9
%%  Call verify_idl2_link_down on Leaf node to verify that 
%%  CPRI registers have correct values.
%%
%% $Result_9
%%  Registers have correct values.
%%
%% $Action_10
%%  Repeat Action_1 to Action_9 for the remaining IDL2 links
%%
%% $Result_10
%%  -
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%% -
%%
%% Revision history:
%%   2013-04-29 ebacemi
%%     First version
%%
%%   2013-07-08 ebacemi
%%     Renamed to dci_idl2_start5
%%
%%   2013-08-19 ebacemi
%%     Line rate should not be higher than the specified one
%%
%%   2014-01-20 ebacemi
%%     Updated for WP6.1
%%
%%------------------------------------------------------------------------------
dci_idl2_start5() ->
	[{userdata,[{wp, ""},
				{requirement, "TBD"},
				{slogan, "IDL2 Link - Start IDL2 Link (5G)"},
			    {hwConfig, hwConfigIDL2_B}]}].

dci_idl2_start5(_Config) ->
	ct:pal("dci_idl2_start5"),
	idl2_link_setup(?IDL2_LINE_RATE_5G, starting_lmc_loaded).

%%------------------------------------------------------------------------------
%% $Id DCI_IDL2_START6
%%
%% $Header
%%  IDL2 Link - Start IDL2 Link (10G)
%%
%% $Description
%%  Verifies that it is possible to start a 10G speed IDL2 link using
%%  the RICM_START_IDL2_LINK_REQ signal.
%%
%% $Requirements
%%  TBD
%%
%% $HW config
%%  At least one 10G IDL2 link
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  The DU BC is in state starting
%%  DP LMC is loaded
%%  DCI connection establish performed
%%  Subscribe DCI faults
%%
%% $Action_1
%%  Send RICM_START_IDL2_LINK_REQ with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%  * farEndDuId = <read from config file>
%%  * farEndPortNo = <read from config file>
%%  * packetRatio = 1
%%  * lineRate = 2
%%
%% $Result_1
%%  RICM_START_IDL2_LINK_CFM is received with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%
%% $Action_2
%%  Wait for a RICM_START_IDL2_LINK_IND signal.
%%
%% $Result_2
%%  RICM_START_IDL2_LINK_IND is received with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%  * packetRatio = 1
%%  * lineRate = <don't care>
%%  * availStatus = RICM_IDL2_LINK_AVAILABLE
%%
%% $Action_3
%%  Read the lineRate from Result_2 and verify that it is not
%%  higher than the one specified in Action_1.
%%
%% $Result_3
%%  The lineRate in Result_2 is correct.
%%
%% $Action_4
%%  When the leaf DU is type3:
%%  Wait for a RICM_START_IDL2_LINK_IND signal.
%%
%% $Result_4
%%  RICM_START_IDL2_LINK_IND is received with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%  * packetRatio = 1
%%  * lineRate = <same as in Result_2>
%%  * availStatus = RICM_IDL2_LINK_AVAILABLE_SYNC
%%
%% $Action_5
%%  Call verify_idl2_link_up on Branch node to verify that 
%%  CPRI registers have correct values.
%%
%% $Result_5
%%  Registers have correct values.
%%
%% $Action_6
%%  Call verify_idl2_link_up on Leaf node to verify that 
%%  CPRI registers have correct values.
%%
%% $Result_6
%%  Registers have correct values.
%%
%% $Action_7
%%  Send RICM_STOP_IDL2_LINK_REQ with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%
%% $Result_7
%%  RICM_STOP_IDL2_LINK_CFM is received with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%
%% $Action_8
%%  Call verify_idl2_link_down on Branch node to verify that 
%%  CPRI registers have correct values.
%%
%% $Result_8
%%  Registers have correct values.
%%
%% $Action_9
%%  Call verify_idl2_link_down on Leaf node to verify that 
%%  CPRI registers have correct values.
%%
%% $Result_9
%%  Registers have correct values.
%%
%% $Action_10
%%  Repeat Action_1 to Action_9 for the remaining IDL2 links
%%
%% $Result_10
%%  -
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%% -
%%
%% Revision history:
%%   2013-04-29 ebacemi
%%     First version
%%
%%   2013-07-08 ebacemi
%%     Renamed to dci_idl2_start6
%%
%%   2013-08-19 ebacemi
%%     Line rate should not be higher than the specified one
%%
%%   2014-01-20 ebacemi
%%     Updated for WP6.1
%%
%%------------------------------------------------------------------------------
dci_idl2_start6() ->
	[{userdata,[{wp, ""},
				{requirement, "TBD"},
				{slogan, "IDL2 Link - Start IDL2 Link (10G)"},
				{hwConfig, hwConfigIDL2_C}]}].

dci_idl2_start6(_Config) ->
	ct:pal("dci_idl2_start6"),
	idl2_link_setup(?IDL2_LINE_RATE_10G, starting_lmc_loaded).

idl2_link_setup(LineRate, State) ->
	idl2_link_setup(LineRate, State, LineRate).

idl2_link_setup(LineRate, State, ExpectedLineRate) ->
	subscribe_states(),

	Node2Exists = nci_ricm_utils:node_exists(node2),

	nci_bci_states:set_state([{state, State}]),

	ok = nci_dci_actions:conn_establish([]),
	ok = nci_dci_actions:subscribe_faults([]),

	if LineRate == ExpectedLineRate ->
			IDL2Links = nci_ricm_utils:get_all_idl2_links([{minLineRate, LineRate}]);
	   true ->
			IDL2Links = nci_ricm_utils:get_all_idl2_links([{maxLineRate, ExpectedLineRate}])
	end,

	PacketRatio = 1,

	lists:foreach(
		fun(IDL2Link) ->
				ct:pal("IDL2 link used: ~p", [IDL2Link]),

				ct:pal("Action_1"),
				ok = nci_dci_actions:start_idl2_link(IDL2Link ++ [{packetRatio, PacketRatio},
																  {lineRate, LineRate}]),

				ct:pal("Action_2"),
				%% lineRate is "don't care" since RICM might set up the link with a different 
				%% line rate than the specified one.
				{ok, Ind} = nci_dci_actions:idl2_link_ind(IDL2Link ++ [{packetRatio, PacketRatio},
																	   {lineRate, '_'},
																	   {availStatus, ?RICM_IDL2_LINK_AVAILABLE}]),
				ReceivedLineRate = Ind#'RicmStartIdl2LinkIndS'.lineRate,

				ct:pal("Action_3"), 
				%% The received line rate must not be higher than the input line rate or
				%% the maximum supported line rate.
				if ReceivedLineRate > ExpectedLineRate ->
						ct:fail("Line rate is greater than ~p", [ExpectedLineRate]);
				   true ->
						ok
				end,

				ct:pal("Action_4"), 
				receive_time_sync_ind(IDL2Link, PacketRatio, ReceivedLineRate),

				ct:pal("Action_5"),
				verify_idl2_link_up(IDL2Link ++ [{packetRatio, PacketRatio},
												 {lineRate, ReceivedLineRate}]),

				ct:pal("Action_6"),
				verify_idl2_link_up_leaf(IDL2Link ++ [{packetRatio, PacketRatio},
													  {lineRate, ReceivedLineRate},
													  {node2Exists, Node2Exists}]),

				ct:pal("Action_7"),
				ok = nci_dci_actions:stop_idl2_link(IDL2Link),

				ct:pal("Action_8"),
				verify_idl2_link_down(IDL2Link),

				ct:pal("Action_9"),
				verify_idl2_link_down_leaf(IDL2Link ++ [{node2Exists, Node2Exists}]),

				wait_for_leaf(Node2Exists),

				ct:pal("Action_10")

		end,
		IDL2Links),

	%% Check for unexpected signals
	nci_common_utils:check_outstanding_faults().

%%------------------------------------------------------------------------------
%% $Id DCI_IDL2_START7
%%
%% $Header
%%  IDL2 Link - Start IDL2 Link: Invalid NearEndPortNo
%%
%% $Description
%%  Verifies that RICM sends the correct reject signal when specifying an invalid
%%  nearEndPortNo in RICM_START_IDL2_LINK_REQ.
%%
%% $Requirements
%%  TBD
%%
%% $HW config
%%  Any
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  The DU BC is in state starting
%%  DP LMC is loaded
%%  DCI connection establish performed
%%  Subscribe DCI faults
%%
%% $Action_1
%%  Send RICM_START_IDL2_LINK_REQ with parameters: 
%%  * nearEndDuId = 1
%%  * nearEndPortNo = <0, 1, 2, 7>
%%  * farEndDuId = 2
%%  * farEndPortNo = 3
%%  * packetRatio = 1
%%  * lineRate = 2
%%
%% $Result_1
%%  RICM_START_IDL2_LINK_REJ is received with parameters: 
%%  * errorCode = UNSUCCESSFUL
%%  * errorDescription = "Invalid nearEndPortNo"
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%% -
%%
%% Revision history:
%%   2013-07-15 ebacemi
%%     First version
%%
%%------------------------------------------------------------------------------
dci_idl2_start7() ->
	[{userdata,[{wp, ""}, 
				{requirement, "TBD"},
				{slogan, "IDL2 Link - Start IDL2 Link: Invalid NearEndPortNo"}]}].

dci_idl2_start7(_Config) ->
	ct:pal("dci_idl2_start7"),

	subscribe_states(),

	nci_bci_states:set_state([{state, starting_lmc_loaded}]),

	ok = nci_dci_actions:conn_establish([]),
	ok = nci_dci_actions:subscribe_faults([]),

	ct:pal("Action_1"),
	lists:foreach(
		fun(NearEndPortNo) ->
				ok = nci_dci_actions:start_idl2_link([{expectedSigNo, ?RICM_START_IDL2_LINK_REJ},
													  {errorCode, ?ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL},
													  {errorDescription, {regexp, "Invalid nearEndPortNo"}},
													  {nearEndDuId, 1},
													  {nearEndPortNo, NearEndPortNo},
													  {farEndDuId, 2},
													  {farEndPortNo, 3},
													  {packetRatio, 1},
													  {lineRate, ?IDL2_LINE_RATE_2_5G}])
		end,
		[0, 1, 2, 7]),

	%% Check for unexpected signals
	nci_common_utils:check_outstanding_faults().

%%------------------------------------------------------------------------------
%% $Id DCI_IDL2_START8
%%
%% $Header
%%  IDL2 Link - Start IDL2 Link: Invalid FarEndPortNo
%%
%% $Description
%%  Verifies that RICM sends the correct reject signal when specifying an invalid
%%  farEndPortNo in RICM_START_IDL2_LINK_REQ.
%%
%% $Requirements
%%  TBD
%%
%% $HW config
%%  Any
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  The DU BC is in state starting
%%  DP LMC is loaded
%%  DCI connection establish performed
%%  Subscribe DCI faults
%%
%% $Action_1
%%  Send RICM_START_IDL2_LINK_REQ with parameters: 
%%  * nearEndDuId = 1
%%  * nearEndPortNo = 3
%%  * farEndDuId = 2
%%  * farEndPortNo = <0, 7>
%%  * packetRatio = 1
%%  * lineRate = 2
%%
%% $Result_1
%%  RICM_START_IDL2_LINK_REJ is received with parameters: 
%%  * errorCode = UNSUCCESSFUL
%%  * errorDescription = "Invalid farEndPortNo"
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%% -
%%
%% Revision history:
%%   2013-07-15 ebacemi
%%     First version
%%   2013-09-10 ebacemi
%%     Updated to not check values 1 and 2.
%%     Branch doesn't know what node leaf is, so we can only verify that farEndPortNo is within the valid range 1-6.
%%
%%------------------------------------------------------------------------------
dci_idl2_start8() ->
	[{userdata,[{wp, ""}, 
				{requirement, "TBD"},
				{slogan, "IDL2 Link - Start IDL2 Link: Invalid FarEndPortNo"}]}].

dci_idl2_start8(_Config) ->
	ct:pal("dci_idl2_start8"),

	subscribe_states(),

	nci_bci_states:set_state([{state, starting_lmc_loaded}]),

	ok = nci_dci_actions:conn_establish([]),
	ok = nci_dci_actions:subscribe_faults([]),

	ct:pal("Action_1"),
	lists:foreach(
		fun(FarEndPortNo) ->
				ok = nci_dci_actions:start_idl2_link([{expectedSigNo, ?RICM_START_IDL2_LINK_REJ},
													  {errorCode, ?ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL},
													  {errorDescription, {regexp, "Invalid farEndPortNo"}},
													  {nearEndDuId, 1},
													  {nearEndPortNo, 3},
													  {farEndDuId, 2},
													  {farEndPortNo, FarEndPortNo},
													  {packetRatio, 1},
													  {lineRate, ?IDL2_LINE_RATE_2_5G}])
		end,
		[0, 7]),

	%% Check for unexpected signals
	nci_common_utils:check_outstanding_faults().

%%------------------------------------------------------------------------------
%% $Id DCI_IDL2_START9
%%
%% $Header
%%  IDL2 Link - Start IDL2 Link: Invalid PacketRatio
%%
%% $Description
%%  Verifies that RICM sends the correct reject signal when specifying an invalid
%%  packetRatio in RICM_START_IDL2_LINK_REQ.
%%
%% $Requirements
%%  TBD
%%
%% $HW config
%%  Any
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  The DU BC is in state starting
%%  DP LMC is loaded
%%  DCI connection establish performed
%%  Subscribe DCI faults
%%
%% $Action_1
%%  Send RICM_START_IDL2_LINK_REQ with parameters: 
%%  * nearEndDuId = 1
%%  * nearEndPortNo = 3
%%  * farEndDuId = 2
%%  * farEndPortNo = 3
%%  * packetRatio = <0, 16>
%%  * lineRate = 2
%%
%% $Result_1
%%  RICM_START_IDL2_LINK_REJ is received with parameters: 
%%  * errorCode = UNSUCCESSFUL
%%  * errorDescription = "Invalid packetRatio"
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%% -
%%
%% Revision history:
%%   2013-07-15 ebacemi
%%     First version
%%
%%------------------------------------------------------------------------------
dci_idl2_start9() ->
	[{userdata,[{wp, ""}, 
				{requirement, "TBD"},
				{slogan, "IDL2 Link - Start IDL2 Link: Invalid PacketRatio"}]}].

dci_idl2_start9(_Config) ->
	ct:pal("dci_idl2_start9"),

	subscribe_states(),

	nci_bci_states:set_state([{state, starting_lmc_loaded}]),

	ok = nci_dci_actions:conn_establish([]),
	ok = nci_dci_actions:subscribe_faults([]),

	ct:pal("Action_1"),
	lists:foreach(
		fun(PacketRatio) ->
				ok = nci_dci_actions:start_idl2_link([{expectedSigNo, ?RICM_START_IDL2_LINK_REJ},
													  {errorCode, ?ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL},
													  {errorDescription, {regexp, "Invalid packetRatio"}},
													  {nearEndDuId, 1},
													  {nearEndPortNo, 3},
													  {farEndDuId, 2},
													  {farEndPortNo, 3},
													  {packetRatio, PacketRatio},
													  {lineRate, ?IDL2_LINE_RATE_2_5G}])
		end,
		[0, 16]),

	%% Check for unexpected signals
	nci_common_utils:check_outstanding_faults().

%%------------------------------------------------------------------------------
%% $Id DCI_IDL2_START10
%%
%% $Header
%%  IDL2 Link - Start IDL2 Link: Invalid LineRate
%%
%% $Description
%%  Verifies that RICM sends the correct reject signal when specifying an invalid
%%  lineRate in RICM_START_IDL2_LINK_REQ.
%%
%% $Requirements
%%  TBD
%%
%% $HW config
%%  Any
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  The DU BC is in state starting
%%  DP LMC is loaded
%%  DCI connection establish performed
%%  Subscribe DCI faults
%%
%% $Action_1
%%  Send RICM_START_IDL2_LINK_REQ with parameters: 
%%  * nearEndDuId = 1
%%  * nearEndPortNo = 3
%%  * farEndDuId = 2
%%  * farEndPortNo = 3
%%  * packetRatio = 1
%%  * lineRate = <0, 1, 5>
%%
%% $Result_1
%%  RICM_START_IDL2_LINK_REJ is received with parameters: 
%%  * errorCode = UNSUCCESSFUL
%%  * errorDescription = "Invalid lineRate"
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%% -
%%
%% Revision history:
%%   2013-07-15 ebacemi
%%     First version
%%
%%   2013-11-06 emanssa
%%     Update to include line rate = 0 and 1.
%%
%%------------------------------------------------------------------------------
dci_idl2_start10() ->
	[{userdata,[{wp, ""}, 
				{requirement, "TBD"},
				{slogan, "IDL2 Link - Start IDL2 Link: Invalid LineRate"}]}].

dci_idl2_start10(_Config) ->
	ct:pal("dci_idl2_start10"),

	subscribe_states(),

	nci_bci_states:set_state([{state, starting_lmc_loaded}]),

	ok = nci_dci_actions:conn_establish([]),
	ok = nci_dci_actions:subscribe_faults([]),

	ct:pal("Action_1"),
	lists:foreach(
		fun(LineRate) ->
			ok = nci_dci_actions:start_idl2_link([{expectedSigNo, ?RICM_START_IDL2_LINK_REJ},
												  {errorCode, ?ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL},
												  {errorDescription, {regexp, "Invalid lineRate"}},
												  {nearEndDuId, 1},
												  {nearEndPortNo, 3},
												  {farEndDuId, 2},
												  {farEndPortNo, 3},
												  {packetRatio, 1},
												  {lineRate, LineRate}])
		end,
		[0, 1, 5]),

	%% Check for unexpected signals
	nci_common_utils:check_outstanding_faults().

%%------------------------------------------------------------------------------
%% $Id DCI_IDL2_START11
%%
%% $Header
%%  IDL2 Link - Start IDL2 Link: Different lineRate and packetRatio
%%
%% $Description
%%  Attempts to start an IDL2 link on a port where IDL2 is already operational.
%%  All possible line rates and packet ratios are exercised when starting the second link.
%%  In all cases a CFM and an IND is expected. The parameters in the IND should match the
%%  initial link parameters.
%%
%% $Requirements
%%  TBD
%%
%% $HW config
%%  At least one 5G IDL2 link
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  The DU BC is in state starting
%%  DP LMC is loaded
%%  DCI connection establish performed
%%  Subscribe DCI faults
%%  All IDL2 links are started with lineRate = 5G and packetRatio = 1
%%
%% $Action_1
%%  Send RICM_START_IDL2_LINK_REQ with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%  * farEndDuId = <read from config file>
%%  * farEndPortNo = <read from config file>
%%  * packetRatio = 1
%%  * lineRate = [2, 3, 4]
%%
%% $Result_1
%%  RICM_START_IDL2_LINK_CFM is received with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%
%% $Action_2
%%  Wait for a RICM_START_IDL2_LINK_IND signal.
%%
%% $Result_2
%%  RICM_START_IDL2_LINK_IND is received with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%  * availStatus = RICM_IDL2_LINK_AVAILABLE_SYNC
%%  * packetRatio = 1
%%  * lineRate = 3
%%
%% $Action_3
%%  Repeat Action_1 to Action_2 for all valid line rates.
%%
%% $Result_3
%%  -
%%
%% $Action_4
%%  Send RICM_START_IDL2_LINK_REQ with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%  * farEndDuId = <read from config file>
%%  * farEndPortNo = <read from config file>
%%  * packetRatio = [1, 2, ..., 14, 15]
%%  * lineRate = 3
%%
%% $Result_4
%%  RICM_START_IDL2_LINK_CFM is received with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%
%% $Action_5
%%  Wait for a RICM_START_IDL2_LINK_IND signal.
%%
%% $Result_5
%%  RICM_START_IDL2_LINK_IND is received with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%  * availStatus = RICM_IDL2_LINK_AVAILABLE_SYNC
%%  * packetRatio = 1
%%  * lineRate = 3
%%
%% $Action_6
%%  Repeat Action_4 to Action_5 for all valid packet ratios.
%%
%% $Result_6
%%  -
%%
%% $Action_7
%%  Verify that the IDL2 link is operational by reading FPGA registers on branch and leaf.
%%
%% $Result_7
%%  IDL2 link is operational and registers have correct values.
%%
%% $Action_8
%%  Repeat Action_1 to Action_7 for all remaining IDL2 links
%%
%% $Result_8
%%  -
%%
%% $Postcondition
%%  Stop all IDL2 links.
%%
%% $End
%%
%% Review:
%% -
%%
%% Revision history:
%%   2013-07-15 ebacemi
%%     First version
%%   2013-08-06 ebacemi
%%     Bugfix, badmatch on first idl2_link_ind() call
%%   2013-09-09 ebacemi
%%     Updated TC to expect CFM and IND instead of REJ.
%%     Added Action_3.
%%   2013-11-06 ebacemi
%%     Improved TC to use all IDL2 links.
%%     Improved TC to test different line rates and packet ratios
%%
%%   2014-01-20 ebacemi
%%     Updated for WP6.1
%%
%%------------------------------------------------------------------------------
dci_idl2_start11() ->
	[{userdata,[{wp, ""},
				{requirement, "TBD"},
				{slogan, "IDL2 Link - Start IDL2 Link: Different lineRate and packetRatio"},
				{hwConfig, hwConfigIDL2_B}]}].

dci_idl2_start11(_Config) ->
	ct:pal("dci_idl2_start11"),

	subscribe_states(),

	Node2Exists = nci_ricm_utils:node_exists(node2),

	PacketRatio = 1,
	LineRate = ?IDL2_LINE_RATE_5G,

	AllLineRates = [?IDL2_LINE_RATE_2_5G, ?IDL2_LINE_RATE_5G, ?IDL2_LINE_RATE_10G],
	AllPacketRatios = lists:seq(1, 15),

	IDL2Links = nci_ricm_utils:get_all_idl2_links([{minLineRate, LineRate}]),

	nci_bci_states:set_state([{state, starting_lmc_loaded}]),

	ok = nci_dci_actions:conn_establish([]),
	ok = nci_dci_actions:subscribe_faults([]),

	start_idl2_links([{idl2Links, IDL2Links},
					  {node2Exists, Node2Exists},
					  {lineRate, LineRate}]),

	lists:foreach(
		fun(IDL2Link) ->
				lists:foreach(
					fun(NewLineRate) ->
							ct:pal("Action_1"),
							ok = nci_dci_actions:start_idl2_link(IDL2Link ++ [{packetRatio, PacketRatio},
																			  {lineRate, NewLineRate}]),

							ct:pal("Action_2"),
							receive_time_sync_ind(IDL2Link, PacketRatio, LineRate),

							ct:pal("Action_3")
					end,
					AllLineRates),

				lists:foreach(
					fun(NewPacketRatio) ->
							ct:pal("Action_4"),
							ok = nci_dci_actions:start_idl2_link(IDL2Link ++ [{packetRatio, NewPacketRatio},
																			  {lineRate, LineRate}]),

							ct:pal("Action_5"),
							receive_time_sync_ind(IDL2Link, PacketRatio, LineRate),

							ct:pal("Action_6")
					end,
					AllPacketRatios),

				ct:pal("Action_7"),
				verify_idl2_link_up(IDL2Link ++ [{packetRatio, PacketRatio},
												 {lineRate, LineRate}]),
				verify_idl2_link_up_leaf(IDL2Link ++ [{packetRatio, PacketRatio},
													  {lineRate, LineRate},
													  {node2Exists, Node2Exists},
													  {loadLMC, false}]),

				ct:pal("Action_8")
		end,
		IDL2Links),

	stop_idl2_links([{idl2Links, IDL2Links},
					 {node2Exists, Node2Exists}]),

	%% Check for unexpected signals
	nci_common_utils:check_outstanding_faults().

%%------------------------------------------------------------------------------
%% $Id DCI_IDL2_START12
%%
%% $Header
%%  IDL2 Link - Start IDL2 Link: On radio port, CPRI link not operational
%%
%% $Description
%%  Verifies that it is possible to start an IDL2 link on a port where a radio is connected
%%  but with a non-operational CPRI link. We expect a RICM_START_IDL2_LINK_CFM signal, 
%%  but then no RICM_START_IDL2_LINK_IND.
%%  Then attempt to set up the CPRI link to the radio and verify it's working.
%%
%% $Requirements
%%  TBD
%%
%% $HW config
%%  At least one radio
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  The DU BC is in state starting
%%  DP LMC is loaded
%%  DCI connection establish performed
%%  Subscribe DCI faults
%%
%% $Action_1
%%  Send RICM_START_IDL2_LINK_REQ with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%  * farEndDuId = <read from config file>
%%  * farEndPortNo = <read from config file>
%%  * packetRatio = 1
%%  * lineRate = 2
%%
%% $Result_1
%%  RICM_START_IDL2_LINK_CFM is received with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%
%% $Action_2
%%  Wait for a RICM_START_IDL2_LINK_IND signal.
%%
%% $Result_2
%%  RICM_START_IDL2_LINK_IND is never received.
%%
%% $Action_3
%%  Send RICM_STOP_IDL2_LINK_REQ with parameters:
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%
%% $Result_3
%%  RICM_STOP_IDL2_LINK_CFM is received with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%
%% $Action_4
%%  Verify that the IDL2 link is back in RX mode by calling verify_idl2_link_down().
%%
%% $Result_4
%%  IDL2 link is back in RX mode.
%%
%% $Action_5
%%  Send RICM_START_CPRI_LINK_REQ with parameters:
%%  * ruId = <read from config file>
%%  * portNo = <read from config file>
%%  * cascadeNo = <read from config file>
%%  * primary = 1
%%
%% $Result_5a
%%  RICM_START_CPRI_LINK_CFM is received with parameters: 
%%  * ruId = <read from config file>
%%
%% $Result_5b
%%  RICM_START_CPRI_LINK_IND is received with parameters: 
%%  * ruId = <read from config file>
%%  * availStatus = 1
%%
%% $Action_6
%%  Send RICM_ADD_RADIO_CTL_REQ with parameters:
%%  * ruId = <read from config file>
%%
%% $Result_6a
%%  RICM_ADD_RADIO_CTL_CFM is received with parameters: 
%%  * ruId = <read from config file>
%%
%% $Result_6b
%%  RICM_ADD_RADIO_CTL_IND is received with parameters: 
%%  * ruId = <read from config file>
%%  * connStatus = 1
%%
%% $Action_7
%%  Verify that the CPRI link is up by executing lmclist on the RU.
%%
%% $Result_7
%%  The RU responds with a valid list of LMCs.
%%
%% $Postcondition
%%  Reset CPRI link.
%%
%% $End
%%
%% Review:
%% -
%%
%% Revision history:
%%   2013-07-15 ebacemi
%%     First version
%%
%%------------------------------------------------------------------------------
dci_idl2_start12() ->
	[{userdata,[{wp, ""},
				{requirement, "TBD"},
				{slogan, "IDL2 Link - Start IDL2 Link: On radio port, CPRI link not operational"},
				{hwConfig, hwConfigF}]}].

dci_idl2_start12(_Config) ->
	ct:pal("dci_idl2_start12"),

	subscribe_states(),

	Radio = nci_ricm_utils:get_first_radio([{excludePortNos, [1, 2]}]),
	PortNo = proplists:get_value(portNo, Radio),
	RuLnhPath = proplists:get_value(ruLnhPath, Radio),

	IDL2Link = [{nearEndDuId, 1}, 
				{nearEndPortNo, PortNo},
				{farEndDuId, 2},
				{farEndPortNo, 3}],

	nci_bci_states:set_state([{state, starting_lmc_loaded}]),

	ok = nci_dci_actions:conn_establish([]),
	ok = nci_dci_actions:subscribe_faults([]),

	ct:pal("Action_1"),
	ok = nci_dci_actions:start_idl2_link(IDL2Link ++ [{packetRatio, 1},
													  {lineRate, ?IDL2_LINE_RATE_2_5G}]),

	ct:pal("Action_2"),
	{error, timeout} = osegw:recv(?OSE_GW_DEAMON_1, [?RICM_START_IDL2_LINK_IND], 30*1000),

	ct:pal("Action_3"),
	%% Stop the link in order to go back to RX only
	ok = nci_dci_actions:stop_idl2_link(IDL2Link),

	ct:pal("Action_4"),
	verify_idl2_link_down(IDL2Link),

	ct:pal("Action_5"),
	ok = nci_dci_actions:start_cpri_link(Radio),
	ok = nci_dci_actions:cpri_link_ind(Radio ++ [{availStatus, 1}]),

	ct:pal("Action_6"),
	ok = nci_dci_actions:add_radio_control(Radio),
	ok = nci_dci_actions:radio_control_ind(Radio ++ [{connStatus, 1}]),

	ct:pal("Action_7"),
	nci_common_utils:coli_cmd("lhsh " ++ RuLnhPath ++ " lmclist", "SlotProt State"),

	ok = nci_dci_actions:reset_cpri_link(Radio),
	ok = nci_dci_actions:reset_cpri_link_ind(Radio),

	%% Check for unexpected signals
	nci_common_utils:check_outstanding_faults().

%%------------------------------------------------------------------------------
%% $Id DCI_IDL2_START13
%%
%% $Header
%%  IDL2 Link - Start IDL2 Link: On radio port, CPRI link operational
%%
%% $Description
%%  Verifies that it is not possible to start an IDL2 link on a port where a radio is connected
%%  with an operational CPRI link.
%%
%% $Requirements
%%  TBD
%%
%% $HW config
%%  At least one radio
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  The DU BC is in state starting
%%  DP LMC is loaded
%%  DCI connection establish performed
%%  Subscribe DCI faults
%%  CPRI link and O&M link to the radio is up.
%%
%% $Action_1
%%  Send RICM_START_IDL2_LINK_REQ with parameters: 
%%  * nearEndDuId = 1
%%  * nearEndPortNo = <port where radio is connected>
%%  * farEndDuId = 2
%%  * farEndPortNo = 3
%%  * packetRatio = 1
%%  * lineRate = 2
%%
%% $Result_1
%%  RICM_START_IDL2_LINK_REJ is received with parameters: 
%%  * errorCode = UNSUCCESSFUL
%%  * errorDescription = "CPRI link already setup on this port"
%%
%% $Action_2
%%  Verify that the CPRI link to the radio is still up by
%%  running the lmclist command.
%%
%% $Result_2
%%  lmclist returns correct result.
%%
%% $Postcondition
%%  Reset CPRI link.
%%
%% $End
%%
%% Review:
%% -
%%
%% Revision history:
%%   2013-07-15 ebacemi
%%     First version
%%
%%   2013-11-04 emanssa
%%     Update in order to new ErrorDescription
%%
%%------------------------------------------------------------------------------
dci_idl2_start13() ->
	[{userdata,[{wp, ""},
				{requirement, "TBD"},
				{slogan, "IDL2 Link - Start IDL2 Link: On radio port, CPRI link operational"},
				{hwConfig, hwConfigF}]}].

dci_idl2_start13(_Config) ->
	ct:pal("dci_idl2_start13"),

	subscribe_states(),

	Radio = nci_ricm_utils:get_first_radio([{excludePortNos, [1, 2]}]),
	PortNo = proplists:get_value(portNo, Radio),
	RuLnhPath = proplists:get_value(ruLnhPath, Radio),

	nci_bci_states:set_state([{state, starting_lmc_loaded}]),

	ok = nci_dci_actions:conn_establish([]),
	ok = nci_dci_actions:subscribe_faults([]),

	%% Start CPRI link
	ok = nci_dci_actions:start_cpri_link(Radio),
	ok = nci_dci_actions:cpri_link_ind(Radio ++ [{availStatus, 1}]),

	%% Start O&M link
	nci_dci_actions:add_radio_control(Radio),
	nci_dci_actions:radio_control_ind(Radio ++ [{connStatus, 1}]),

	ct:pal("Action_1"),
	ok = nci_dci_actions:start_idl2_link([{expectedSigNo, ?RICM_START_IDL2_LINK_REJ},
										  {errorCode, ?ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL},
										  {errorDescription, {regexp, "CPRI link already setup on this port"}},
										  {nearEndDuId, 1}, 
										  {nearEndPortNo, PortNo},
										  {farEndDuId, 2},
										  {farEndPortNo, 3},
										  {packetRatio, 1},
										  {lineRate, ?IDL2_LINE_RATE_2_5G}]),

	ct:pal("Action_2"),
	nci_common_utils:coli_cmd("lhsh " ++ RuLnhPath ++ " lmclist", "SlotProt State"),

	ok = nci_dci_actions:reset_cpri_link(Radio),
	ok = nci_dci_actions:reset_cpri_link_ind(Radio),

	%% Check for unexpected signals
	nci_common_utils:check_outstanding_faults().


%%------------------------------------------------------------------------------
%% $Id DCI_IDL2_START15
%%
%% $Header
%%  IDL2 Link - Start IDL2 Link: Same NearEndDuId and FarEndDuId
%%
%% $Description
%%  Verifies that RICM sends the correct reject signal when specifying the same 
%%  value for nearEndDuId and farEndDuId.
%%
%% $Requirements
%%  TBD
%%
%% $HW config
%%  Any
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  The DU BC is in state starting
%%  DP LMC is loaded
%%  DCI connection establish performed
%%  Subscribe DCI faults
%%
%% $Action_1
%%  Send RICM_START_IDL2_LINK_REQ with parameters: 
%%  * nearEndDuId = 1
%%  * nearEndPortNo = 3
%%  * farEndDuId = 1
%%  * farEndPortNo = 3
%%  * packetRatio = 1
%%  * lineRate = 2
%%
%% $Result_1
%%  RICM_START_IDL2_LINK_REJ is received with parameters: 
%%  * errorCode = UNSUCCESSFUL
%%  * errorDescription = "nearEndDuId and farEndDuId are identical"
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%% -
%%
%% Revision history:
%%   2013-07-15 ebacemi
%%     First version
%%
%%------------------------------------------------------------------------------
dci_idl2_start15() ->
	[{userdata,[{wp, ""}, 
				{requirement, "TBD"},
				{slogan, "IDL2 Link - Start IDL2 Link: Same NearEndDuId and FarEndDuId"}]}].

dci_idl2_start15(_Config) ->
	ct:pal("dci_idl2_start15"),

	subscribe_states(),

	nci_bci_states:set_state([{state, starting_lmc_loaded}]),

	ok = nci_dci_actions:conn_establish([]),
	ok = nci_dci_actions:subscribe_faults([]),

	ct:pal("Action_1"),
	ok = nci_dci_actions:start_idl2_link([{expectedSigNo, ?RICM_START_IDL2_LINK_REJ},
										  {errorCode, ?ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL},
										  {errorDescription, {regexp, "nearEndDuId and farEndDuId are identical"}},
										  {nearEndDuId, 1},
										  {nearEndPortNo, 3},
										  {farEndDuId, 1},
										  {farEndPortNo, 3},
										  {packetRatio, 1},
										  {lineRate, ?IDL2_LINE_RATE_2_5G}]),

	%% Check for unexpected signals
	nci_common_utils:check_outstanding_faults().

%%------------------------------------------------------------------------------
%% $Id DCI_IDL2_START16
%%
%% $Header
%%  IDL2 Link - Start IDL2 Link: 5G on max 2.5G link
%%
%% $Description
%%  Verifies that it is possible to send RICM_START_IDL2_LINK_REQ with lineRate = 5G on a link
%%  that supports maximum 2.5G. The link is then expected to come up at 2.5G.
%%
%% $Requirements
%%  TBD
%%
%% $HW config
%%  At least one IDL2 link (max 2.5G)
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  The DU BC is in state starting
%%  DP LMC is loaded
%%  DCI connection establish performed
%%  Subscribe DCI faults
%%
%% $Action_1
%%  Send RICM_START_IDL2_LINK_REQ with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%  * farEndDuId = <read from config file>
%%  * farEndPortNo = <read from config file>
%%  * packetRatio = 1
%%  * lineRate = IDL2_LINE_RATE_5G
%%
%% $Result_1
%%  RICM_START_IDL2_LINK_CFM is received with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%
%% $Action_2
%%  Wait for a RICM_START_IDL2_LINK_IND signal.
%%
%% $Result_2
%%  RICM_START_IDL2_LINK_IND is received with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%  * packetRatio = 1
%%  * lineRate = <don't care>
%%  * availStatus = RICM_IDL2_LINK_AVAILABLE
%%
%% $Action_3
%%  Read the lineRate from Result_2 and verify that it is 2.5G.
%%
%% $Result_3
%%  The lineRate in Result_2 is correct.
%%
%% $Action_4
%%  Wait for a RICM_START_IDL2_LINK_IND signal.
%%
%% $Result_4
%%  RICM_START_IDL2_LINK_IND is received with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%  * packetRatio = 1
%%  * lineRate = <same as in Result_2>
%%  * availStatus = RICM_IDL2_LINK_AVAILABLE_SYNC
%%
%% $Action_5
%%  Call verify_idl2_link_up on Branch node to verify that 
%%  CPRI registers have correct values.
%%
%% $Result_5
%%  Registers have correct values.
%%
%% $Action_6
%%  Call verify_idl2_link_up on Leaf node to verify that 
%%  CPRI registers have correct values.
%%
%% $Result_6
%%  Registers have correct values.
%%
%% $Action_7
%%  Send RICM_STOP_IDL2_LINK_REQ with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%
%% $Result_7
%%  RICM_STOP_IDL2_LINK_CFM is received with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%
%% $Action_8
%%  Call verify_idl2_link_down on Branch node to verify that 
%%  CPRI registers have correct values.
%%
%% $Result_8
%%  Registers have correct values.
%%
%% $Action_9
%%  Call verify_idl2_link_down on Leaf node to verify that 
%%  CPRI registers have correct values.
%%
%% $Result_9
%%  Registers have correct values.
%%
%% $Action_10
%%  Repeat Action_1 to Action_9 for the remaining IDL2 links
%%
%% $Result_10
%%  -
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%% -
%%
%% Revision history:
%%   2013-08-29 ebacemi
%%     First version
%%
%%   2014-01-20 ebacemi
%%     Updated for WP6.1
%%
%%------------------------------------------------------------------------------
dci_idl2_start16() ->
	[{userdata,[{wp, ""},
				{requirement, "TBD"},
				{slogan, "IDL2 Link - Start IDL2 Link: 5G on max 2.5G link"},
				{hwConfig, hwConfigIDL2_D}]}].

dci_idl2_start16(_Config) ->
	ct:pal("dci_idl2_start16"),
	idl2_link_setup(?IDL2_LINE_RATE_5G, starting_lmc_loaded, ?IDL2_LINE_RATE_2_5G).

%%------------------------------------------------------------------------------
%% $Id DCI_IDL2_START17
%%
%% $Header
%%  IDL2 Link - Start IDL2 Link: 10G on max 2.5G link
%%
%% $Description
%%  Verifies that it is possible to send RICM_START_IDL2_LINK_REQ with lineRate = 10G on a link
%%  that supports maximum 2.5G. The link is then expected to come up at 2.5G.
%%
%% $Requirements
%%  TBD
%%
%% $HW config
%%  At least one IDL2 link (max 2.5G)
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  The DU BC is in state starting
%%  DP LMC is loaded
%%  DCI connection establish performed
%%  Subscribe DCI faults
%%
%% $Action_1
%%  Send RICM_START_IDL2_LINK_REQ with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%  * farEndDuId = <read from config file>
%%  * farEndPortNo = <read from config file>
%%  * packetRatio = 1
%%  * lineRate = IDL2_LINE_RATE_10G
%%
%% $Result_1
%%  RICM_START_IDL2_LINK_CFM is received with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%
%% $Action_2
%%  Wait for a RICM_START_IDL2_LINK_IND signal.
%%
%% $Result_2
%%  RICM_START_IDL2_LINK_IND is received with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%  * packetRatio = 1
%%  * lineRate = <don't care>
%%  * availStatus = RICM_IDL2_LINK_AVAILABLE
%%
%% $Action_3
%%  Read the lineRate from Result_2 and verify that it is 2.5G.
%%
%% $Result_3
%%  The lineRate in Result_2 is correct.
%%
%% $Action_4
%%  Wait for a RICM_START_IDL2_LINK_IND signal.
%%
%% $Result_4
%%  RICM_START_IDL2_LINK_IND is received with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%  * packetRatio = 1
%%  * lineRate = <same as in Result_2>
%%  * availStatus = RICM_IDL2_LINK_AVAILABLE_SYNC
%%
%% $Action_5
%%  Call verify_idl2_link_up on Branch node to verify that 
%%  CPRI registers have correct values.
%%
%% $Result_5
%%  Registers have correct values.
%%
%% $Action_6
%%  Call verify_idl2_link_up on Leaf node to verify that 
%%  CPRI registers have correct values.
%%
%% $Result_6
%%  Registers have correct values.
%%
%% $Action_7
%%  Send RICM_STOP_IDL2_LINK_REQ with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%
%% $Result_7
%%  RICM_STOP_IDL2_LINK_CFM is received with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%
%% $Action_8
%%  Call verify_idl2_link_down on Branch node to verify that 
%%  CPRI registers have correct values.
%%
%% $Result_8
%%  Registers have correct values.
%%
%% $Action_9
%%  Call verify_idl2_link_down on Leaf node to verify that 
%%  CPRI registers have correct values.
%%
%% $Result_9
%%  Registers have correct values.
%%
%% $Action_10
%%  Repeat Action_1 to Action_9 for the remaining IDL2 links
%%
%% $Result_10
%%  -
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%% -
%%
%% Revision history:
%%   2013-08-29 ebacemi
%%     First version
%%
%%   2014-01-20 ebacemi
%%     Updated for WP6.1
%%
%%------------------------------------------------------------------------------
dci_idl2_start17() ->
	[{userdata,[{wp, ""},
				{requirement, "TBD"},
				{slogan, "IDL2 Link - Start IDL2 Link: 10G on max 2.5G link"},
				{hwConfig, hwConfigIDL2_D}]}].

dci_idl2_start17(_Config) ->
	ct:pal("dci_idl2_start17"),
	idl2_link_setup(?IDL2_LINE_RATE_10G, starting_lmc_loaded, ?IDL2_LINE_RATE_2_5G).

%%------------------------------------------------------------------------------
%% $Id DCI_IDL2_START18
%%
%% $Header
%%  IDL2 Link - Start IDL2 Link: 10G on max 5G link
%%
%% $Description
%%  Verifies that it is possible to send RICM_START_IDL2_LINK_REQ with lineRate = 10G on a link
%%  that supports maximum 5G. The link is then expected to come up at 2.5G or 5G.
%%
%% $Requirements
%%  TBD
%%
%% $HW config
%%  At least one IDL2 link (max 5G)
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  The DU BC is in state starting
%%  DP LMC is loaded
%%  DCI connection establish performed
%%  Subscribe DCI faults
%%
%% $Action_1
%%  Send RICM_START_IDL2_LINK_REQ with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%  * farEndDuId = <read from config file>
%%  * farEndPortNo = <read from config file>
%%  * packetRatio = 1
%%  * lineRate = IDL2_LINE_RATE_10G
%%
%% $Result_1
%%  RICM_START_IDL2_LINK_CFM is received with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%
%% $Action_2
%%  Wait for a RICM_START_IDL2_LINK_IND signal.
%%
%% $Result_2
%%  RICM_START_IDL2_LINK_IND is received with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%  * packetRatio = 1
%%  * lineRate = <don't care>
%%  * availStatus = RICM_IDL2_LINK_AVAILABLE
%%
%% $Action_3
%%  Read the lineRate from Result_2 and verify that it is 2.5G or 5G.
%%
%% $Result_3
%%  The lineRate in Result_2 is correct.
%%
%% $Action_4
%%  Wait for a RICM_START_IDL2_LINK_IND signal.
%%
%% $Result_4
%%  RICM_START_IDL2_LINK_IND is received with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%  * packetRatio = 1
%%  * lineRate = <same as in Result_2>
%%  * availStatus = RICM_IDL2_LINK_AVAILABLE_SYNC
%%
%% $Action_5
%%  Call verify_idl2_link_up on Branch node to verify that 
%%  CPRI registers have correct values.
%%
%% $Result_5
%%  Registers have correct values.
%%
%% $Action_6
%%  Call verify_idl2_link_up on Leaf node to verify that 
%%  CPRI registers have correct values.
%%
%% $Result_6
%%  Registers have correct values.
%%
%% $Action_7
%%  Send RICM_STOP_IDL2_LINK_REQ with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%
%% $Result_7
%%  RICM_STOP_IDL2_LINK_CFM is received with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%
%% $Action_8
%%  Call verify_idl2_link_down on Branch node to verify that 
%%  CPRI registers have correct values.
%%
%% $Result_8
%%  Registers have correct values.
%%
%% $Action_9
%%  Call verify_idl2_link_down on Leaf node to verify that 
%%  CPRI registers have correct values.
%%
%% $Result_9
%%  Registers have correct values.
%%
%% $Action_10
%%  Repeat Action_1 to Action_9 for the remaining IDL2 links
%%
%% $Result_10
%%  -
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%% -
%%
%% Revision history:
%%   2013-08-29 ebacemi
%%     First version
%%
%%   2014-01-20 ebacemi
%%     Updated for WP6.1
%%
%%------------------------------------------------------------------------------
dci_idl2_start18() ->
	[{userdata,[{wp, ""},
				{requirement, "TBD"},
				{slogan, "IDL2 Link - Start IDL2 Link: 10G on max 5G link"},
				{hwConfig, hwConfigIDL2_E}]}].

dci_idl2_start18(_Config) ->
	ct:pal("dci_idl2_start18"),
	idl2_link_setup(?IDL2_LINE_RATE_10G, starting_lmc_loaded, ?IDL2_LINE_RATE_5G).

%%------------------------------------------------------------------------------
%% $Id DCI_IDL2_START19
%%
%% $Header
%%  IDL2 Link - Start IDL2 Link: Different farEndPortNo
%%
%% $Description
%%  Verifies that it is not possible to start an IDL2 link when passing in an incorrect
%%  farEndPortNo. The farEndPortNo should be within the valid range, but it shouldn't 
%%  match the physical configuration.
%%
%% $Requirements
%%  TBD
%%
%% $HW config
%%  At least one 2.5G IDL2 link
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  The DU BC is in state starting
%%  DP LMC is loaded
%%  DCI connection establish performed
%%  Subscribe DCI faults
%%
%% $Action_1
%%  Send RICM_START_IDL2_LINK_REQ with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%  * farEndDuId = <read from config file>
%%  * farEndPortNo = <pick a different one than the one from the config file>
%%  * packetRatio = 1
%%  * lineRate = 2
%%
%% $Result_1
%%  RICM_START_IDL2_LINK_CFM is received with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%
%% $Action_2
%%  Wait 60s for a RICM_START_IDL2_LINK_IND signal.
%%
%% $Result_2
%%  No RICM_START_IDL2_LINK_IND signal is received.
%%
%% $Action_3
%%  Send RICM_STOP_IDL2_LINK_REQ with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%
%% $Result_3
%%  RICM_STOP_IDL2_LINK_CFM is received with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%
%% $Action_4
%%  Send RICM_START_IDL2_LINK_REQ with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%  * farEndDuId = <read from config file>
%%  * farEndPortNo = <read from config file>
%%  * packetRatio = 1
%%  * lineRate = 2
%%
%% $Result_4
%%  RICM_START_IDL2_LINK_CFM is received with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%
%% $Action_5
%%  Wait for a RICM_START_IDL2_LINK_IND signal.
%%
%% $Result_5
%%  RICM_START_IDL2_LINK_IND is received with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%  * packetRatio = 1
%%  * lineRate = <don't care>
%%  * availStatus = RICM_IDL2_LINK_AVAILABLE
%%
%% $Action_6
%%  When leaf DU is type3:
%%  Wait for a RICM_START_IDL2_LINK_IND signal.
%%
%% $Result_6
%%  RICM_START_IDL2_LINK_IND is received with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%  * packetRatio = 1
%%  * lineRate = <same as from Result_5>
%%  * availStatus = RICM_IDL2_LINK_AVAILABLE_SYNC
%%
%% $Action_7
%%  Call verify_idl2_link_up on Branch and Leaf nodes to verify that 
%%  CPRI registers have correct values.
%%
%% $Result_7
%%  Registers have correct values.
%%
%% $Postcondition
%%  Stop IDL2 link
%%
%% $End
%%
%% Review:
%% -
%%
%% Revision history:
%%   2013-10-17 ebacemi
%%     First version
%%
%%   2014-01-20 ebacemi
%%     Updated for WP6.1
%%
%%------------------------------------------------------------------------------
dci_idl2_start19() ->
	[{userdata,[{wp, ""},
				{requirement, "TBD"},
				{slogan, "IDL2 Link -  Start IDL2 Link: Different farEndPortNo"},
				{hwConfig, hwConfigIDL2_A}]}].

dci_idl2_start19(_Config) ->
	ct:pal("dci_idl2_start19"),

	subscribe_states(),

	Node2Exists = nci_ricm_utils:node_exists(node2),

	nci_bci_states:set_state([{state, starting_lmc_loaded}]),

	ok = nci_dci_actions:conn_establish([]),
	ok = nci_dci_actions:subscribe_faults([]),

	IDL2Link = nci_ricm_utils:get_first_idl2_link(),	

	ct:pal("IDL2 link used: ~p", [IDL2Link]),

	FarEndPortNo = proplists:get_value(farEndPortNo, IDL2Link),
	%% Pick the first invalid farEndPortNo
	InvalidFarEndPortNo = lists:nth(1, lists:subtract([3, 4, 5, 6], [FarEndPortNo])),
	PacketRatio = 1,
	LineRate = ?IDL2_LINE_RATE_2_5G,

	ct:pal("Action_1"),
	ok = nci_dci_actions:start_idl2_link(proplists:delete(farEndPortNo, IDL2Link) ++ 
											 [{farEndPortNo, InvalidFarEndPortNo}, 
											  {packetRatio, PacketRatio},
											  {lineRate, LineRate}]),
	
	ct:pal("Action_2"),
	ct:pal("Wait 1 minute for a RICM_START_IDL2_LINK_IND signal. A timeout is expected"),
	{error, timeout} = osegw:recv(?OSE_GW_DEAMON_1, [?RICM_START_IDL2_LINK_IND], 60*1000),

	ct:pal("Action_3"),
	ok = nci_dci_actions:stop_idl2_link(IDL2Link),

	wait_for_leaf(Node2Exists),

	ct:pal("Action_4"),
	ok = nci_dci_actions:start_idl2_link(IDL2Link ++ [{packetRatio, PacketRatio},
													  {lineRate, LineRate}]),
	ct:pal("Action_5"),
	{ok, Ind} = nci_dci_actions:idl2_link_ind(IDL2Link ++ [{packetRatio, PacketRatio},
														   {lineRate, '_'},
														   {availStatus, ?RICM_IDL2_LINK_AVAILABLE}]),
	ReceivedLineRate = Ind#'RicmStartIdl2LinkIndS'.lineRate,

	ct:pal("Action_6"),
	receive_time_sync_ind(IDL2Link, PacketRatio, ReceivedLineRate),

	ct:pal("Action_7"), 
	verify_idl2_link_up(IDL2Link ++ [{packetRatio, PacketRatio},
									 {lineRate, ReceivedLineRate}]),
	verify_idl2_link_up_leaf(IDL2Link ++ [{packetRatio, PacketRatio},
										  {lineRate, ReceivedLineRate},
										  {node2Exists, Node2Exists}]),

	ok = nci_dci_actions:stop_idl2_link(IDL2Link),

	wait_for_leaf(Node2Exists),

	%% Check for unexpected signals
	nci_common_utils:check_outstanding_faults().

%%------------------------------------------------------------------------------
%% $Id DCI_IDL2_START20
%%
%% $Header
%%  IDL2 Link - Start IDL2 Link: IDL2 link already started in leaf mode
%%
%% $Description
%%  Verifies that it is not possible to start an IDL2 link on a port where the
%%  IDL2 link is already started in leaf mode.
%%
%% $Requirements
%%  TBD
%%
%% $HW config
%%  At least one IDL2 link
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  IDL2 links started to all leaf DUs
%%  The DU BC is in state starting on all DUs
%%  DP LMC is loaded on all DUs
%%  DCI connection establish performed on all DUs
%%  Subscribe DCI faults performed on all DUs
%%
%% $Action_1
%%  Send RICM_START_IDL2_LINK_REQ on leaf DU with parameters: 
%%  * nearEndDuId = <farEndDuId from config file>
%%  * nearEndPortNo = <farEndPortNo from from config file>
%%  * farEndDuId = <nearEndDuId from config file>
%%  * farEndPortNo = <nearEndPortNo from config file>
%%  * packetRatio = 1
%%  * lineRate = IDL2_LINE_RATE_2_5G
%%
%% $Result_1
%%  RICM_START_IDL2_LINK_REJ is received with parameters: 
%%  * errorCode = UNSUCCESSFUL
%%  * errorDescription = "IDL2 link already started in leaf mode"
%%
%% $Action_2
%%  Repeat Action_1 for the remaining IDL2 links
%%
%% $Result_2
%%  -
%%
%% $Action_3
%%  In order to verify that all IDL2 links are still operational, 
%%  check FPGA registers on all branch and leaf DUs and verify that 
%%  they have correct values.
%%
%% $Result_3
%%  Registers have correct values.
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%% -
%%
%% Revision history:
%%   2013-10-30 ebacemi
%%     First version
%%
%%------------------------------------------------------------------------------
dci_idl2_start20() ->
	[{userdata,[{wp, ""},
				{requirement, "TBD"},
				{slogan, "IDL2 Link - Start IDL2 Link: IDL2 link already started in leaf mode"},
				{hwConfig, hwConfigIDL2_A}]}].

dci_idl2_start20(_Config) ->
	ct:pal("dci_idl2_start20"),

	subscribe_states(),

	LineRate = ?IDL2_LINE_RATE_2_5G,
	PacketRatio = 1,

	nci_bci_states:set_state([{state, starting_lmc_loaded}]),

	ok = nci_dci_actions:conn_establish([]),
	ok = nci_dci_actions:subscribe_faults([]),

	IDL2Links = nci_ricm_utils:get_all_idl2_links(),

	start_idl2_links([{idl2Links, IDL2Links}]),

	lists:foreach(
		fun(IDL2Link) ->
				FarEndDuLnhPath = proplists:get_value(farEndDuLnhPath, IDL2Link),
				DcServer = get_dc_server(FarEndDuLnhPath),

				ct:pal("Action_1"),
				ok = nci_dci_actions:start_idl2_link([{nearEndPortNo, proplists:get_value(farEndPortNo, IDL2Link)},
													  {nearEndDuId, proplists:get_value(farEndDuId, IDL2Link)},
													  {farEndPortNo, proplists:get_value(nearEndPortNo, IDL2Link)},
													  {farEndDuId, proplists:get_value(nearEndDuId, IDL2Link)},
													  {packetRatio, PacketRatio},
													  {lineRate, LineRate},
													  {dcServer, DcServer},
													  {expectedSigNo, ?RICM_START_IDL2_LINK_REJ},
													  {errorCode, ?ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL},
													  {errorDescription, {regexp, "IDL2 link already started in leaf mode"}}]),

				ct:pal("Action_2")
		end,
		IDL2Links),

	ct:pal("Action_3"),
	lists:foreach(
		fun(IDL2Link) ->
				verify_idl2_link_up(IDL2Link ++ [{packetRatio, PacketRatio},
												 {lineRate, LineRate}]),
				verify_idl2_link_up_leaf(IDL2Link ++ [{packetRatio, PacketRatio},
													  {lineRate, LineRate},
													  {loadLMC, false}])
		end,
		IDL2Links),

	stop_idl2_links([{idl2Links, IDL2Links}]),

	%% Check for unexpected signals
	nci_common_utils:check_outstanding_faults().

%%------------------------------------------------------------------------------
%% $Id DCI_IDL2_START21
%%
%% $Header
%%  IDL2 Link - Start IDL2 Link: Different nearEndDuId, farEndDuId and farEndPortNo
%%
%% $Description
%%  Attempts to start an IDL2 link on a port where IDL2 is already operational.
%%  Different values for nearEndDuId, farEndDuId and farEndPortNo are exercised 
%%  when starting the second link. In all cases a REJ is expected.
%%
%% $Requirements
%%  TBD
%%
%% $HW config
%%  One 2.5G IDL2 link
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  The DU BC is in state starting
%%  DP LMC is loaded
%%  DCI connection establish performed
%%  Subscribe DCI faults
%%  All available IDL2 links are started
%%
%% $Action_1
%%  Send RICM_START_IDL2_LINK_REQ with parameters: 
%%  * nearEndDuId = <a different value than the existing IDL2 link>
%%  * nearEndPortNo = <same as existing IDL2 link>
%%  * farEndDuId = <a different value than the existing IDL2 link>
%%  * farEndPortNo = <a different value than the existing IDL2 link>
%%  * packetRatio = 1
%%  * lineRate = 2
%%
%% $Result_1
%%  RICM_START_IDL2_LINK_REJ is received with parameters: 
%%  * nearEndDuId = <same as in Action_1>
%%  * nearEndPortNo = <same as in Action_1>
%%  * errorCode = UNSUCCESSFUL
%%  * errorDescription = "Link already setup with other parameters"
%%
%% $Action_2
%%  Repeat Action_1 for nearEndDuId, farEndDuId and farEndPortNo.
%%
%% $Result_2
%%  -
%%
%% $Action_3
%%  Repeat Action_1 to Action_2 for all remaining IDL2 links.
%%
%% $Result_3
%%  -
%%
%% $Postcondition
%%  Stop all IDL2 links
%%
%% $End
%%
%% Review:
%% -
%%
%% Revision history:
%%   2013-11-06 EBACEMI
%%     First version
%%   2013-12-02 EBACEMI
%%     Changed DuId to PortNo in IDL2Link4
%%
%%------------------------------------------------------------------------------
dci_idl2_start21() ->
	[{userdata,[{wp, ""}, 
				{requirement, "TBD"},
				{slogan, "IDL2 Link -  Start IDL2 Link: Different nearEndDuId, farEndDuId and farEndPortNo"},
				{hwConfig, hwConfigIDL2_A}]}].

dci_idl2_start21(_Config) ->
	ct:pal("dci_idl2_start21"),

	subscribe_states(),

	Node2Exists = nci_ricm_utils:node_exists(node2),

	LineRate = ?IDL2_LINE_RATE_2_5G,
	PacketRatio = 1,

	IDL2Links = nci_ricm_utils:get_all_idl2_links(),

	nci_bci_states:set_state([{state, starting_lmc_loaded}]),

	ok = nci_dci_actions:conn_establish([]),
	ok = nci_dci_actions:subscribe_faults([]),

	start_idl2_links([{idl2Links, IDL2Links},
					  {node2Exists, Node2Exists}]),

	lists:foreach(
		fun(IDL2Link) ->
				%% Calculate new parameters
				%%
				%% nearEndDuId:  Increase value by 10 and make sure it doesn't exceed 63.
				%% farEndDuId:   Increase value by 10 and make sure it doesn't exceed 63.
				%% farEndPortNo: Pick the first value in the list [3, 4, 5, 6] that doesn't
				%%               match the existing farEndPortNo.
				NearEndDuId = (proplists:get_value(nearEndDuId, IDL2Link) + 10) rem 64,
				FarEndDuId = (proplists:get_value(farEndDuId, IDL2Link) + 10) rem 64,	
				FarEndPortNo = lists:nth(1, lists:subtract([3, 4, 5, 6], [proplists:get_value(farEndPortNo, IDL2Link)])),

				%% Construct new IDL2 links
				IDL2Link2 = proplists:delete(nearEndDuId, IDL2Link) ++ [{nearEndDuId, NearEndDuId}],
				IDL2Link3 = proplists:delete(farEndDuId, IDL2Link) ++ [{farEndDuId, FarEndDuId}],
				IDL2Link4 = proplists:delete(farEndPortNo, IDL2Link) ++ [{farEndPortNo, FarEndPortNo}],

				lists:foreach(
					fun(InvalidIDL2Link) ->
							ct:pal("Action_1"),
							ok = nci_dci_actions:start_idl2_link(InvalidIDL2Link ++ [{packetRatio, PacketRatio},
																					 {lineRate, LineRate},
																					 {expectedSigNo, ?RICM_START_IDL2_LINK_REJ},
																					 {errorCode, ?ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL},
																					 {errorDescription, {regexp, "Link already setup with other parameters"}}]),

							ct:pal("Action_2")
					end,
					[IDL2Link2, IDL2Link3, IDL2Link4]),

				ct:pal("Action_3")
		end,
		IDL2Links),

	stop_idl2_links([{idl2Links, IDL2Links},
					 {node2Exists, Node2Exists}]),

	%% Check for unexpected signals
	nci_common_utils:check_outstanding_faults().

%%------------------------------------------------------------------------------
%% $Id DCI_IDL2_START22
%%
%% $Header
%%  IDL2 Link - Start IDL2 Link: No SFP
%%
%% $Description
%%  Start IDL2 links on all ports that have no SFP inserted to verify that we get
%%  a "No SFP plugged in" fault.
%%
%% $Requirements
%%  TBD
%%
%% $External References
%%  -
%%
%% $HW Config
%%  No SFP on port C, D, E or F
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state starting.
%%  DP LMC is loaded.
%%  DCI connection establish performed.
%%  Subscribe DCI faults
%%
%% $Action_1
%%  Send RICM_START_IDL2_LINK_REQ with parameters:
%%  * nearEndPortNo = <unused port>
%%  * nearEndDuId = 1
%%  * farEndPortNo = 6
%%  * farEndDuId = 2
%%  * packetRatio = 1
%%  * lineRate = 2 (2.5Gbit)
%%
%% $Result_1
%%  RICM_START_IDL2_LINK_CFM is received with parameters:
%%  * nearEndPortNo = <unused port>
%%  * nearEndDuId = 1
%%
%% $Action_2
%%  Wait for a ELIB_DC_FAULT_IND signal
%%
%% $Result_2
%%  ELIB_DC_FAULT_IND is received with parameters:
%%  * faultId = ELIB_CONST_FH_FAULT_ID_LINK_FAILURE
%%  * faultDescription = "No SFP plugged in"
%%
%% $Action_3
%%  Send RICM_STOP_IDL2_LINK_REQ with parameters:
%%  * nearEndPortNo = <unused port>
%%  * nearEndDuId = 1
%%
%% $Result_3
%%  RICM_STOP_IDL2_LINK_CFM is received with parameters:
%%  * nearEndPortNo = <unused port>
%%  * nearEndDuId = 1
%%
%% $Action_4
%%  Wait for a ELIB_DC_FAULT_CEASE_IND signal
%%
%% $Result_4
%%  ELIB_DC_FAULT_CEASE_IND is received with parameters:
%%  * faultId = ELIB_CONST_FH_FAULT_ID_LINK_FAILURE
%%
%% $Action_5
%%  Repeat Action_1 to Action_4 for all remaining unused IDL2 ports
%%
%% $Result_5
%%  -
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Revision history:
%%  2014-01-14, EBACEMI
%%    First version
%%------------------------------------------------------------------------------
dci_idl2_start22() ->
	[{userdata,[{wp, ""},
				{requirement, "TBD"},
				{slogan, "IDL2 Link - Start IDL2 Link: No SFP"},
				{hwConfig, hwConfigJ}]}].
dci_idl2_start22(_Config) ->
	ct:pal("dci_idl2_start22"),

	subscribe_states(),

	UnusedIDL2Ports = nci_ricm_utils:get_all_unused_idl2_ports(),

	ct:pal("Unused idl2 ports: ~p~n", [UnusedIDL2Ports]),

	nci_bci_states:set_state([{state, starting_lmc_loaded}]),

	ok = nci_dci_actions:conn_establish([]),
	ok = nci_dci_actions:subscribe_faults([]),

	lists:foreach(
		fun({portNo, UnusedPortNo}) ->
				ct:pal("Action_1"),
				ok = nci_dci_actions:start_idl2_link([{nearEndPortNo, UnusedPortNo}]),
				
				ct:pal("Action_2"),
				nci_dci_actions:fault_ind([{faultId, ?ELIB_CONST_FH_FAULT_ID_LINK_FAILURE},
										   {faultDescription, {regexp, "No SFP plugged in"}}]),
				
				ct:pal("Action_3"),
				ok = nci_dci_actions:stop_idl2_link([{nearEndPortNo, UnusedPortNo}]),
				
				ct:pal("Action_4"),
				ok = nci_dci_actions:fault_cease_ind([{faultId, ?ELIB_CONST_FH_FAULT_ID_LINK_FAILURE}]),

				ct:pal("Action_5")
		end,
		UnusedIDL2Ports),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id DCI_IDL2_START23
%%
%% $Header
%%  IDL2 Link - Start IDL2 Link: 10G on max 5G link on DU2 in a triple configuration
%%
%% $Description
%%  Verifies that it is possible to send RICM_START_IDL2_LINK_REQ with lineRate = 10G on a link
%%  that supports maximum 5G. The link is then expected to come up at 2.5G or 5G. The link that
%%  is verified is the link between DU2 and DU3.
%%
%% $Requirements
%%  TBD
%%
%% $HW config
%%  At least one IDL2 link between DU1 and DU2
%%  At least one IDL2 link between DU1 and DU3
%%  At least one IDL2 link between DU2 and DU3 (max 5G)
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  The DU BC is in state starting
%%  DP LMC is loaded
%%  DCI connection establish performed
%%  Subscribe DCI faults
%%  Start IDL2 links to from DU1 to DU2 and DU3
%%
%% $Action_1
%%  Send RICM_START_IDL2_LINK_REQ on DU2 with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%  * farEndDuId = <read from config file>
%%  * farEndPortNo = <read from config file>
%%  * packetRatio = 1
%%  * lineRate = IDL2_LINE_RATE_10G
%%
%% $Result_1
%%  RICM_START_IDL2_LINK_CFM is receivedwith parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%
%% $Action_2
%%  Wait for a RICM_START_IDL2_LINK_IND signal.
%%
%% $Result_2
%%  RICM_START_IDL2_LINK_IND is received with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%  * packetRatio = 1
%%  * lineRate = <don't care>
%%  * availStatus = RICM_IDL2_LINK_AVAILABLE
%%
%% $Action_3
%%  Read the lineRate from Result_2 and verify that it is less than 10G.
%%
%% $Result_3
%%  The lineRate in Result_2 is correct.
%%
%% $Action_4
%%  Wait for a RICM_START_IDL2_LINK_IND signal.
%%
%% $Result_4
%%  RICM_START_IDL2_LINK_IND is received with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%  * packetRatio = 1
%%  * lineRate = <same as in Result_2>
%%  * availStatus = RICM_IDL2_LINK_AVAILABLE_SYNC
%%
%% $Action_5
%%  Call verify_idl2_link_up on DU2 to verify that 
%%  CPRI registers have correct values.
%%
%% $Result_5
%%  Registers have correct values.
%%
%% $Action_6
%%  Call verify_idl2_link_up on DU3 to verify that 
%%  CPRI registers have correct values.
%%
%% $Result_6
%%  Registers have correct values.
%%
%% $Postcondition
%%  Stop all IDL2 links
%%
%% $End
%%
%% Review:
%% -
%%
%% Revision history:
%%   2014-03-11 ebacemi
%%     First version
%%
%%------------------------------------------------------------------------------
dci_idl2_start23() ->
	[{userdata,[{wp, ""},
				{requirement, "TBD"},
				{slogan, "IDL2 Link - Start IDL2 Link: 10G on max 5G link on DU2 in a triple configuration"},
				{hwConfigDu0, hwConfigIDL2_A},
				{hwConfigDu1, hwConfigIDL2_E}]}].

dci_idl2_start23(_Config) ->
	ct:pal("dci_idl2_start23"),

	subscribe_states(),

	nci_bci_states:set_state([{state, starting_lmc_loaded}]),

	ok = nci_dci_actions:conn_establish([]),
	ok = nci_dci_actions:subscribe_faults([]),

	IDL2Links = nci_ricm_utils:get_all_idl2_links(),

	start_idl2_links([{idl2Links, IDL2Links}]),

	PacketRatio = 1,
	LineRate = ?IDL2_LINE_RATE_10G,
	ExpectedLineRate = ?IDL2_LINE_RATE_5G,
	IDL2Link5G = nci_ricm_utils:get_first_idl2_link([{maxLineRate, ExpectedLineRate},
													 {du, du1}]),

	NearEndDuLnhPath = proplists:get_value(nearEndDuLnhPath, IDL2Link5G),
	DcServer = get_dc_server(NearEndDuLnhPath),

	ct:pal("Action_1"),
	ok = nci_dci_actions:start_idl2_link(IDL2Link5G ++ [{dcServer, DcServer},
														{packetRatio, PacketRatio},
														{lineRate, LineRate}]),

	ct:pal("Action_2"),
	%% lineRate is "don't care" since RICM might set up the link with a different 
	%% line rate than the specified one.
	{ok, Ind} = nci_dci_actions:idl2_link_ind(IDL2Link5G ++ [{packetRatio, PacketRatio},
															 {lineRate, '_'},
															 {availStatus, ?RICM_IDL2_LINK_AVAILABLE}]),
	ReceivedLineRate = Ind#'RicmStartIdl2LinkIndS'.lineRate,

	ct:pal("Action_3"), 
	%% The received line rate must not be higher than the specified line rate or
	%% the maximum supported line rate.
	if ReceivedLineRate > ExpectedLineRate ->
			ct:fail("Line rate is greater than ~p", [ExpectedLineRate]);
	   true ->
			ok
	end,

	ct:pal("Action_4"), 
	receive_time_sync_ind(IDL2Link5G, PacketRatio, ReceivedLineRate),

	ct:pal("Action_5"),
	verify_idl2_link_up(IDL2Link5G ++ [{packetRatio, PacketRatio},
									   {lineRate, ReceivedLineRate}]),

	ct:pal("Action_6"),
	verify_idl2_link_up_leaf(IDL2Link5G ++ [{packetRatio, PacketRatio},
											{lineRate, ReceivedLineRate},
											{loadLMC, false}]),

	ok = nci_dci_actions:stop_idl2_link(IDL2Link5G ++ [{dcServer, DcServer}]),

	stop_idl2_links([{idl2Links, IDL2Links}]),

	%% Check that NO BC/DC_FAULT_IND is generated.
	nci_common_utils:check_outstanding_faults(2000).

%%------------------------------------------------------------------------------
%% $Id DCI_IDL2_STOP3
%%
%% $Header
%%  IDL2 Link - Stop IDL2 Link: State Disabled
%%
%% $Description
%%  Verifies that it is not possible to start an IDL2 link using
%%  the RICM_STOP_IDL2_LINK_REQ signal in state disabled.
%%
%% $Requirements
%%  TBD
%%
%% $HW config
%%  Any
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  The DU BC is in state disabled
%%  DP LMC is loaded
%%  DCI connection establish performed
%%  Subscribe DCI faults
%%
%% $Action_1
%%  Send RICM_STOP_IDL2_LINK_REQ with parameters: 
%%  * nearEndDuId = 1
%%  * nearEndPortNo = 3
%%
%% $Result_1
%%  RICM_STOP_IDL2_LINK_REJ is received with parameters: 
%%  * nearEndDuId = 1
%%  * nearEndPortNo = 3
%%  * errorCode = UNSUCCESSFUL
%%  * errorDescription = "Invalid O&M state"
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%% -
%%
%% Revision history:
%%   2013-07-15 ebacemi
%%     First version
%%
%%------------------------------------------------------------------------------
dci_idl2_stop3() ->
	[{userdata,[{wp, ""}, 
				{requirement, "TBD"},
				{slogan, "IDL2 Link - Stop IDL2 Link: State Disabled"}]}].

dci_idl2_stop3(_Config) ->
	ct:pal("dci_idl2_stop3"),
	dci_idl2_stop_rej(disabled, "Invalid O&M state").

%%------------------------------------------------------------------------------
%% $Id DCI_IDL2_STOP4
%%
%% $Header
%%  IDL2 Link - Stop IDL2 Link: State Starting LMC Not Loaded
%%
%% $Description
%%  Verifies that it is not possible to start an IDL2 link using
%%  the RICM_STOP_IDL2_LINK_REQ signal in state starting LMC not loaded.
%%
%% $Requirements
%%  TBD
%%
%% $HW config
%%  Any
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  The DU BC is in state starting
%%  DP LMC is not loaded
%%  DCI connection establish performed
%%  Subscribe DCI faults
%%
%% $Action_1
%%  Send RICM_STOP_IDL2_LINK_REQ with parameters: 
%%  * nearEndDuId = 1
%%  * nearEndPortNo = 3
%%
%% $Result_1
%%  RICM_STOP_IDL2_LINK_REJ is received with parameters: 
%%  * nearEndDuId = 1
%%  * nearEndPortNo = 3
%%  * errorCode = UNSUCCESSFUL
%%  * errorDescription = "DP not loaded"
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%% -
%%
%% Revision history:
%%   2013-07-15 ebacemi
%%     First version
%%
%%------------------------------------------------------------------------------
dci_idl2_stop4() ->
	[{userdata,[{wp, ""}, 
				{requirement, "TBD"},
				{slogan, "IDL2 Link - Start IDL2 Link (2.5G) State Starting LMC Not Loaded"}]}].

dci_idl2_stop4(_Config) ->
	ct:pal("dci_idl2_stop4"),
	dci_idl2_stop_rej(starting_lmc_not_loaded, "DP not loaded").

dci_idl2_stop_rej(State, ErrorDescription) ->
	{ok, session_up} = coli:subscribe_state(?SHELL_COMMAND),
	{ok, session_up} = osegw:subscribe_state(?OSE_GW_DEAMON_1),

	case State of
		disabled ->
			%% Need to load DP LMC before going to disabled state
			nci_bci_states:set_state([{state, starting_lmc_loaded}]);
		_ ->
			ok
	end,

	nci_bci_states:set_state([{state, State}]),

	ok = nci_dci_actions:conn_establish([]),
	ok = nci_dci_actions:subscribe_faults([]),

	ct:pal("Action_1"),
	ok = nci_dci_actions:stop_idl2_link([{nearEndDuId, 1}, 
										 {nearEndPortNo, 3},
										 {expectedSigNo, ?RICM_STOP_IDL2_LINK_REJ},
										 {errorCode, ?ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL},
										 {errorDescription, {regexp, ErrorDescription}}]),
	
	%% Check for unexpected signals
	nci_common_utils:check_outstanding_faults().

%%------------------------------------------------------------------------------
%% $Id DCI_IDL2_STOP5
%%
%% $Header
%%  IDL2 Link - Stop IDL2 Link: Invalid NearEndPortNo
%%
%% $Description
%%  Verifies that RICM sends the correct reject signal when specifying an invalid
%%  nearEndPortNo in RICM_STOP_IDL2_LINK_REQ.
%%
%% $Requirements
%%  TBD
%%
%% $HW config
%%  Any
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  The DU BC is in state starting
%%  DP LMC is loaded
%%  DCI connection establish performed
%%  Subscribe DCI faults
%%
%% $Action_1
%%  Send RICM_STOP_IDL2_LINK_REQ with parameters: 
%%  * nearEndDuId = 1
%%  * nearEndPortNo = <0, 1, 2, 7>
%%
%% $Result_1
%%  RICM_STOP_IDL2_LINK_REJ is received with parameters: 
%%  * errorCode = UNSUCCESSFUL
%%  * errorDescription = "Invalid nearEndPortNo"
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%% -
%%
%% Revision history:
%%   2013-07-15 ebacemi
%%     First version
%%
%%------------------------------------------------------------------------------
dci_idl2_stop5() ->
	[{userdata,[{wp, ""}, 
				{requirement, "TBD"},
				{slogan, "IDL2 Link - Stop IDL2 Link: Invalid NearEndPortNo"}]}].

dci_idl2_stop5(_Config) ->
	ct:pal("dci_idl2_stop5"),

	{ok, session_up} = coli:subscribe_state(?SHELL_COMMAND),
	{ok, session_up} = osegw:subscribe_state(?OSE_GW_DEAMON_1),

	nci_bci_states:set_state([{state, starting_lmc_loaded}]),

	ok = nci_dci_actions:conn_establish([]),
	ok = nci_dci_actions:subscribe_faults([]),

	ct:pal("Action_1"),
	lists:foreach(
	  fun(NearEndPortNo) ->
			  ok = nci_dci_actions:stop_idl2_link([{expectedSigNo, ?RICM_STOP_IDL2_LINK_REJ},
												   {errorCode, ?ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL},
												   {errorDescription, {regexp, "Invalid nearEndPortNo"}},
												   {nearEndDuId, 1},
												   {nearEndPortNo, NearEndPortNo}])
	  end,
	  [0, 1, 2, 7]),

	%% Check for unexpected signals
	nci_common_utils:check_outstanding_faults().

%%------------------------------------------------------------------------------
%% $Id DCI_IDL2_STOP6
%%
%% $Header
%%  IDL2 Link - Stop IDL2 Link: IDL2 link not started
%%
%% $Description
%%  Verifies that RICM sends the correct reject signal when attempting to stop 
%%  an IDL2 link that is not started.
%%
%% $Requirements
%%  TBD
%%
%% $HW config
%%  Any
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  The DU BC is in state starting
%%  DP LMC is loaded
%%  DCI connection establish performed
%%  Subscribe DCI faults
%%
%% $Action_1
%%  Send RICM_STOP_IDL2_LINK_REQ with parameters: 
%%  * nearEndDuId = 1
%%  * nearEndPortNo = 3
%%
%% $Result_1
%%  RICM_STOP_IDL2_LINK_REJ is received with parameters: 
%%  * errorCode = UNSUCCESSFUL
%%  * errorDescription = "IDL2 link not started"
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%% -
%%
%% Revision history:
%%   2013-07-15 ebacemi
%%     First version
%%
%%------------------------------------------------------------------------------
dci_idl2_stop6() ->
	[{userdata,[{wp, ""}, 
				{requirement, "TBD"},
				{slogan, "IDL2 Link - Stop IDL2 Link: IDL2 link not started"}]}].

dci_idl2_stop6(_Config) ->
	ct:pal("dci_idl2_stop6"),

	{ok, session_up} = coli:subscribe_state(?SHELL_COMMAND),
	{ok, session_up} = osegw:subscribe_state(?OSE_GW_DEAMON_1),

	nci_bci_states:set_state([{state, starting_lmc_loaded}]),

	ok = nci_dci_actions:conn_establish([]),
	ok = nci_dci_actions:subscribe_faults([]),

	ct:pal("Action_1"),
	ok = nci_dci_actions:stop_idl2_link([{expectedSigNo, ?RICM_STOP_IDL2_LINK_REJ},
										 {errorCode, ?ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL},
										 {errorDescription, {regexp, "IDL2 link not started"}},
										 {nearEndDuId, 1},
										 {nearEndPortNo, 3}]),

	%% Check for unexpected signals
	nci_common_utils:check_outstanding_faults().

%%------------------------------------------------------------------------------
%% $Id DCI_IDL2_STOP7
%%
%% $Header
%%  IDL2 Link - Stop IDL2 Link: Radio port, CPRI link operational
%%
%% $Description
%%  Verifies that RICM sends the correct reject signal when attempting to stop 
%%  an IDL2 link on a port where a radio is connected with an operational CPRI link.
%%  The radio must be connected to port C, D, E or F.
%%
%% $Requirements
%%  TBD
%%
%% $HW config
%%  At least one radio
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  The DU BC is in state starting
%%  DP LMC is loaded
%%  DCI connection establish performed
%%  Subscribe DCI faults
%%  CPRI link and O&M link to the radio is up.
%%
%% $Action_1
%%  Send RICM_STOP_IDL2_LINK_REQ with parameters: 
%%  * nearEndDuId = 1
%%  * nearEndPortNo = <port where radio is connected>
%%
%% $Result_1
%%  RICM_STOP_IDL2_LINK_REJ is received with parameters: 
%%  * errorCode = UNSUCCESSFUL
%%  * errorDescription = "IDL2 link not started"
%%
%% $Action_2
%%  Verify that the CPRI link to the radio is still up by
%%  running the lmclist command.
%%
%% $Result_2
%%  lmclist returns correct result.
%%
%% $Postcondition
%%  Reset CPRI link.
%%
%% $End
%%
%% Review:
%% -
%%
%% Revision history:
%%   2013-07-15 ebacemi
%%     First version
%%
%%------------------------------------------------------------------------------
dci_idl2_stop7() ->
	[{userdata,[{wp, ""},
				{requirement, "TBD"},
				{slogan, "IDL2 Link - Stop IDL2 Link: Radio port, CPRI link operational"},
				{hwConfig, hwConfigF}]}].

dci_idl2_stop7(_Config) ->
	ct:pal("dci_idl2_stop7"),

	{ok, session_up} = coli:subscribe_state(?SHELL_COMMAND),
	{ok, session_up} = osegw:subscribe_state(?OSE_GW_DEAMON_1),

	Radio = nci_ricm_utils:get_first_radio([{excludePortNos, [1, 2]}]),
	PortNo = proplists:get_value(portNo, Radio),
	RuLnhPath = proplists:get_value(ruLnhPath, Radio),

	nci_bci_states:set_state([{state, starting_lmc_loaded}]),

	ok = nci_dci_actions:conn_establish([]),
	ok = nci_dci_actions:subscribe_faults([]),

	%% Start CPRI link
	ok = nci_dci_actions:start_cpri_link(Radio),
	ok = nci_dci_actions:cpri_link_ind(Radio ++ [{availStatus, 1}]),

	%% Start O&M link
	nci_dci_actions:add_radio_control(Radio),
	nci_dci_actions:radio_control_ind(Radio ++ [{connStatus, 1}]),

	nci_common_utils:coli_cmd("lhsh " ++ RuLnhPath ++ " lmclist", "SlotProt State"),

	ct:pal("Action_1"),
	ok = nci_dci_actions:stop_idl2_link([{expectedSigNo, ?RICM_STOP_IDL2_LINK_REJ},
										 {errorCode, ?ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL},
										 {errorDescription, {regexp, "IDL2 link not started"}},
										 {nearEndDuId, 1},
										 {nearEndPortNo, PortNo}]),

	ct:pal("Action_2"),
	nci_common_utils:coli_cmd("lhsh " ++ RuLnhPath ++ " lmclist", "SlotProt State"),

	ok = nci_dci_actions:reset_cpri_link(Radio),
	ok = nci_dci_actions:reset_cpri_link_ind(Radio),

	%% Check for unexpected signals
	nci_common_utils:check_outstanding_faults().

%%------------------------------------------------------------------------------
%% $Id DCI_IDL2_STOP8
%%
%% $Header
%%  IDL2 Link - Stop IDL2 Link: IDL2 link already started in leaf mode
%%
%% $Description
%%  Verifies that it is not possible to stop an IDL2 link on a port where the
%%  IDL2 link is already started in leaf mode.
%%
%% $Requirements
%%  TBD
%%
%% $HW config
%%  At least one IDL2 link
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  IDL2 links started to all leaf DUs
%%  The DU BC is in state starting on all DUs
%%  DP LMC is loaded on all DUs
%%  DCI connection establish performed on all DUs
%%  Subscribe DCI faults performed on all DUs
%%
%% $Action_1
%%  Send RICM_STOP_IDL2_LINK_REQ on leaf DU with parameters: 
%%  * nearEndDuId = <farEndDuId from config file>
%%  * nearEndPortNo = <farEndPortNo from from config file>
%%
%% $Result_1
%%  RICM_STOP_IDL2_LINK_REJ is received with parameters: 
%%  * errorCode = UNSUCCESSFUL
%%  * errorDescription = "IDL2 link already started in leaf mode"
%%
%% $Action_2
%%  Repeat Action_1 for the remaining IDL2 links
%%
%% $Result_2
%%  -
%%
%% $Action_3
%%  In order to verify that all IDL2 links are still operational, 
%%  check FPGA registers on all branch and leaf DUs and verify that 
%%  they have correct values.
%%
%% $Result_3
%%  Registers have correct values.
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%% -
%%
%% Revision history:
%%   2013-10-30 ebacemi
%%     First version
%%
%%------------------------------------------------------------------------------
dci_idl2_stop8() ->
	[{userdata,[{wp, ""},
				{requirement, "TBD"},
				{slogan, "IDL2 Link - Stop IDL2 Link: IDL2 link already started in leaf mode"},
				{hwConfig, hwConfigIDL2_A}]}].

dci_idl2_stop8(_Config) ->
	ct:pal("dci_idl2_stop8"),

	subscribe_states(),

	LineRate = ?IDL2_LINE_RATE_2_5G,
	PacketRatio = 1,

	nci_bci_states:set_state([{state, starting_lmc_loaded}]),

	ok = nci_dci_actions:conn_establish([]),
	ok = nci_dci_actions:subscribe_faults([]),

	IDL2Links = nci_ricm_utils:get_all_idl2_links(),

	start_idl2_links([{idl2Links, IDL2Links}]),

	lists:foreach(
		fun(IDL2Link) ->
				FarEndDuLnhPath = proplists:get_value(farEndDuLnhPath, IDL2Link),
				DcServer = get_dc_server(FarEndDuLnhPath),

				ct:pal("Action_1"),
				ok = nci_dci_actions:stop_idl2_link([{nearEndPortNo, proplists:get_value(farEndPortNo, IDL2Link)},
													 {nearEndDuId, proplists:get_value(farEndDuId, IDL2Link)},
													 {dcServer, DcServer},
													 {expectedSigNo, ?RICM_STOP_IDL2_LINK_REJ},
													 {errorCode, ?ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL},
													 {errorDescription, {regexp, "IDL2 link already started in leaf mode"}}]),

				ct:pal("Action_2")
		end,
		IDL2Links),

	ct:pal("Action_3"),
	lists:foreach(
		fun(IDL2Link) ->
				verify_idl2_link_up(IDL2Link ++ [{packetRatio, PacketRatio},
												 {lineRate, LineRate}]),
				verify_idl2_link_up_leaf(IDL2Link ++ [{packetRatio, PacketRatio},
													  {lineRate, LineRate},
													  {loadLMC, false}])
		end,
		IDL2Links),

	stop_idl2_links([{idl2Links, IDL2Links}]),

	%% Check for unexpected signals
	nci_common_utils:check_outstanding_faults().

%%------------------------------------------------------------------------------
%% $Id DCI_IDL2_CPRI1
%%
%% $Header
%%  IDL2 Link - Start CPRI link to a DU connected IDL2 port (IDL2 link down).
%%
%% $Description
%%  Verifies that attempt to set up CPRI link to DU-connected port shall result in a "No Signal Detected" fault.
%%
%% $Requirement
%%  CBD_RICM_DCI-START-CPRI-LINK_FU:3:H 
%%
%% $HW config
%%  One 2.5G IDL2 link.
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state starting
%%  DP LMC is loaded
%%  DCI connection establish performed
%%  DCI fault subscribtion performed
%%
%% $Action_1
%%  For each IDL2 link, send RICM_START_CPRI_LINK_REQ with parameters: 
%%  * portNo = nearEndPortNo from config file
%%  * ruId = (nearEndPortNo - 1)  * 6 + 1
%%  * cascadeNo = 1
%%  * primary = 1
%%
%% $Result_1
%%  For each IDL2 link, RICM_START_CPRI_LINK_CFM is received with parameters: 
%%  * ruId = (nearEndPortNo * 6) + 1
%%
%% $Action_2
%%  Wait 3 minutes for a ELIB_DC_FAULT_IND signal.
%%
%% $Result_2
%%  -
%%
%% $Action_3
%%  For each IDL2 link, wait for a ELIB_DC_FAULT_IND signal.
%%
%% $Result_3
%%  For each IDL2 link, ELIB_DC_FAULT_IND is received with parameters: 
%%  * faultId = ELIB_CONST_FH_FAULT_ID_LINK_FAILURE
%%  * faultDescription = "No signal detected"
%%
%% $Postcondition
%% -
%%
%% $End
%%
%% Review:
%% -
%%
%% Revision history:
%%   2013-07-11 ehuayya
%%     First version
%%   2013-10-11 ebacemi
%%     Improved the test case to use all available IDL2 links
%%
%%------------------------------------------------------------------------------
dci_idl2_cpri1() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_RICM_DCI-START-CPRI-LINK_FU:3:H"},
				{slogan, "IDL2 Link - Unable to start CPRI link on IDL2 port (IDL2 link down)"},
				{hwConfig, hwConfigIDL2_A}]}].

dci_idl2_cpri1(_Config) ->
	ct:pal("dci_idl2_cpri1"),

	{ok, session_up} = osegw:subscribe_state(?OSE_GW_DEAMON_1),
	{ok, session_up} = coli:subscribe_state(?SHELL_COMMAND),
	
	nci_bci_states:set_state([{state, starting_lmc_loaded}]),

	ok = nci_dci_actions:conn_establish([]),
	ok = nci_dci_actions:subscribe_faults([]),

	IDL2Links = nci_ricm_utils:get_all_idl2_links(),

	ct:pal("Action_1"),
	lists:foreach(
		fun(IDL2Link) ->
				PortNo = proplists:get_value(nearEndPortNo, IDL2Link),
				RuId = (PortNo - 1)  * 6 + 1,

				ok = nci_dci_actions:start_cpri_link([{portNo, PortNo},
													  {ruId, RuId}])
		end,
		IDL2Links),

	ct:pal("Action_2"),
	ct:pal("Wait 3 minutes"),
	timer:sleep(3 * 60 * 1000),

	ct:pal("Action_3"),
	lists:foreach(
		fun(_) ->
				_FaultId = nci_dci_actions:fault_ind([{faultId, ?ELIB_CONST_FH_FAULT_ID_LINK_FAILURE},
													  {faultDescription, {regexp, "No signal detected"}}])
		end,
		IDL2Links),

	nci_common_utils:check_outstanding_faults(),

	%% Perform a cold restart to cease the LINK_FAILURE faults
	nci_bci_states:cold_restart([]).

%%------------------------------------------------------------------------------
%% $Id DCI_IDL2_CPRI2
%%
%% $Header
%%  IDL2 Link - Start CPRI link to a DU connected IDL2 port (IDL2 link up).
%%
%% $Description
%%  Verifies that it is not possible to set up a CPRI link on a port where 
%%  an IDL2 link is already started.
%%
%% $Requirement
%%  CBD_RICM_DCI-START-CPRI-LINK_FU:3:H 
%%
%% $HW config
%%  One 2.5G IDL2 link.
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state starting
%%  DP LMC is loaded
%%  DCI connection establish performed
%%  Subscribe DCI faults
%%  All IDL2 links are operational in synchronous mode
%%
%% $Action_1
%%  Send RICM_START_CPRI_LINK_REQ with parameters: 
%%  * portNo = <nearEndPortNo from config file>
%%  * ruId = (nearEndPortNo - 1)  * 6 + 1
%%  * cascadeNo = 1
%%  * primary = 1
%%
%% $Result_1
%%  RICM_START_CPRI_LINK_REJ is received with parameters: 
%%  * errorCode = UNSUCCESSFUL
%%  * errorDescription = "IDL2 link already setup on this port"
%%
%% $Action_2
%%  Call verify_idl2_link_up on branch and leaf nodes to verify
%%  that the IDL2 link is still up.
%%
%% $Result_2
%%  IDL2 link is up
%%
%% $Action_3
%%  Repeat Action_1 to Action_2 for all remaining IDL2 links
%%
%% $Result_3
%%  -
%%
%% $Postcondition
%%  Stop the IDL2 links
%%
%% $End
%%
%% Review:
%% -
%%
%% Revision history:
%%   2013-07-16 ebacemi
%%     First version
%%   2013-10-11 ebacemi
%%     Improved the test case to use all available IDL2 links
%%     Restructured to use helper functions to start all IDL2 links
%%
%%------------------------------------------------------------------------------
dci_idl2_cpri2() ->
	[{userdata,[{wp, ""}, 
				{requirement, "CBD_RICM_DCI-START-CPRI-LINK_FU:3:H"},
				{slogan, "IDL2 Link - Unable to start CPRI link on IDL2 port (IDL2 link up)"},
				{hwConfig, hwConfigIDL2_A}]}].

dci_idl2_cpri2(_Config) ->
	ct:pal("dci_idl2_cpri2"),
	subscribe_states(),

	Node2Exists = nci_ricm_utils:node_exists(node2),

	IDL2Links = nci_ricm_utils:get_all_idl2_links(),
	PacketRatio = 1,
	LineRate = ?IDL2_LINE_RATE_2_5G,
	RuId = 1,


	nci_bci_states:set_state([{state, starting_lmc_loaded}]),

	ok = nci_dci_actions:conn_establish([]),
	ok = nci_dci_actions:subscribe_faults([]),

	start_idl2_links([{idl2Links, IDL2Links},
					  {packetRatio, PacketRatio},
					  {lineRate, LineRate}]),

	lists:foreach(
		fun(IDL2Link) ->
				PortNo = proplists:get_value(nearEndPortNo, IDL2Link),

				ct:pal("Action_1"),
				ok = nci_dci_actions:start_cpri_link([{expectedSigNo, ?RICM_START_CPRI_LINK_REJ},
													  {errorCode, ?ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL},
													  {errorDescription, {regexp, "IDL2 link already setup on this port"}},
													  {portNo, PortNo},
													  {ruId, RuId}]),

				ct:pal("Action_2"),
				verify_idl2_link_up(IDL2Link ++ [{packetRatio, PacketRatio},
												 {lineRate, LineRate}]),
				verify_idl2_link_up_leaf(IDL2Link ++ [{packetRatio, PacketRatio},
													  {lineRate, LineRate},
													  {node2Exists, Node2Exists},
													  {loadLMC, false}]),

				ct:pal("Action_3")
		end,
		IDL2Links),

	stop_idl2_links([{idl2Links, IDL2Links}]),

	nci_common_utils:check_outstanding_faults().

%%------------------------------------------------------------------------------
%% $Id DCI_IDL2_CPRI3
%%
%% $Header
%%  IDL2 Link - Start CPRI link to a DU connected IDL2 port (IDL2 link up in leaf mode).
%%
%% $Description
%%  Verifies that it is not possible to set up a CPRI link on a port where 
%%  an IDL2 link is already started in leaf mode.
%%
%% $Requirements
%%  TBD
%%
%% $HW config
%%  At least one IDL2 link
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  IDL2 links started to all leaf DUs
%%  The DU BC is in state starting on all DUs
%%  DP LMC is loaded on all DUs
%%  DCI connection establish performed on all DUs
%%  Subscribe DCI faults on all DUs
%%
%% $Action_1
%%  Send RICM_START_CPRI_LINK_REQ with parameters: 
%%  * portNo = <farEndPortNo from config file>
%%  * ruId = 1
%%  * cascadeNo = 1
%%  * primary = 1
%%
%% $Result_1
%%  RICM_START_CPRI_LINK_REJ is received with parameters: 
%%  * errorCode = UNSUCCESSFUL
%%  * errorDescription = "IDL2 link already setup on this port"
%%
%% $Action_2
%%  Repeat Action_1 for the remaining IDL2 links
%%
%% $Result_2
%%  -
%%
%% $Action_3
%%  In order to verify that all IDL2 links are still operational, 
%%  check FPGA registers on all branch and leaf DUs and verify that 
%%  they have correct values.
%%
%% $Result_3
%%  Registers have correct values.
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%% -
%%
%% Revision history:
%%   2013-10-30 ebacemi
%%     First version
%%   2013-12-02 ebacemi
%%     Updated the expected string
%%
%%------------------------------------------------------------------------------
dci_idl2_cpri3() ->
	[{userdata,[{wp, ""},
				{requirement, "TBD"},
				{slogan, "IDL2 Link - Start CPRI link to a DU connected IDL2 port (IDL2 link up in leaf mode)"},
				{hwConfig, hwConfigIDL2_A}]}].

dci_idl2_cpri3(_Config) ->
	ct:pal("dci_idl2_cpri3"),

	subscribe_states(),

	LineRate = ?IDL2_LINE_RATE_2_5G,
	PacketRatio = 1,

	nci_bci_states:set_state([{state, starting_lmc_loaded}]),

	ok = nci_dci_actions:conn_establish([]),
	ok = nci_dci_actions:subscribe_faults([]),

	IDL2Links = nci_ricm_utils:get_all_idl2_links(),

	start_idl2_links([{idl2Links, IDL2Links}]),

	lists:foreach(
		fun(IDL2Link) ->
				FarEndDuLnhPath = proplists:get_value(farEndDuLnhPath, IDL2Link),
				DcServer = get_dc_server(FarEndDuLnhPath),

				ct:pal("Action_1"),
				ok = nci_dci_actions:start_cpri_link([{ruId, 1},
													  {portNo, proplists:get_value(farEndPortNo, IDL2Link)},
													  {cascadeNo, 1},
													  {dcServer, DcServer},
													  {expectedSigNo, ?RICM_START_CPRI_LINK_REJ},
													  {errorCode, ?ELIB_CONST_HWU_ERROR_CODE_UNSUCCESSFUL},
													  {errorDescription, {regexp, "IDL2 link already setup on this port"}}]),

				ct:pal("Action_2")
		end,
		IDL2Links),

	ct:pal("Action_3"),
	lists:foreach(
		fun(IDL2Link) ->
				verify_idl2_link_up(IDL2Link ++ [{packetRatio, PacketRatio},
												 {lineRate, LineRate}]),
				verify_idl2_link_up_leaf(IDL2Link ++ [{packetRatio, PacketRatio},
													  {lineRate, LineRate},
													  {loadLMC, false}])
		end,
		IDL2Links),

	stop_idl2_links([{idl2Links, IDL2Links}]),

	%% Check for unexpected signals
	nci_common_utils:check_outstanding_faults().


%%------------------------------------------------------------------------------
%% $Id DCI_IDL2_CPRI4
%%
%% $Header
%%  IDL2 Link - Start CPRI link to radio on leaf DU
%%
%% $Description
%%  Verifies that it is possible to set up a CPRI link on a leaf DU
%%
%% $Requirements
%%  TBD
%%
%% $HW config
%%  At least one IDL2 link
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  IDL2 links started to the leaf DU
%%  The DU BC is in state starting on all DUs
%%  DP LMC is loaded on all DUs
%%  DCI connection establish performed on all DUs
%%  Subscribe DCI faults on all DUs
%%
%% $Action_1
%%  Send RICM_START_CPRI_LINK_REQ on leaf DU with parameters:
%%  * ruId = <read from config file>
%%  * portNo = <read from config file>
%%  * cascadeNo = <read from config file>
%%  * primary = 1
%%
%% $Result_1a
%%  RICM_START_CPRI_LINK_CFM is received on leaf DU with parameters: 
%%  * ruId = <read from config file>
%%
%% $Result_1b
%%  RICM_START_CPRI_LINK_IND is received on leaf DU with parameters: 
%%  * ruId = <read from config file>
%%  * availStatus = 1
%%
%% $Action_2
%%  Send RICM_ADD_RADIO_CTL_REQ on leaf DU with parameters:
%%  * ruId = <read from config file>
%%
%% $Result_2a
%%  RICM_ADD_RADIO_CTL_CFM is received on leaf DU with parameters: 
%%  * ruId = <read from config file>
%%
%% $Result_2b
%%  RICM_ADD_RADIO_CTL_IND is received on leaf DU with parameters: 
%%  * ruId = <read from config file>
%%  * connStatus = 1
%%
%% $Action_3
%%  Verify that the CPRI link is up by executing lmclist on the RU.
%%
%% $Result_3
%%  The RU responds with a valid list of LMCs.
%%
%% $Action_4
%%  Repeat Action_1 to Action_3 for all radios on the leaf DU.
%%
%% $Result_4
%%  -
%%
%% $Action_5
%%  Send RICM_RESET_CPRI_LINK_REQ on leaf DU with parameters:
%%  * ruId = <read from config file>
%%
%% $Result_5a
%%  RICM_RESET_CPRI_LINK_CFM is received on leaf DU with parameters: 
%%  * ruId = <read from config file>
%%
%% $Result_5b
%%  RICM_RESET_CPRI_LINK_IND is received on leaf DU with parameters: 
%%  * ruId = <read from config file>
%%
%% $Action_6
%%  Repeat Action_5 for all radios with cascadeNo = 1 on the leaf DU.
%%
%% $Result_6
%%  -
%%
%% $Action_7
%%  In order to verify that the IDL2 link is still operational, 
%%  check FPGA registers on branch and leaf DU and verify that 
%%  they have correct values.
%%
%% $Result_7
%%  Registers have correct values.
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%% -
%%
%% Revision history:
%%   2013-10-30 ebacemi
%%     First version
%%
%%------------------------------------------------------------------------------
dci_idl2_cpri4() ->
	[{userdata,[{wp, ""},
				{requirement, "TBD"},
				{slogan, "IDL2 Link - Start CPRI link to radio on leaf DU"},
				{hwConfigDu0, hwConfigIDL2_A},
				{hwConfigDu1, hwConfigA}]}].

dci_idl2_cpri4(_Config) ->
	ct:pal("dci_idl2_cpri4"),

	subscribe_states(),

	LineRate = ?IDL2_LINE_RATE_2_5G,
	PacketRatio = 1,

	nci_bci_states:set_state([{state, starting_lmc_loaded}]),

	ok = nci_dci_actions:conn_establish([]),
	ok = nci_dci_actions:subscribe_faults([]),

	IDL2Link = nci_ricm_utils:get_first_idl2_link(),

	start_idl2_links([{idl2Links, [IDL2Link]}]),

	FarEndDuLnhPath = proplists:get_value(farEndDuLnhPath, IDL2Link),
	DcServer = get_dc_server(FarEndDuLnhPath),

	Radios = nci_ricm_utils:get_all_radios([{du, du1}]),

	ct:pal("~p", [Radios]),

	lists:foreach(
		fun(Radio) ->
				RuLnhPath = proplists:get_value(ruLnhPath, Radio),

				ct:pal("Action_1"),
				ok = nci_dci_actions:start_cpri_link(Radio ++ [{dcServer, DcServer}]),
				ok = nci_dci_actions:cpri_link_ind(Radio ++ [{availStatus, 1}]),

				ct:pal("Action_2"),
				ok = nci_dci_actions:add_radio_control(Radio ++ [{dcServer, DcServer}]),
				ok = nci_dci_actions:radio_control_ind(Radio ++ [{connStatus, 1}, 
																 {radioSoftware, application}]),

				ct:pal("Action_3"),
				nci_common_utils:coli_cmd("lhsh " ++ RuLnhPath ++ " lmclist", "SlotProt State"),

				ct:pal("Action_4")
		end,
		Radios),

	lists:foreach(
		fun(Radio) ->
				case proplists:get_value(cascadeNo, Radio) of
					1 ->
						ct:pal("Action_5"),
						ok = nci_dci_actions:reset_cpri_link(Radio ++ [{dcServer, DcServer}]),
						ok = nci_dci_actions:reset_cpri_link_ind(Radio),

						ct:pal("Action_6");
					_ ->
						ok
				end
		end,
		Radios),

	ct:pal("Action_7"),
	verify_idl2_link_up(IDL2Link ++ [{packetRatio, PacketRatio},
									 {lineRate, LineRate}]),
	verify_idl2_link_up_leaf(IDL2Link ++ [{packetRatio, PacketRatio},
										  {lineRate, LineRate},
										  {loadLMC, false}]),

	stop_idl2_links([{idl2Links, [IDL2Link]}]),

	%% Check for unexpected signals
	nci_common_utils:check_outstanding_faults().

%%------------------------------------------------------------------------------
%% $Id DCI_IDL2_LSP1
%%
%% $Header
%%  IDL2 Link - Link Status Propagation (Start + Stop)
%%
%% $Description
%%  Verifies that it is possible to receive correct IDPI/IDL2 link status
%%  indications during IDL2 link startup.
%%
%% $Requirements
%%  TBD
%%
%% $HW config
%%  One 2.5G IDL2 link
%%
%% $Type
%%  regression
%%
%% $Precondition
%%  The DU BC is in state starting
%%  DP LMC is loaded
%%  DCI connection establish performed on Branch node
%%  Subscribe DCI faults on Branch node
%%  Both Branch and Leaf nodes have done IDPI connection establish and IDPI link status subscription
%%  Both Branch and Leaf nodes have received 4 initial IDPI link status indications
%%
%% $Action_1
%%  Send RICM_START_IDL2_LINK_REQ to branch node with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%  * farEndDuId = <read from config file>
%%  * farEndPortNo = <read from config file>
%%  * packetRatio = 1
%%  * lineRate = ?IDL2_LINE_RATE_2_5G
%%
%% $Result_1
%%  RICM_START_IDL2_LINK_CFM is received with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%
%% $Action_2
%%  Wait for the Leaf node to receive a IDPI_LINK_STATUS_IND siganl.
%%
%% $Result_2
%%  IDPI_LINK_STATUS_IND is received on Leaf node with parameters:
%%  * nearEndDuId = Don't care
%%  * nearEndPortNo = farEndPortId from Action_1
%%  * farEndDuId = Don't care
%%  * farEndPortNo = Don't care
%%  * packetRatio = Dont't care
%%  * lineRate = Don't care
%%  * idl2LinkStatus = IDPI_LINK_AVAILABLE_NO_RX_SERVICE
%%  * dunDataValid = 0
%%  * portDataValid = 0
%%  * sequenceNumber = SeqNo_NODE2
%%
%% $Action_3
%%  Wait for the Leaf node to receive a IDPI_LINK_STATUS_IND signal.
%%
%% $Result_3
%%  IDPI_LINK_STATUS_IND is received on Leaf node with parameters:
%%  * nearEndDuId = farEndDuId from Action_1
%%  * nearEndPortNo = farEndPortId from Action_1
%%  * farEndDuId = nearEndDuId from Action_1
%%  * farEndPortNo = nearEndPortId from Action_1
%%  * packetRatio = 1
%%  * lineRate = <Line rate received in Action_2>
%%  * idl2LinkStatus = IDPI_LINK_AVAILABLE_NO_RX_SERVICE
%%  * dunDataValid = 1
%%  * portDataValid = 0
%%  * sequenceNumber = SeqNo_NODE2 + 1*<number of IDPI clients>
%%
%% $Action_4
%%  Wait for the Leaf node to receive a IDPI_LINK_STATUS_IND signal.
%%
%% $Result_4
%%  IDPI_LINK_STATUS_IND is received on Leaf node with parameters:
%%  * nearEndDuId = farEndDuId from Action_1
%%  * nearEndPortNo = farEndPortId from Action_1
%%  * farEndDuId = nearEndDuId from Action_1
%%  * farEndPortNo = nearEndPortId from Action_1
%%  * packetRatio = 1
%%  * lineRate = <Line rate received in Action_2>
%%  * idl2LinkStatus = IDPI_LINK_AVAILABLE_NO_RX_SERVICE
%%  * dunDataValid = 1
%%  * portDataValid = 1
%%  * sequenceNumber = SeqNo_NODE2 + 2*<number of IDPI clients>
%%
%% $Action_5
%%  Wait for the Leaf node to receive a IDPI_LINK_STATUS_IND signal.
%%
%% $Result_5
%%  IDPI_LINK_STATUS_IND is received on Leaf node with parameters:
%%  * nearEndDuId = farEndDuId from Action_1
%%  * nearEndPortNo = farEndPortId from Action_1
%%  * farEndDuId = nearEndDuId from Action_1
%%  * farEndPortNo = nearEndPortId from Action_1
%%  * packetRatio = 1
%%  * lineRate = <Line rate received in Action_2>
%%  * idl2LinkStatus = IDPI_LINK_AVAILABLE
%%  * dunDataValid = 1
%%  * portDataValid = 1
%%  * sequenceNumber = SeqNo_NODE2 + 3*<number of IDPI clients>
%%
%% $Action_6
%%  Wait for the Branch node to receive a IDPI_LINK_STATUS_IND signal.
%%
%% $Result_6
%%  IDPI_LINK_STATUS_IND is received on Branch node with parameters:
%%  * nearEndDuId = nearEndDuId from Action_1
%%  * nearEndPortNo = nearEndPortId from Action_1
%%  * farEndDuId = farEndDuId from Action_1
%%  * farEndPortNo = farEndPortId from Action_1
%%  * packetRatio = 1
%%  * lineRate = <Line rate received in Action_2>
%%  * idl2LinkStatus = IDPI_LINK_AVAILABLE_NO_TX_SERVICE
%%  * dunDataValid = 0
%%  * portDataValid = 0
%%  * sequenceNumber = SeqNo_NODE1
%%
%% $Action_7
%%  Wait for the Branch node to receive a IDPI_LINK_STATUS_IND signal.
%%
%% $Result_7
%%  IDPI_LINK_STATUS_IND is received on Branch node with parameters:
%%  * nearEndDuId = nearEndDuId from Action_1
%%  * nearEndPortNo = nearEndPortId from Action_1
%%  * farEndDuId = farEndDuId from Action_1
%%  * farEndPortNo = farEndPortId from Action_1
%%  * packetRatio = 1
%%  * lineRate = <Line rate received in Action_2>
%%  * idl2LinkStatus = IDPI_LINK_AVAILABLE_NO_TX_SERVICE
%%  * dunDataValid = 1
%%  * portDataValid = 0
%%  * sequenceNumber = SeqNo_NODE1 + 1*<number of IDPI clients>
%%
%% $Action_8
%%  Wait for the Branch node to receive a IDPI_LINK_STATUS_IND signal.
%%
%% $Result_8
%%  IDPI_LINK_STATUS_IND is received on Branch node with parameters:
%%  * nearEndDuId = nearEndDuId from Action_1
%%  * nearEndPortNo = nearEndPortId from Action_1
%%  * farEndDuId = farEndDuId from Action_1
%%  * farEndPortNo = farEndPortId from Action_1
%%  * packetRatio = 1
%%  * lineRate = <Line rate received in Action_2>
%%  * idl2LinkStatus = IDPI_LINK_AVAILABLE_NO_TX_SERVICE
%%  * dunDataValid = 1
%%  * portDataValid = 1
%%  * sequenceNumber = SeqNo_NODE1 + 2*<number of IDPI clients>
%%
%% $Action_9
%%  Wait for the Branch node to receive a IDPI_LINK_STATUS_IND signal.
%%
%% $Result_9
%%  IDPI_LINK_STATUS_IND is received on Branch node with parameters:
%%  * nearEndDuId = nearEndDuId from Action_1
%%  * nearEndPortNo = nearEndPortId from Action_1
%%  * farEndDuId = farEndDuId from Action_1
%%  * farEndPortNo = farEndPortId from Action_1
%%  * packetRatio = 1
%%  * lineRate = <Line rate received in Action_2>
%%  * idl2LinkStatus = IDPI_LINK_AVAILABLE
%%  * dunDataValid = 1
%%  * portDataValid = 1
%%  * sequenceNumber = SeqNo_NODE1 + 3*<number of IDPI clients>
%%
%% $Action_10
%%  Wait for the Branch node to receive a START_IDL2_LINK_IND signal.
%%
%% $Result_10
%%  START_IDL2_LINK_IND is received on branch side with parameters:
%%  * nearEndDuId = nearEndDuId from Action_1
%%  * nearEndPortNo = nearEndPortId from Action_1
%%  * packetRatio = 1
%%  * lineRate = <Line rate received in Action_2>
%%  * availStatus = RICM_IDL2_LINK_AVAILABLE
%%
%% $Action_11
%%  When the leaf DU is type3:
%%  Wait for the Branch node to receive a START_IDL2_LINK_IND signal.
%%
%% $Result_11
%%  START_IDL2_LINK_IND is received on branch side with parameters:
%%  * nearEndDuId = nearEndDuId from Action_1
%%  * nearEndPortNo = nearEndPortId from Action_1
%%  * packetRatio = 1
%%  * lineRate = <Line rate received in Action_2>
%%  * availStatus = RICM_IDL2_LINK_AVAILABLE_SYNC
%%
%% $Action_12
%%  Call verify_idl2_link_up on Branch node to verify that 
%%  CPRI registers have correct values.
%%
%% $Result_12
%%  Registers have correct values.
%%
%% $Action_13
%%  Call verify_idl2_link_up on Leaf node to verify that 
%%  CPRI registers have correct values.
%%
%% $Result_13
%%  Registers have correct values.
%%
%% $Postcondition
%%  Send STOP_IDL2_LINK_REQ to Branch node.
%%  Receive IDPI_LINK_STATUS_IND on both Branch and Leaf nodes to indicate link down.
%%  Call verify_idl2_link_down on branch and leaf.
%%
%% $End
%%
%% Review:
%% -
%%
%% Revision history:
%%   2013-07-01 ehuayya
%%     First version
%%
%%   2013-07-08 ebacemi
%%     Renamed to dci_idl2_lsp1
%%
%%   2013-11-22 ebacemi
%%     Updated to support 2 NSS clients
%%
%%   2014-01-20 ebacemi
%%     Updated for WP6.1
%%
%%------------------------------------------------------------------------------
dci_idl2_lsp1() ->
	[{userdata,[{wp, ""}, 
				{requirement, "TBD"},
				{slogan, "IDL2 Link - Link Status Propagation (Start + Stop)"},
				{nodeConfig, nodeConfigB},
				{hwConfig, hwConfigIDL2_A}]}].

dci_idl2_lsp1(_Config) ->
	ct:pal("dci_idl2_lsp1"),

	subscribe_states(),

	Node2Exists = nci_ricm_utils:node_exists(node2),

	%% On node1 (branch node) we have 5 IDPI clients:
	%% CS, Intra, NSS (2 processes) and our own test process
	NumIDPIClientsNode1 = 5,

	%% On node2 (type2 leaf node) we have 4 IDPI clients:
	%% CS, Intra, NSS  and our own test process
	NumIDPIClientsNode2 = 4,

	nci_bci_states:set_state([{state, starting_lmc_loaded}]),

	%% Type2 RICM only supports IDPI revision 1
	ok = nci_idpi_actions:conn_establish([{oseGwDeamon, ?OSE_GW_DEAMON_NODE2_1},
										  {protocolRev, ?IDPI_PROTOCOL_PV1}]),
	ok = nci_idpi_actions:subscribe_link_status_and_receive_inds([{oseGwDeamon,  ?OSE_GW_DEAMON_NODE2_1}]),

	ok = nci_idpi_actions:conn_establish([]),
	ok = nci_idpi_actions:subscribe_link_status_and_receive_inds([]),

	IDL2Link = nci_ricm_utils:get_first_idl2_link(),
	ct:pal("IDL2 link used: ~p", [IDL2Link]),
	NearEndPortNo = proplists:get_value(nearEndPortNo, IDL2Link),
	NearEndDuId = proplists:get_value(nearEndDuId, IDL2Link),
	FarEndPortNo = proplists:get_value(farEndPortNo, IDL2Link),
	FarEndDuId = proplists:get_value(farEndDuId, IDL2Link),
	LineRate = ?IDL2_LINE_RATE_2_5G,
	PacketRatio = 1,

	ok = nci_dci_actions:conn_establish([]),
	ok = nci_dci_actions:subscribe_faults([]),
	
	ct:pal("Action_1"),
	ok = nci_dci_actions:start_idl2_link(IDL2Link ++ [{packetRatio, PacketRatio},
													  {lineRate, LineRate}]),

	ct:pal("Action_2"),
	{ok, Ind_NODE2} = nci_idpi_actions:link_status_ind([{oseGwDeamon, ?OSE_GW_DEAMON_NODE2_1},
														{dunDataValid, 0},
														{portDataValid, 0},
														{nearEndPortNo, FarEndPortNo},
														{nearEndDuId, '_'},
														{farEndPortNo, '_'},
														{farEndDuId, '_'},
														{lineRate, '_'}, 
														{packetRatio, '_'},
														{idl2LinkStatus, ?IDPI_LINK_AVAILABLE_NO_RX_SERVICE}]),
	SeqNo_NODE2 = Ind_NODE2#'IdpiLinkStatusIndS'.sequenceNumber,
	ReceivedLineRate = Ind_NODE2#'IdpiLinkStatusIndS'.lineRate,
	
	ct:pal("Action_3"),
	{ok, _} = nci_idpi_actions:link_status_ind([{oseGwDeamon, ?OSE_GW_DEAMON_NODE2_1},
												{nearEndDuId, FarEndDuId}, 
												{nearEndPortNo, FarEndPortNo},
												{farEndDuId, NearEndDuId},
												{farEndPortNo, NearEndPortNo},
												{packetRatio, PacketRatio},
												{lineRate, ReceivedLineRate},
												{portDataValid, 0},
												{dunDataValid, 1},
												{idl2LinkStatus, ?IDPI_LINK_AVAILABLE_NO_RX_SERVICE},
												{sequenceNumber, SeqNo_NODE2 + 1*NumIDPIClientsNode2}]),

	ct:pal("Action_4"),
	{ok, _} = nci_idpi_actions:link_status_ind([{oseGwDeamon, ?OSE_GW_DEAMON_NODE2_1},
												{nearEndDuId, FarEndDuId}, 
												{nearEndPortNo, FarEndPortNo},
												{farEndDuId, NearEndDuId},
												{farEndPortNo, NearEndPortNo},
												{packetRatio, PacketRatio},
												{lineRate, ReceivedLineRate},
												{portDataValid, 1},
												{dunDataValid, 1},
												{idl2LinkStatus, ?IDPI_LINK_AVAILABLE_NO_RX_SERVICE},
												{sequenceNumber, SeqNo_NODE2 + 2*NumIDPIClientsNode2}]),

	ct:pal("Action_5"),
	{ok, _} = nci_idpi_actions:link_status_ind([{oseGwDeamon, ?OSE_GW_DEAMON_NODE2_1},
												{nearEndDuId, FarEndDuId}, 
												{nearEndPortNo, FarEndPortNo},
												{farEndDuId, NearEndDuId},
												{farEndPortNo, NearEndPortNo},
												{packetRatio, PacketRatio},
												{lineRate, ReceivedLineRate},
												{dunDataValid, 1},
												{portDataValid, 1},
												{idl2LinkStatus, ?IDPI_LINK_AVAILABLE},
												{sequenceNumber, SeqNo_NODE2 + 3*NumIDPIClientsNode2}]),

	ct:pal("Action_6"),
	{ok, Ind_NODE1} = nci_idpi_actions:link_status2_ind([{nearEndPortNo, NearEndPortNo},
														 {nearEndDuId, NearEndDuId},
														 {farEndPortNo, FarEndPortNo},
														 {farEndDuId, FarEndDuId},
														 {lineRate, ReceivedLineRate},
														 {packetRatio, PacketRatio},
														 {dunDataValid, 0},
														 {portDataValid, 0},
														 {idl2LinkStatus, ?IDPI_LINK_AVAILABLE_NO_TX_SERVICE}]),
	SeqNo_NODE1 = Ind_NODE1#'IdpiLinkStatusIndS'.sequenceNumber,
	
	ct:pal("Action_7"),
	{ok, _} = nci_idpi_actions:link_status2_ind([{nearEndDuId, NearEndDuId}, 
												 {nearEndPortNo, NearEndPortNo},
												 {farEndDuId, FarEndDuId},
												 {farEndPortNo, FarEndPortNo},
												 {packetRatio, PacketRatio},
												 {lineRate, ReceivedLineRate},
												 {dunDataValid, 1},
												 {portDataValid, 0},
												 {idl2LinkStatus, ?IDPI_LINK_AVAILABLE_NO_TX_SERVICE},
												 {sequenceNumber, SeqNo_NODE1 + 1*NumIDPIClientsNode1}]),
									  
	ct:pal("Action_8"),
	{ok, _} = nci_idpi_actions:link_status2_ind([{nearEndDuId, NearEndDuId}, 
												 {nearEndPortNo, NearEndPortNo},
												 {farEndDuId, FarEndDuId},
												 {farEndPortNo, FarEndPortNo},
												 {packetRatio, PacketRatio},
												 {lineRate, ReceivedLineRate},
												 {dunDataValid, 1},
												 {portDataValid, 1},
												 {idl2LinkStatus, ?IDPI_LINK_AVAILABLE_NO_TX_SERVICE},
												 {sequenceNumber, SeqNo_NODE1 + 2*NumIDPIClientsNode1}]),

	ct:pal("Action_9"),
	{ok, _} = nci_idpi_actions:link_status2_ind([{nearEndDuId, NearEndDuId}, 
												 {nearEndPortNo, NearEndPortNo},
												 {farEndDuId, FarEndDuId},
												 {farEndPortNo, FarEndPortNo},
												 {packetRatio, PacketRatio},
												 {lineRate, ReceivedLineRate},
												 {dunDataValid, 1},
												 {portDataValid, 1},
												 {idl2LinkStatus, ?IDPI_LINK_AVAILABLE},
												 {sequenceNumber, SeqNo_NODE1 + 3*NumIDPIClientsNode1}]),

	ct:pal("Action_10"),
	{ok, _} = nci_dci_actions:idl2_link_ind(IDL2Link ++ [{packetRatio, PacketRatio},
														 {lineRate, ReceivedLineRate},
														 {availStatus, ?RICM_IDL2_LINK_AVAILABLE}]),

	ct:pal("Action_11"),
	receive_time_sync_ind(IDL2Link, PacketRatio, ReceivedLineRate),

	ct:pal("Action_12"),
	verify_idl2_link_up(IDL2Link ++ [{packetRatio, PacketRatio},
									 {lineRate, ReceivedLineRate}]),

	ct:pal("Action_13"),
	verify_idl2_link_up_leaf(IDL2Link ++ [{packetRatio, PacketRatio},
										  {lineRate, ReceivedLineRate},
										  {node2Exists, Node2Exists}]),

	%% Stop the link
	ok = nci_dci_actions:stop_idl2_link([{nearEndDuId, NearEndDuId}, 
										 {nearEndPortNo, NearEndPortNo}]),

	%% Get IDPI link down indications
	{ok, _} = nci_idpi_actions:link_status_ind([{oseGwDeamon, ?OSE_GW_DEAMON_NODE2_1},
												{nearEndDuId, '_'}, 
												{nearEndPortNo, FarEndPortNo},
												{farEndDuId, '_'},
												{farEndPortNo, '_'},
												{packetRatio, '_'},
												{lineRate, '_'},
												{portDataValid, 0},
												{dunDataValid, 0},
												{idl2LinkStatus, ?IDPI_LINK_UNAVAILABLE},
												{sequenceNumber, SeqNo_NODE2 + 4*NumIDPIClientsNode2}]),

	{ok, _} = nci_idpi_actions:link_status2_ind([{nearEndDuId, '_'}, 
												 {nearEndPortNo, NearEndPortNo},
												 {farEndDuId, '_'},
												 {farEndPortNo, '_'},
												 {packetRatio, '_'},
												 {lineRate, '_'},
												 {portDataValid, 0},
												 {dunDataValid, 0},
												 {idl2LinkStatus, ?IDPI_LINK_UNAVAILABLE},
												 {sequenceNumber, SeqNo_NODE1 + 4*NumIDPIClientsNode1}]),

	verify_idl2_link_down(IDL2Link),
	verify_idl2_link_down_leaf(IDL2Link ++ [{node2Exists, Node2Exists}]),
	
	%% Check for unexpected signals
	nci_common_utils:check_outstanding_faults(),
	
	%% Restart client to make sure we are disconnected
	nci_common_utils:restart_osegw(),

	case Node2Exists of
		true ->
			%% Check for unexpected signals
			nci_common_utils:check_outstanding_faults(?OSE_GW_DEAMON_NODE2_1, 2000),

			%% Restart client to make sure we are disconnected
			nci_common_utils:restart_osegw(?OSE_GW_DEAMON_NODE2_1, osegw_node2);
		_ ->
			ok
	end.

%%------------------------------------------------------------------------------
%% $Id DCI_IDL2_LINK1
%%
%% $Header
%%  IDL2 Link - Restart IDL2 Link
%%
%% $Description
%%  Verifies that it is possible to restart an IDL2 link with a different
%%  packetRatio and lineRate.
%%
%% $Requirements
%%  TBD
%%
%% $HW config
%%  One 5G IDL2 link
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  The DU BC is in state starting
%%  DP LMC is loaded
%%  DCI connection establish performed
%%  Subscribe DCI faults
%%
%% $Action_1
%%  Send RICM_START_IDL2_LINK_REQ with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%  * farEndDuId = <read from config file>
%%  * farEndPortNo = <read from config file>
%%  * packetRatio = 1
%%  * lineRate = 2
%%
%% $Result_1
%%  RICM_START_IDL2_LINK_CFM is received with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%
%% $Action_2
%%  Wait for a RICM_START_IDL2_LINK_IND signal.
%%
%% $Result_2
%%  RICM_START_IDL2_LINK_IND is received with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%  * packetRatio = 1
%%  * lineRate = <don't care>
%%  * availStatus = RICM_IDL2_LINK_AVAILABLE
%%
%% $Action_3
%%  When the leaf DU is type3:
%%  Wait for a RICM_START_IDL2_LINK_IND signal.
%%
%% $Result_3
%%  RICM_START_IDL2_LINK_IND is received with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%  * packetRatio = 1
%%  * lineRate = <don't care>
%%  * availStatus = RICM_IDL2_LINK_AVAILABLE_SYNC
%%
%% $Action_4
%%  Send RICM_STOP_IDL2_LINK_REQ with parameters: 
%%  * nearEndDuId = 1
%%  * nearEndPortNo = 3
%%
%% $Result_4
%%  RICM_STOP_IDL2_LINK_CFM is received with parameters: 
%%  * nearEndDuId = 1
%%  * nearEndPortNo = 3
%%
%% $Action_5
%%  Send RICM_START_IDL2_LINK_REQ with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%  * farEndDuId = <read from config file>
%%  * farEndPortNo = <read from config file>
%%  * packetRatio = 2
%%  * lineRate = 3
%%
%% $Result_5
%%  RICM_START_IDL2_LINK_CFM is received with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%
%% $Action_6
%%  Wait for a RICM_START_IDL2_LINK_IND signal.
%%
%% $Result_6
%%  RICM_START_IDL2_LINK_IND is received with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%  * packetRatio = 2
%%  * lineRate = <don't care>
%%  * availStatus = RICM_IDL2_LINK_AVAILABLE
%%
%% $Action_7
%%  When the leaf DU is type3:
%%  Wait for a RICM_START_IDL2_LINK_IND signal.
%%
%% $Result_7
%%  RICM_START_IDL2_LINK_IND is received with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%  * packetRatio = 2
%%  * lineRate = <same as from Result_6>
%%  * availStatus = RICM_IDL2_LINK_AVAILABLE_SYNC
%%
%% $Action_8
%%  Call verify_idl2_link_up() to verify that the IDL2 link
%%  is in operational state on both branch and leaf nodes.
%%
%% $Result_8
%%  Registers show that IDL2 link is in operational state.
%%
%% $Postcondition
%%  Stop IDL2 link
%%
%% $End
%%
%% Review:
%% -
%%
%% Revision history:
%%   2013-05-08 EBACEMI
%%     First version
%%   2013-06-26 EISMELE
%%     Modified the IDL2 link config_1 register to
%%     to enable the led bit.
%%   2013-07-16 EBACEMI
%%     Renamed and restructured the TC
%%   2013-09-24 EBACEMI
%%     Updated to support type3-type3
%%   2014-01-20 EBACEMI
%%     Updated for WP6.1
%%
%%------------------------------------------------------------------------------
dci_idl2_link1() ->
	[{userdata,[{wp, ""}, 
				{requirement, "TBD"},
				{slogan, "IDL2 Link - Restart IDL2 Link"},
				{hwConfig, hwConfigIDL2_B}]}].

dci_idl2_link1(_Config) ->
	ct:pal("dci_idl2_link1"),
	subscribe_states(),

	Node2Exists = nci_ricm_utils:node_exists(node2),

	IDL2Link = nci_ricm_utils:get_first_idl2_link([{minLineRate, ?IDL2_LINE_RATE_5G}]),
	ct:pal("IDL2 link used: ~p", [IDL2Link]),

	LineRate1 = ?IDL2_LINE_RATE_2_5G,
	LineRate2 = ?IDL2_LINE_RATE_5G,
	PacketRatio1 = 1,
	PacketRatio2 = 2,

	nci_bci_states:set_state([{state, starting_lmc_loaded}]),

	ok = nci_dci_actions:conn_establish([]),
	ok = nci_dci_actions:subscribe_faults([]),

	ct:pal("Action_1"),
	ok = nci_dci_actions:start_idl2_link(IDL2Link ++ [{packetRatio, PacketRatio1},
													  {lineRate, LineRate1}]),
	
	ct:pal("Action_2"),
	{ok, _} = nci_dci_actions:idl2_link_ind(IDL2Link ++ [{packetRatio, PacketRatio1},
														 {lineRate, '_'},
														 {availStatus, ?RICM_IDL2_LINK_AVAILABLE}]),

	ct:pal("Action_3"),
	receive_time_sync_ind(IDL2Link, PacketRatio1, '_'),

	ct:pal("Action_4"),
	ok = nci_dci_actions:stop_idl2_link(IDL2Link),

	wait_for_leaf(Node2Exists),

	ct:pal("Action_5"),
	ok = nci_dci_actions:start_idl2_link(IDL2Link ++ [{packetRatio, PacketRatio2},
													  {lineRate, LineRate2}]),
	
	ct:pal("Action_6"),
	{ok, Ind} = nci_dci_actions:idl2_link_ind(IDL2Link ++ [{packetRatio, PacketRatio2},
														   {lineRate, '_'},
														   {availStatus, ?RICM_IDL2_LINK_AVAILABLE}]),
	ReceivedLineRate2 = Ind#'RicmStartIdl2LinkIndS'.lineRate,
	
	ct:pal("Action_7"),
	receive_time_sync_ind(IDL2Link, PacketRatio2, ReceivedLineRate2),

	ct:pal("Action_8"),
	verify_idl2_link_up(IDL2Link ++ [{packetRatio, PacketRatio2},
									 {lineRate, ReceivedLineRate2}]),
	verify_idl2_link_up_leaf(IDL2Link ++ [{packetRatio, PacketRatio2},
										  {lineRate, ReceivedLineRate2},
										  {node2Exists, Node2Exists}]),

	ok = nci_dci_actions:stop_idl2_link(IDL2Link),

	wait_for_leaf(Node2Exists),

	%% Check for unexpected signals
	nci_common_utils:check_outstanding_faults().

%%------------------------------------------------------------------------------
%% $Id DCI_IDL2_LINK2
%%
%% $Header
%%  IDL2 Link - Cold restart (RX only)
%%
%% $Description
%%  Verifies that after a cold restart on both branch and leaf, both sides should 
%%  be in RX mode on all IDL2 ports.
%%
%% $Requirements
%%  TBD
%%
%% $HW config
%%  Any
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  -
%%
%% $Action_1
%%  Perform cold restart on the branch node.
%%
%% $Result_1
%%  Branch node is restarted.
%%
%% $Action_2
%%  If leaf is type2, perform cold restart on the leaf node.
%%
%% $Result_2
%%  Leaf node is restarted.
%%
%% $Action_3
%%  Load DP LMC on branch node.
%%
%% $Result_3
%%  DP LMC is loaded on branch.
%%
%% $Action_4
%%  If a second node exists, sleep for 10 seconds to allow NSS to enter freerunning mode.
%%  Normally this takes 13 seconds straight from boot up, so 10 seconds + the time it takes to
%%  load DP LMC on branch should be enough.
%%
%% $Result_4
%%  -
%%
%% $Action_5
%%  Verify that all IDL2 links are down on both branch and leaf.
%%
%% $Result_5
%%  All IDL2 links are down on both branch and leaf.
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%% -
%%
%% Revision history:
%%   2013-09-02 ebacemi
%%     First version
%%   2013-09-24 EBACEMI
%%     Updated to support type3-type3
%%   2013-11-22 EBACEMI
%%     Added a delay to make the TC work better with type3-type2 configurations
%%
%%------------------------------------------------------------------------------
dci_idl2_link2() ->
	[{userdata,[{wp, ""}, 
				{requirement, "TBD"},
				{slogan, "IDL2 Link - Cold restart (RX only)"}]}].

dci_idl2_link2(_Config) ->
	ct:pal("dci_idl2_link2"),

	subscribe_states(),

	Node2Exists = nci_ricm_utils:node_exists(node2),

	ct:pal("Action_1"),
	%% Cold restart on branch
	nci_ricm_utils:cold_restart(node1),
	
	ct:pal("Action_2"),
	%% Cold restart on leaf
	case Node2Exists of
		true ->
			nci_ricm_utils:cold_restart(node2);
		_ ->
			ok
	end,

	ct:pal("Action_3"),
	nci_bci_states:set_state([{state, starting_lmc_loaded}]),

	ct:pal("Action_4"),
	case Node2Exists of
		true ->
			ct:pal("10 second delay allowing NSS to enter freerunning mode"),
			timer:sleep(10*1000);
		_ ->
			ok
	end,

	ct:pal("Action_5"),
	lists:foreach(
		fun(PortNo) ->
				verify_idl2_link_down([{nearEndPortNo, PortNo}]),
				verify_idl2_link_down_leaf([{farEndPortNo, PortNo},
											{node2Exists, Node2Exists}])
		end,
		[3, 4, 5, 6]),

	%% Check for unexpected signals
	nci_common_utils:check_outstanding_faults().

%%------------------------------------------------------------------------------
%% $Id DCI_IDL2_LINK3
%%
%% $Header
%%  IDL2 Link - Cold restart on leaf
%%
%% $Description
%%  Verifies that RICM sends correct indications after a restart of the leaf node.
%%
%% $Requirements
%%  TBD
%%
%% $HW config
%%  At least one IDL2 link
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  The DU BC is in state starting
%%  DP LMC is loaded
%%  DCI connection establish performed
%%  Subscribe DCI faults
%%
%% $Action_1
%%  Send RICM_START_IDL2_LINK_REQ on branch with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%  * farEndDuId = <read from config file>
%%  * farEndPortNo = <read from config file>
%%  * packetRatio = 1
%%  * lineRate = IDL2_LINE_RATE_2_5G
%%
%% $Result_1
%%  RICM_START_IDL2_LINK_CFM is received on branch with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%
%% $Action_2
%%  Wait for a RICM_START_IDL2_LINK_IND signal.
%%
%% $Result_2
%%  RICM_START_IDL2_LINK_IND is received on branch with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%  * packetRatio = 1
%%  * lineRate = IDL2_LINE_RATE_2_5G
%%  * availStatus = RICM_IDL2_LINK_AVAILABLE
%%
%% $Action_3
%%  When the leaf DU is type3:
%%  Wait for a RICM_START_IDL2_LINK_IND signal.
%%
%% $Result_3
%%  RICM_START_IDL2_LINK_IND is received on branch with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%  * packetRatio = 1
%%  * lineRate = IDL2_LINE_RATE_2_5G
%%  * availStatus = RICM_IDL2_LINK_AVAILABLE_SYNC
%%
%% $Action_4
%%  Perform cold restart on the leaf node.
%%
%% $Result_4
%%  The leaf node has restarted.
%%
%% $Action_5
%%  Wait for a RICM_START_IDL2_LINK_IND on branch.
%%
%% $Result_5
%%  RICM_START_IDL2_LINK_IND is received on branch with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%  * packetRatio = 1
%%  * lineRate = IDL2_LINE_RATE_2_5G
%%  * availStatus = RICM_IDL2_LINK_UNAVAILABLE
%%
%% $Action_6
%%  Wait for a RICM_START_IDL2_LINK_IND on branch.
%%
%% $Result_6
%%  RICM_START_IDL2_LINK_IND is received on branch with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%  * packetRatio = 1
%%  * lineRate = IDL2_LINE_RATE_2_5G
%%  * availStatus = RICM_IDL2_LINK_AVAILABLE
%%
%% $Action_7
%%  When the leaf DU is type3:
%%  Wait for a RICM_START_IDL2_LINK_IND on branch.
%%
%% $Result_7
%%  RICM_START_IDL2_LINK_IND is received on branch with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%  * packetRatio = 1
%%  * lineRate = IDL2_LINE_RATE_2_5G
%%  * availStatus = RICM_IDL2_LINK_AVAILABLE_SYNC
%%
%% $Action_8
%%  Send RICM_STOP_IDL2_LINK_REQ on branch with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%
%% $Result_8
%%  RICM_STOP_IDL2_LINK_CFM is received on branch with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%
%% $Action_9
%%  Repeat Action_1 to Action_8 for the remaining IDL2 links.
%%
%% $Result_9
%%  -
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%% -
%%
%% Revision history:
%%   2013-09-02 ebacemi
%%     First version
%%   2013-09-09 ebacemi
%%     Increased timetrap to 10 minutes
%%   2013-09-24 EBACEMI
%%     Updated to support type3-type3
%%   2014-01-20 EBACEMI
%%     Updated for WP6.1
%%   2014-02-17 EBACEMI
%%     Updated to wait for leaf DU to load all type3 SW before stopping the link
%%
%%------------------------------------------------------------------------------
dci_idl2_link3() ->
	[{timetrap, {minutes, 10}},
	 {userdata,[{wp, ""}, 
				{requirement, "TBD"},
				{slogan, "IDL2 Link - Cold restart on leaf"},
				{hwConfig, hwConfigIDL2_A}]}].

dci_idl2_link3(_Config) ->
	ct:pal("dci_idl2_link3"),

	subscribe_states(),

	Node2Exists = nci_ricm_utils:node_exists(node2),

	IDL2Links = nci_ricm_utils:get_all_idl2_links(),

	nci_bci_states:set_state([{state, starting_lmc_loaded}]),

	ok = nci_dci_actions:conn_establish([]),
	ok = nci_dci_actions:subscribe_faults([]),

	LineRate = ?IDL2_LINE_RATE_2_5G,
	PacketRatio = 1,

	lists:foreach(
		fun(IDL2Link) ->
				ct:pal("IDL2 link used: ~p", [IDL2Link]),

				FarEndDuId = proplists:get_value(farEndDuId, IDL2Link),
				FarEndDuLnhPath = proplists:get_value(farEndDuLnhPath, IDL2Link),

				ct:pal("Action_1"),
				ok = nci_dci_actions:start_idl2_link(IDL2Link ++ [{packetRatio, PacketRatio},
																  {lineRate, LineRate}]),
	
				ct:pal("Action_2"),
				{ok, _} = nci_dci_actions:idl2_link_ind(IDL2Link ++ [{packetRatio, PacketRatio},
																	 {lineRate, LineRate},
																	 {availStatus, ?RICM_IDL2_LINK_AVAILABLE}]),
	
				ct:pal("Action_3"),
				receive_time_sync_ind(IDL2Link, PacketRatio, LineRate),
				
				ct:pal("Action_4"),
				case Node2Exists of
					true ->
						nci_ricm_utils:cold_restart(node2);
					_ ->
						ct:pal("Waiting for ~s", [FarEndDuLnhPath]),
						ok = cpp_lib:poll_load_start(?SHELL_COMMAND, FarEndDuLnhPath, 120*1000),

						nci_common_utils:coli_cmd_with_output("restartObj piu " ++ integer_to_list(FarEndDuId) ++ " cold")
				end,

				ct:pal("Action_5"),
				{ok, _} = nci_dci_actions:idl2_link_ind(IDL2Link ++ [{packetRatio, PacketRatio},
																	 {lineRate, LineRate},
																	 {availStatus, ?RICM_IDL2_LINK_UNAVAILABLE}]),

				ct:pal("Action_6"),
				{ok, _} = nci_dci_actions:idl2_link_ind(IDL2Link ++ [{packetRatio, PacketRatio},
																	 {lineRate, LineRate},
																	 {availStatus, ?RICM_IDL2_LINK_AVAILABLE}]),

				ct:pal("Action_7"),
				receive_time_sync_ind(IDL2Link, PacketRatio, LineRate),
				
				%% Wait for the leaf DU to load all type3 SW
				case Node2Exists of
					true ->
						ok;
					_ ->
						ct:pal("Waiting for ~s", [FarEndDuLnhPath]),
						ok = cpp_lib:poll_load_start(?SHELL_COMMAND, FarEndDuLnhPath, 120*1000)
				end,

				ct:pal("Action_8"),
				ok = nci_dci_actions:stop_idl2_link(IDL2Link),
				
				wait_for_leaf(Node2Exists),

				ct:pal("Action_9")

		end,
		IDL2Links),

	%% Check for unexpected signals
	nci_common_utils:check_outstanding_faults().

%%------------------------------------------------------------------------------
%% $Id DCI_IDL2_LINK4
%%
%% $Header
%%  IDL2 Link - Start CPRI and IDL2 links (IDL2 first)
%%
%% $Description
%%  Verifies that it is possible to have an IDL2 link up at the same time as a CPRI link to a radio.
%%  The IDL2 link is started before the CPRI link.
%%
%% $Requirements
%%  TBD
%%
%% $HW config
%%  One IDL2 link and one RU
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  The DU BC is in state starting
%%  DP LMC is loaded
%%  DCI connection establish performed
%%  Subscribe DCI faults
%%
%% $Action_1
%%  Send RICM_START_IDL2_LINK_REQ with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%  * farEndDuId = <read from config file>
%%  * farEndPortNo = <read from config file>
%%  * packetRatio = 1
%%  * lineRate = IDL2_LINE_RATE_2_5G
%%
%% $Result_1
%%  RICM_START_IDL2_LINK_CFM is received with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%
%% $Action_2
%%  Wait for a RICM_START_IDL2_LINK_IND signal.
%%
%% $Result_2
%%  RICM_START_IDL2_LINK_IND is received with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%  * packetRatio = 1
%%  * lineRate = IDL2_LINE_RATE_2_5G
%%  * availStatus = RICM_IDL2_LINK_AVAILABLE
%%
%% $Action_3
%%  Wait for a RICM_START_IDL2_LINK_IND signal.
%%
%% $Result_3
%%  RICM_START_IDL2_LINK_IND is received with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%  * packetRatio = 1
%%  * lineRate = IDL2_LINE_RATE_2_5G
%%  * availStatus = RICM_IDL2_LINK_AVAILABLE_SYNC
%%
%% $Action_4
%%  Send RICM_START_CPRI_LINK_REQ with parameters:
%%  * ruId = <read from config file>
%%  * portNo = <read from config file>
%%  * cascadeNo = <read from config file>
%%  * primary = 1
%%
%% $Result_4a
%%  RICM_START_CPRI_LINK_CFM is received with parameters: 
%%  * ruId = <read from config file>
%%
%% $Result_4b
%%  RICM_START_CPRI_LINK_IND is received with parameters: 
%%  * ruId = <read from config file>
%%  * availStatus = 1
%%
%% $Action_5
%%  Send RICM_ADD_RADIO_CTL_REQ with parameters:
%%  * ruId = <read from config file>
%%
%% $Result_5a
%%  RICM_ADD_RADIO_CTL_CFM is received with parameters: 
%%  * ruId = <read from config file>
%%
%% $Result_5b
%%  RICM_ADD_RADIO_CTL_IND is received with parameters: 
%%  * ruId = <read from config file>
%%  * connStatus = 1
%%
%% $Action_6
%%  Verify that the IDL2 link is operational by calling verify_idl2_link_up().
%%
%% $Result_6
%%  IDL2 link is operational.
%%
%% $Action_7
%%  Verify that the CPRI link is up by executing lmclist on the RU.
%%
%% $Result_7
%%  The RU responds with a valid list of LMCs.
%%
%% $Action_8
%%  Send RICM_RESET_CPRI_LINK_REQ with parameters:
%%  * ruId = <read from config file>
%%
%% $Result_8a
%%  RICM_RESET_CPRI_LINK_CFM is received with parameters: 
%%  * ruId = <read from config file>
%%
%% $Result_8b
%%  RICM_RESET_CPRI_LINK_IND is received with parameters: 
%%  * ruId = <read from config file>
%%
%% $Action_9
%%  Verify that the IDL2 link is operational by calling verify_idl2_link_up().
%%
%% $Result_9
%%  IDL2 link is operational.
%%
%% $Postcondition
%%  Stop IDL2 link.
%%
%% $End
%%
%% Review:
%% -
%%
%% Revision history:
%%   2013-09-09 ebacemi
%%     First version
%%   2013-09-24 EBACEMI
%%     Updated to support type3-type3
%%   2014-01-20 EBACEMI
%%     Updated for WP6.1
%%
%%------------------------------------------------------------------------------
dci_idl2_link4() ->
	[{userdata,[{wp, ""}, 
				{requirement, "TBD"},
				{slogan, "IDL2 Link - Start CPRI and IDL2 links (IDL2 first)"},
				{hwConfig, hwConfigG}]}].

dci_idl2_link4(_Config) ->
	ct:pal("dci_idl2_link4"),

	subscribe_states(),

	Node2Exists = nci_ricm_utils:node_exists(node2),

	IDL2Link = nci_ricm_utils:get_first_idl2_link(),
	Radio = nci_ricm_utils:get_first_radio(),
	RuLnhPath = proplists:get_value(ruLnhPath, Radio),

	LineRate = ?IDL2_LINE_RATE_2_5G,
	PacketRatio = 1,

	nci_bci_states:set_state([{state, starting_lmc_loaded}]),

	ok = nci_dci_actions:conn_establish([]),
	ok = nci_dci_actions:subscribe_faults([]),

	ct:pal("Action_1"),
	ok = nci_dci_actions:start_idl2_link(IDL2Link ++ [{packetRatio, PacketRatio},
													  {lineRate, LineRate}]),

	ct:pal("Action_2"),
	{ok, _} = nci_dci_actions:idl2_link_ind(IDL2Link ++ [{packetRatio, PacketRatio},
														 {lineRate, LineRate},
														 {availStatus, ?RICM_IDL2_LINK_AVAILABLE}]),

	ct:pal("Action_3"),
	receive_time_sync_ind(IDL2Link, PacketRatio, LineRate),

	ct:pal("Action_4"),
	ok = nci_dci_actions:start_cpri_link(Radio),
	ok = nci_dci_actions:cpri_link_ind(Radio ++ [{availStatus, 1}]),

	ct:pal("Action_5"),
	ok = nci_dci_actions:add_radio_control(Radio),
	ok = nci_dci_actions:radio_control_ind(Radio ++ [{connStatus, 1}]),

	ct:pal("Action_6"),
	verify_idl2_link_up(IDL2Link ++ [{packetRatio, PacketRatio},
									 {lineRate, LineRate}]),
	verify_idl2_link_up_leaf(IDL2Link ++ [{packetRatio, PacketRatio},
										  {lineRate, LineRate},
										  {node2Exists, Node2Exists}]),

	ct:pal("Action_7"),
	nci_common_utils:coli_cmd("lhsh " ++ RuLnhPath ++ " lmclist", "SlotProt State"),

	ct:pal("Action_8"),
	ok = nci_dci_actions:reset_cpri_link(Radio),
	ok = nci_dci_actions:reset_cpri_link_ind(Radio),

	ct:pal("Action_9"),
	verify_idl2_link_up(IDL2Link ++ [{packetRatio, PacketRatio},
									 {lineRate, LineRate}]),
	verify_idl2_link_up_leaf(IDL2Link ++ [{packetRatio, PacketRatio},
										  {lineRate, LineRate},
										  {node2Exists, Node2Exists},
										  {loadLMC, false}]),

	ok = nci_dci_actions:stop_idl2_link(IDL2Link),

	wait_for_leaf(Node2Exists),

	%% Check for unexpected signals
	nci_common_utils:check_outstanding_faults().

%%------------------------------------------------------------------------------
%% $Id DCI_IDL2_LINK5
%%
%% $Header
%%  IDL2 Link - Start CPRI and IDL2 links (CPRI first)
%%
%% $Description
%%  Verifies that it is possible to have an IDL2 link up at the same time as a CPRI link to a radio.
%%  The CPRI link is started before the IDL2 link.
%%
%% $Requirements
%%  TBD
%%
%% $HW config
%%  One IDL2 link and one RU
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  The DU BC is in state starting
%%  DP LMC is loaded
%%  DCI connection establish performed
%%  Subscribe DCI faults
%%
%% $Action_1
%%  Send RICM_START_CPRI_LINK_REQ with parameters:
%%  * ruId = <read from config file>
%%  * portNo = <read from config file>
%%  * cascadeNo = <read from config file>
%%  * primary = 1
%%
%% $Result_1a
%%  RICM_START_CPRI_LINK_CFM is received with parameters: 
%%  * ruId = <read from config file>
%%
%% $Result_1b
%%  RICM_START_CPRI_LINK_IND is received with parameters: 
%%  * ruId = <read from config file>
%%  * availStatus = 1
%%
%% $Action_2
%%  Send RICM_ADD_RADIO_CTL_REQ with parameters:
%%  * ruId = <read from config file>
%%
%% $Result_2a
%%  RICM_ADD_RADIO_CTL_CFM is received with parameters: 
%%  * ruId = <read from config file>
%%
%% $Result_2b
%%  RICM_ADD_RADIO_CTL_IND is received with parameters: 
%%  * ruId = <read from config file>
%%  * connStatus = 1
%%
%% $Action_3
%%  Send RICM_START_IDL2_LINK_REQ with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%  * farEndDuId = <read from config file>
%%  * farEndPortNo = <read from config file>
%%  * packetRatio = 1
%%  * lineRate = IDL2_LINE_RATE_2_5G
%%
%% $Result_3
%%  RICM_START_IDL2_LINK_CFM is received with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%
%% $Action_4
%%  Wait for a RICM_START_IDL2_LINK_IND signal.
%%
%% $Result_4
%%  RICM_START_IDL2_LINK_IND is received with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%  * packetRatio = 1
%%  * lineRate = IDL2_LINE_RATE_2_5G
%%  * availStatus = RICM_IDL2_LINK_AVAILABLE
%%
%% $Action_5
%%  Wait for a RICM_START_IDL2_LINK_IND signal.
%%
%% $Result_5
%%  RICM_START_IDL2_LINK_IND is received with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%  * packetRatio = 1
%%  * lineRate = IDL2_LINE_RATE_2_5G
%%  * availStatus = RICM_IDL2_LINK_AVAILABLE_SYNC
%%
%% $Action_6
%%  Verify that the IDL2 link is operational by calling verify_idl2_link_up().
%%
%% $Result_6
%%  IDL2 link is operational.
%%
%% $Action_7
%%  Verify that the CPRI link is up by executing lmclist on the RU.
%%
%% $Result_7
%%  The RU responds with a valid list of LMCs.
%%
%% $Action_8
%%  Send RICM_STOP_IDL2_LINK_REQ with parameters:
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%
%% $Result_8
%%  RICM_STOP_IDL2_LINK_CFM is received with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%
%% $Action_9
%%  Verify that the CPRI link is up by executing lmclist on the RU.
%%
%% $Result_9
%%  The RU responds with a valid list of LMCs.
%%
%% $Postcondition
%%  Reset CPRI link.
%%
%% $End
%%
%% Review:
%% -
%%
%% Revision history:
%%   2013-09-09 ebacemi
%%     First version
%%   2013-09-24 EBACEMI
%%     Updated to support type3-type3
%%   2014-01-20 EBACEMI
%%     Updated for WP6.1
%%
%%------------------------------------------------------------------------------
dci_idl2_link5() ->
	[{userdata,[{wp, ""}, 
				{requirement, "TBD"},
				{slogan, "IDL2 Link - Start CPRI and IDL2 links (CPRI first)"},
				{hwConfig, hwConfigG}]}].

dci_idl2_link5(_Config) ->
	ct:pal("dci_idl2_link5"),
	subscribe_states(),

	Node2Exists = nci_ricm_utils:node_exists(node2),

	IDL2Link = nci_ricm_utils:get_first_idl2_link(),
	Radio = nci_ricm_utils:get_first_radio(),
	RuLnhPath = proplists:get_value(ruLnhPath, Radio),

	LineRate = ?IDL2_LINE_RATE_2_5G,
	PacketRatio = 1,

	nci_bci_states:set_state([{state, starting_lmc_loaded}]),

	ok = nci_dci_actions:conn_establish([]),
	ok = nci_dci_actions:subscribe_faults([]),

	ct:pal("Action_1"),
	ok = nci_dci_actions:start_cpri_link(Radio),
	ok = nci_dci_actions:cpri_link_ind(Radio ++ [{availStatus, 1}]),

	ct:pal("Action_2"),
	ok = nci_dci_actions:add_radio_control(Radio),
	ok = nci_dci_actions:radio_control_ind(Radio ++ [{connStatus, 1}]),

	ct:pal("Action_3"),
	ok = nci_dci_actions:start_idl2_link(IDL2Link ++ [{packetRatio, PacketRatio},
													  {lineRate, LineRate}]),

	ct:pal("Action_4"),
	{ok, _} = nci_dci_actions:idl2_link_ind(IDL2Link ++ [{packetRatio, PacketRatio},
														 {lineRate, LineRate},
														 {availStatus, ?RICM_IDL2_LINK_AVAILABLE}]),

	ct:pal("Action_5"),
	receive_time_sync_ind(IDL2Link, PacketRatio, LineRate),

	ct:pal("Action_6"),
	verify_idl2_link_up(IDL2Link ++ [{packetRatio, PacketRatio},
									 {lineRate, LineRate}]),
	verify_idl2_link_up_leaf(IDL2Link ++ [{packetRatio, PacketRatio},
										  {lineRate, LineRate},
										  {node2Exists, Node2Exists}]),

	ct:pal("Action_7"),
	nci_common_utils:coli_cmd("lhsh " ++ RuLnhPath ++ " lmclist", "SlotProt State"),

	ct:pal("Action_8"),
	ok = nci_dci_actions:stop_idl2_link(IDL2Link),

	wait_for_leaf(Node2Exists),

	ct:pal("Action_9"),
	nci_common_utils:coli_cmd("lhsh " ++ RuLnhPath ++ " lmclist", "SlotProt State"),

	ok = nci_dci_actions:reset_cpri_link(Radio),
	ok = nci_dci_actions:reset_cpri_link_ind(Radio),

	%% Check for unexpected signals
	nci_common_utils:check_outstanding_faults().

%%------------------------------------------------------------------------------
%% $Id DCI_IDL2_LINK6
%%
%% $Header
%%  IDL2 Link - Start all links
%%
%% $Description
%%  Verifies that it is possible to start all available IDL2 links simultaneously
%%
%% $Requirements
%%  TBD
%%
%% $HW config
%%  At least one 2.5G IDL2 link
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  The DU BC is in state starting
%%  DP LMC is loaded
%%  DCI connection establish performed
%%  Subscribe DCI faults
%%
%% $Action_1
%%  Send RICM_START_IDL2_LINK_REQ with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%  * farEndDuId = <read from config file>
%%  * farEndPortNo = <read from config file>
%%  * packetRatio = 1
%%  * lineRate = IDL2_LINE_RATE_2_5G
%%
%% $Result_1
%%  RICM_START_IDL2_LINK_CFM is received with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%
%% $Action_2
%%  Wait for a RICM_START_IDL2_LINK_IND signal.
%%
%% $Result_2
%%  RICM_START_IDL2_LINK_IND is received with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%  * packetRatio = 1
%%  * lineRate = <don't care>
%%  * availStatus = RICM_IDL2_LINK_AVAILABLE
%%
%% $Action_3
%%  Wait for a RICM_START_IDL2_LINK_IND signal.
%%
%% $Result_3
%%  RICM_START_IDL2_LINK_IND is received with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%  * packetRatio = 1
%%  * lineRate = <don't care>
%%  * availStatus = RICM_IDL2_LINK_AVAILABLE_SYNC
%%
%% $Action_4
%%  Repeat Action_1 and Action_3 for the remaining IDL2 links
%%  in the configuration.
%%
%% $Result_4
%%  -
%%
%% $Action_5
%%  For each IDL2 link, call verify_idl2_link_up on both
%%  branch and leaf nodes to verify that CPRI registers 
%%  have correct values.
%%
%% $Result_5
%%  Registers have correct values.
%%
%% $Action_6
%%  Send RICM_STOP_IDL2_LINK_REQ with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%
%% $Result_6
%%  RICM_STOP_IDL2_LINK_CFM is received with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%
%% $Action_7
%%  Repeat Action_5 for the remaining IDL2 links
%%  in the configuration.
%%
%% $Result_7
%%  -
%%
%% $Action_8
%%  For each IDL2 link, call verify_idl2_link_down on both
%%  branch and leaf nodes to verify that CPRI registers 
%%  have correct values.
%%
%% $Result_8
%%  Registers have correct values.
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%% -
%%
%% Revision history:
%%   2013-07-16 ebacemi
%%     First version
%%   2014-01-20 EBACEMI
%%     Updated for WP6.1
%%
%%------------------------------------------------------------------------------
dci_idl2_link6() ->
	[{userdata,[{wp, ""},
				{requirement, "TBD"},
				{slogan, "IDL2 Link - Start all links"},
			    {hwConfig, hwConfigIDL2_A}]}].

dci_idl2_link6(_Config) ->
	ct:pal("dci_idl2_link6"),

	subscribe_states(),  

	Node2Exists = nci_ricm_utils:node_exists(node2),

	LineRate = ?IDL2_LINE_RATE_2_5G,
	PacketRatio = 1,
	IDL2Links = nci_ricm_utils:get_all_idl2_links([{minLineRate, LineRate}]),

	nci_bci_states:set_state([{state, starting_lmc_loaded}]),

	ok = nci_dci_actions:conn_establish([]),
	ok = nci_dci_actions:subscribe_faults([]),

	ReceivedLinkInfo = 
		lists:map(
			fun(IDL2Link) ->
					ct:pal("IDL2 link used: ~p", [IDL2Link]),

					ct:pal("Action_1"),
					ok = nci_dci_actions:start_idl2_link(IDL2Link ++ [{packetRatio, PacketRatio},
																	  {lineRate, LineRate}]),

					%% lineRate is "don't care" since RICM might set up the link with a different 
					%% line rate than the specified one.
					ct:pal("Action_2"),
					{ok, Ind} = nci_dci_actions:idl2_link_ind(IDL2Link ++ [{packetRatio, PacketRatio},
																		   {lineRate, '_'},
																		   {availStatus, ?RICM_IDL2_LINK_AVAILABLE}]),

					ct:pal("Action_3"),
					receive_time_sync_ind(IDL2Link, PacketRatio, '_'),

					ct:pal("Action_4"),

					{IDL2Link, Ind#'RicmStartIdl2LinkIndS'.lineRate}
			end,
			IDL2Links),

	ct:pal("Action_5"), 
	lists:foreach(
		fun({IDL2Link, ReceivedLineRate}) ->
				verify_idl2_link_up(IDL2Link ++ [{packetRatio, PacketRatio},
												 {lineRate, ReceivedLineRate}]),
				verify_idl2_link_up_leaf(IDL2Link ++ [{packetRatio, PacketRatio},
													  {lineRate, ReceivedLineRate},
													  {node2Exists, Node2Exists}])
		end,
		ReceivedLinkInfo),

	lists:foreach(
		fun(IDL2Link) ->
				ct:pal("Action_6"),
				ok = nci_dci_actions:stop_idl2_link(IDL2Link),

				wait_for_leaf(Node2Exists),

				ct:pal("Action_7")
		end,
		lists:reverse(IDL2Links)),

	ct:pal("Action_8"),
	lists:foreach(
		fun({IDL2Link, _ReceivedLineRate}) ->
				verify_idl2_link_down(IDL2Link),
				verify_idl2_link_down_leaf(IDL2Link ++ [{node2Exists, Node2Exists}])
		end,
		ReceivedLinkInfo),

	%% Check for unexpected signals
	nci_common_utils:check_outstanding_faults().

%%------------------------------------------------------------------------------
%% $Id DCI_IDL2_LINK7
%%
%% $Header
%%  IDL2 Link - Triple configuration
%%
%% $Description
%%  Verifies that it is possible to set up all necessary IDL2 links in order to create
%%  a full mesh triple IDL2 configuration. Will also verify stop and restart of 
%%  redundant link(s) (link(s) not connected to DU1).
%%
%% $Requirements
%%  TBD
%%
%% $HW config
%%  At least one IDL2 link between DU1 and DU2
%%  At least one IDL2 link between DU1 and DU3
%%  At least one IDL2 link between DU2 and DU3
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  The DU BC is in state starting
%%  DP LMC is loaded
%%  DCI connection establish performed
%%  Subscribe DCI faults
%%
%% $Action_1
%%  Send RICM_START_IDL2_LINK_REQ with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%  * farEndDuId = <read from config file>
%%  * farEndPortNo = <read from config file>
%%  * packetRatio = 1
%%  * lineRate = IDL2_LINE_RATE_2_5G
%%
%% $Result_1
%%  RICM_START_IDL2_LINK_CFM is received with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%
%% $Action_2
%%  Wait for a RICM_START_IDL2_LINK_IND signal.
%%
%% $Result_2
%%  RICM_START_IDL2_LINK_IND is received with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%  * packetRatio = 1
%%  * lineRate = <don't care>
%%  * availStatus = RICM_IDL2_LINK_AVAILABLE
%%
%% $Action_3
%%  Wait for a RICM_START_IDL2_LINK_IND signal.
%%
%% $Result_3
%%  RICM_START_IDL2_LINK_IND is received with parameters: 
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%  * packetRatio = 1
%%  * lineRate = <don't care>
%%  * availStatus = RICM_IDL2_LINK_AVAILABLE_SYNC
%%
%% $Action_4
%%  Check FPGA registers on branch and leaf and verify that
%%  they have correct values.
%%
%% $Result_4
%%  Registers have correct values.
%%
%% $Action_5
%%  Repeat Action_1 to Action_4 for the remaining IDL2 links.
%%  This includes all IDL2 links starting from both DU1 and DU2.
%%
%% $Result_5
%%  -
%%
%% $Action_6
%%  For all IDL2 links:
%%  Check FPGA registers on branch and leaf and verify that
%%  they have correct values.
%%
%% $Result_6
%%  Registers have correct values.
%%
%% $Action_7
%%  Send RICM_STOP_IDL2_LINK_REQ for each redundant link with parameters:
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%
%% $Result_7
%%  RICM_STOP_IDL2_LINK_CFM is received with parameters:
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%
%% $Action_8
%%  Send RICM_START_IDL2_LINK_REQ with parameters:
%%  * nearEndDuId   = farEndDuId from link stopped in previous action
%%  * nearEndPortNo = farEndPortNo from link stopped in previous action
%%  * farEndDuId    = nearEndDuId from link stopped in previous action
%%  * farEndPortNo  = nearEndPortNo from link stopped in previous action
%%  * packetRatio   = 1
%%  * lineRate      = IDL2_LINE_RATE_2_5G
%%
%% $Result_8
%%  RICM_START_IDL2_LINK_CFM is received with parameters:
%%  * nearEndDuId = <as in action_7>
%%  * nearEndPortNo = <as in action_7>
%%
%% $Action_9
%%  Wait for a RICM_START_IDL2_LINK_IND signal.
%%
%% $Result_9
%%  RICM_START_IDL2_LINK_IND is received with parameters:
%%  * nearEndDuId = <as in action_7>
%%  * nearEndPortNo = <as in action_7>
%%  * packetRatio = 1
%%  * lineRate = <don't care>
%%  * availStatus = RICM_IDL2_LINK_AVAILABLE
%%
%% $Action_10
%%  Wait for a RICM_START_IDL2_LINK_IND signal.
%%
%% $Result_10
%%  RICM_START_IDL2_LINK_IND is received with parameters:
%%  * nearEndDuId = <as in action_7>
%%  * nearEndPortNo = <as in action_7>
%%  * packetRatio = 1
%%  * lineRate = <don't care>
%%  * availStatus = RICM_IDL2_LINK_AVAILABLE_SYNC
%%
%% $Action_11
%%  Repeat Action_8 to Action_10 for the remaining redundant IDL2 links.
%%  This includes all IDL2 links not connected with DU1.
%%
%% $Result_11
%% -
%%
%% $Action_12
%%  Send RICM_STOP_IDL2_LINK_REQ with parameters:
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%
%% $Result_12
%%  RICM_STOP_IDL2_LINK_CFM is received with parameters:
%%  * nearEndDuId = <read from config file>
%%  * nearEndPortNo = <read from config file>
%%
%% $Action_13
%%  Check FPGA registers on branch and leaf and verify that
%%  they have correct values.
%%
%% $Result_13
%%  Registers have correct values.
%%
%% $Action_14
%%  Repeat Action_12 to Action_13 for the remaining IDL2 links.
%%  This includes all IDL2 links starting from both DU1 and DU2.
%%
%% $Result_14
%%  -
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%% -
%%
%% Revision history:
%%   2013-10-28 ebacemi
%%     First version
%%   2013-12-10 emasnok
%%     Added stop-start of redundant link
%%   2014-01-20 EBACEMI
%%     Updated for WP6.1
%%
%%------------------------------------------------------------------------------
dci_idl2_link7() ->
	[{userdata,[{wp, ""},
				{requirement, "TBD"},
				{slogan, "IDL2 Link - Triple configuration"},
				{hwConfigDu0, hwConfigIDL2_A},
				{hwConfigDu1, hwConfigIDL2_A}]}].

dci_idl2_link7(_Config) ->
	ct:pal("dci_idl2_link7"),

	subscribe_states(),

	LineRate = ?IDL2_LINE_RATE_2_5G,
	PacketRatio = 1,

	nci_bci_states:set_state([{state, starting_lmc_loaded}]),

	IDL2LinksDU1 = nci_ricm_utils:get_all_idl2_links([{du, du0}]),
	IDL2LinksDU2 = nci_ricm_utils:get_all_idl2_links([{du, du1}]),

	AllIDL2Links = IDL2LinksDU1 ++ IDL2LinksDU2,
	ct:pal("Test case will create the following links: ~n~p", [AllIDL2Links]),

	lists:foreach(
		fun(IDL2Link) ->
				DcServer = get_dc_server(proplists:get_value(nearEndDuLnhPath, IDL2Link)),

				ok = nci_dci_actions:conn_establish([{dcServer, DcServer}]),
				ok = nci_dci_actions:subscribe_faults([{dcServer, DcServer}]),

				ct:pal("Action_1"),
				ok = nci_dci_actions:start_idl2_link(IDL2Link ++ [{packetRatio, PacketRatio},
																  {lineRate, LineRate},
																  {dcServer, DcServer}]),

				ct:pal("Action_2"),
				{ok, _} = nci_dci_actions:idl2_link_ind(IDL2Link ++ [{packetRatio, PacketRatio},
																	 {lineRate, '_'},
																	 {availStatus, ?RICM_IDL2_LINK_AVAILABLE}]),

				ct:pal("Action_3"),
				receive_time_sync_ind(IDL2Link, PacketRatio, '_'),

				%% Load DP LMC on all leaf DUs when DU1 is branch
				LoadLMC =
					case proplists:get_value(nearEndDuId, IDL2Link) of
						1 -> true;
						_ -> false
					end,

				ct:pal("Action_4"),
				verify_idl2_link_up(IDL2Link ++ [{packetRatio, PacketRatio},
												 {lineRate, LineRate}]),
				verify_idl2_link_up_leaf(IDL2Link ++ [{packetRatio, PacketRatio},
													  {lineRate, LineRate},
													  {loadLMC, LoadLMC}]),

				ct:pal("Action_5")
		end,
		AllIDL2Links),

	ct:pal("Action_6"),
	lists:foreach(
		fun(IDL2Link) ->
				verify_idl2_link_up(IDL2Link ++ [{packetRatio, PacketRatio},
												 {lineRate, LineRate}]),
				verify_idl2_link_up_leaf(IDL2Link ++ [{packetRatio, PacketRatio},
													  {lineRate, LineRate},
													  {loadLMC, false}])
		end,
		AllIDL2Links),

	%% Stop and restart redundant link(s) (links not connected with DU1) in opposite direction 
	%% and create a new updated AllIdl2Link-list
	AllIDL2Links1 =
		lists:foldl(
			fun(IDL2Link, Acc) ->
					NearEndDuId      = proplists:get_value(nearEndDuId,      IDL2Link),
					FarEndDuId       = proplists:get_value(farEndDuId,       IDL2Link),
					FarEndPortNo     = proplists:get_value(farEndPortNo,     IDL2Link),
					NearEndPortNo    = proplists:get_value(nearEndPortNo,    IDL2Link),
					NearEndDuLnhPath = proplists:get_value(nearEndDuLnhPath, IDL2Link),
					FarEndDuLnhPath  = proplists:get_value(farEndDuLnhPath,  IDL2Link),
					MaxLineRate      = proplists:get_value(maxLineRate,      IDL2Link),

					%% Stop link
					ct:pal("Stopping link from Du~w->Du~w", [NearEndDuId, FarEndDuId]),

					DcServerStopLink = get_dc_server(proplists:get_value(nearEndDuLnhPath, IDL2Link)),

					ct:pal("Action_7"),
					ok = nci_dci_actions:stop_idl2_link(IDL2Link ++ [{dcServer, DcServerStopLink}]),

					verify_idl2_link_down(IDL2Link),
					verify_idl2_link_down_leaf(IDL2Link),

					%% Create property list for link in opposite direction
					NewLink = [{nearEndPortNo   , FarEndPortNo},
							   {nearEndDuId     , FarEndDuId},
							   {nearEndDuLnhPath, FarEndDuLnhPath},
							   {farEndPortNo    , NearEndPortNo},
							   {farEndDuId      , NearEndDuId},
							   {farEndDuLnhPath , NearEndDuLnhPath},
							   {maxLineRate     , MaxLineRate}],

					ct:pal("Starting link from Du~w->Du~w", 
						   [proplists:get_value(nearEndDuId, NewLink),
							proplists:get_value(farEndDuId, NewLink)]),

					DcServerStartLink = get_dc_server(proplists:get_value(nearEndDuLnhPath, NewLink)),

					ok = nci_dci_actions:conn_establish([{dcServer, DcServerStartLink}]),
					ok = nci_dci_actions:subscribe_faults([{dcServer, DcServerStartLink}]),

					ct:pal("Action_8"),
					ok = nci_dci_actions:start_idl2_link(NewLink ++ [{packetRatio, PacketRatio},
																	 {lineRate, LineRate},
																	 {dcServer, DcServerStartLink}]),

					ct:pal("Action_9"),
					{ok, _} = nci_dci_actions:idl2_link_ind(NewLink ++ [{packetRatio, PacketRatio},
																		{lineRate, '_'},
																		{availStatus, ?RICM_IDL2_LINK_AVAILABLE}]),

					ct:pal("Action_10"),
					receive_time_sync_ind(NewLink, PacketRatio, '_'),

					ct:pal("Verify link in opposite direction is up...."),
					verify_idl2_link_up(NewLink ++ [{packetRatio, PacketRatio},
													{lineRate, LineRate}]),

					verify_idl2_link_up_leaf(NewLink ++ [{packetRatio, PacketRatio},
														 {lineRate, LineRate},
														 {loadLMC, false}]),

					ct:pal("Action_11"),

					Acc ++ [NewLink]
			end,
			IDL2LinksDU1,
			IDL2LinksDU2),


	ct:pal("Now stopping all links! AllLinks: ~n~p", [AllIDL2Links1]),

	lists:foreach(
		fun(IDL2Link) ->
				DcServer = get_dc_server(proplists:get_value(nearEndDuLnhPath, IDL2Link)),

				ct:pal("Stopping link from Du~p->Du~p",
					   [proplists:get_value(nearEndDuId, IDL2Link),
						proplists:get_value(farEndDuId, IDL2Link)]),

				ct:pal("Action_12"),
				ok = nci_dci_actions:stop_idl2_link(IDL2Link ++ [{dcServer, DcServer}]),

				%% Only wait for the leaf DU when we stop the link between it and DU1
				case proplists:get_value(nearEndDuId, IDL2Link) of
					1 ->
						wait_for_leaf(false);
					_ ->
						ok
				end,

				ct:pal("Action_13"),
				verify_idl2_link_down(IDL2Link),
				verify_idl2_link_down_leaf(IDL2Link),

				ct:pal("Action_14")
		end,
		lists:reverse(AllIDL2Links1)),


	%% Check for unexpected signals
	nci_common_utils:check_outstanding_faults().

%%------------------------------------------------------------------------------
%% $Id IDPI_CE1
%%
%% $Header
%%  IDPI Connection Establish - Normal use case
%%
%% $Description
%%  Verifies that a client can perform IDPI connection establish with a correct
%%  protocol revision.
%%
%% $Requirements
%%  TBD
%%
%% $HW config
%%  All
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  -
%%
%% $Action_1
%%  Send IDPI_CONNECTION_ESTABLISH_REQ with parameters: 
%%  * protocolRev = IDPI_PROTOCOL_REV
%%
%% $Result_1
%%  IDPI_CONN_ESTABLISH_CFM is received
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%% -
%%
%% Revision history:
%%   2013-04-22 ebacemi
%%     First version
%%
%%------------------------------------------------------------------------------
idpi_ce1() ->
	[{userdata,[{wp, ""}, 
				{requirement, "TBD"},
				{slogan, "IDPI Connection Establish - Normal use case"}]}].

idpi_ce1(_Config) ->
	ct:pal("idpi_ce1"),

	{ok, session_up} = coli:subscribe_state(?SHELL_COMMAND),
	{ok, session_up} = osegw:subscribe_state(?OSE_GW_DEAMON_1),

	ct:pal("Action_1"),
	ok = nci_idpi_actions:conn_establish([]),

	%% Check for unexpected signals
	nci_common_utils:check_outstanding_faults(),
	
	%% Restart client to make sure we are disconnected
	nci_common_utils:restart_osegw().


%%------------------------------------------------------------------------------
%% $Id IDPI_CE2
%%
%% $Header
%%  IDPI Connection Establish - Invalid protocol revision
%%
%% $Description
%%  Verifies that a client cannot perform IDPI connection establish with an invalid
%%  protocol revision.
%%
%% $Requirements
%%  TBD
%%
%% $HW config
%%  All
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  -
%%
%% $Action_1
%%  Send IDPI_CONNECTION_ESTABLISH_REQ with parameters: 
%%  * protocolRev = IDPI_PROTOCOL_REV + 1
%%
%% $Result_1
%%  IDPI_CONN_ESTABLISH_REJ is received with parameters:
%%  * errorCode = IDPI_ERROR_UNEXPECTED_MESSAGE_RECEIVED
%%  * errorDescription = "Invalid protocol revision"
%%
%% $Action_2
%%  Send IDPI_CONNECTION_ESTABLISH_REQ with parameters: 
%%  * protocolRev = 0
%%
%% $Result_2
%%  IDPI_CONN_ESTABLISH_REJ is received with parameters:
%%  * errorCode = IDPI_ERROR_UNEXPECTED_MESSAGE_RECEIVED
%%  * errorDescription = "Invalid protocol revision"
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%% -
%%
%% Revision history:
%%   2013-04-22 ebacemi
%%     First version
%%   2014-01-07 emasnok
%%     Changed check for invalid protocol rev from "IDPI_PROTOCOL_REV-1" to "0".
%%
%%------------------------------------------------------------------------------
idpi_ce2() ->
	[{userdata,[{wp, ""}, 
				{requirement, "TBD"},
				{slogan, "IDPI Connection Establish - Invalid protocol revision"}]}].

idpi_ce2(_Config) ->
	ct:pal("idpi_ce2"),

	{ok, session_up} = coli:subscribe_state(?SHELL_COMMAND),
	{ok, session_up} = osegw:subscribe_state(?OSE_GW_DEAMON_1),

	%% Connect to IDPI interface protocol rev + 1
	ct:pal("Action_1"),
	ok = nci_idpi_actions:conn_establish([{protocolRev, ?IDPI_PROTOCOL_REV+1},
										  {expectedSigNo, ?IDPI_CONN_ESTABLISH_REJ},
										  {errorCode, ?IDPI_ERROR_UNEXPECTED_MESSAGE_RECEIVED},
										  {errorDescription, {regexp, "Invalid protocol revision*"}}]),	

	%% Connect to IDPI interface protocol 0
	ct:pal("Action_2"),
	ok = nci_idpi_actions:conn_establish([{protocolRev, 0},
										  {expectedSigNo, ?IDPI_CONN_ESTABLISH_REJ},
										  {errorCode, ?IDPI_ERROR_UNEXPECTED_MESSAGE_RECEIVED},
										  {errorDescription, {regexp, "Invalid protocol revision*"}}]),

	%% Check for unexpected signals
	nci_common_utils:check_outstanding_faults(),
	
	%% Restart client to make sure we are disconnected
	nci_common_utils:restart_osegw().


%%------------------------------------------------------------------------------
%% $Id IDPI_CE3
%%
%% $Header
%%  IDPI Connection Establish - Maximum number of clients
%%
%% $Description
%%  Verifies that a maximum of 5 clients can connect using the IDPI interface. Four 
%%  clients will always be connected. Those clients are INTRA, CS and NSS (2 clients). 
%%  So the TC needs to connect one more in order to reach the maximum.
%%
%% $Requirements
%%  TBD
%%
%% $HW config
%%  All
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  Create an additional test client
%%
%% $Action_1
%%  Using 1st test client (OSE_GW_DEAMON_1) send IDPI_CONNECTION_ESTABLISH_REQ with parameters: 
%%  * protocolRev = IDPI_PROTOCOL_REV
%%
%% $Result_1
%%  IDPI_CONN_ESTABLISH_CFM is received
%%
%% $Action_2
%%  Using 2nd test client (OSE_GW_DEAMON_2) send IDPI_CONNECTION_ESTABLISH_REQ with parameters: 
%%  * protocolRev = IDPI_PROTOCOL_REV
%%
%% $Result_2
%%  IDPI_CONN_ESTABLISH_REJ is received with parameters:
%%  * errorCode = IDPI_ERROR_RESOURCE_SHORTAGE
%%  * errorDescription = "Too many clients already connected"
%%
%% $Postcondition
%%  Destroy the additional test client
%%
%% $End
%%
%% Review:
%% -
%%
%% Revision history:
%%   2013-04-22 ebacemi
%%     First version
%%   2013-11-22 ebacemi
%%     Updated to support 2 NSS clients
%%
%%------------------------------------------------------------------------------
idpi_ce3() ->
	[{userdata,[{wp, ""}, 
				{requirement, "TBD"},
				{slogan, "IDPI Connection Establish - Maximum number of clients"}]}].

idpi_ce3(_Config) ->
	ct:pal("idpi_ce3"),

	{ok, session_up} = coli:subscribe_state(?SHELL_COMMAND),
	{ok, session_up} = osegw:subscribe_state(?OSE_GW_DEAMON_1),

	OseGwList = [?OSE_GW_DEAMON_2],

	%% Create clients
	lists:foreach(
		fun(OseGw) ->
				ok = osegw:create(#osegw{name = OseGw, 
										 iap = osegw, 
										 opt = [{ping_timeout, 6000}, 
												{codec_config, 
												 {?SIG_MODS, 
												  sizeof, 
												  osegw_ose,big}}]})
		end,
		OseGwList),


	ct:pal("Action_1"),
	%% Connect 1 client to IDPI interface
	ok = nci_idpi_actions:conn_establish([{oseGwDeamon,?OSE_GW_DEAMON_1}]),

	ct:pal("Action_2"),
	%% Attempt to connect a 6th client to IDPI interface
	ok = nci_idpi_actions:conn_establish([{oseGwDeamon,?OSE_GW_DEAMON_2},
										  {expectedSigNo, ?IDPI_CONN_ESTABLISH_REJ},
										  {errorCode, ?IDPI_ERROR_RESOURCE_SHORTAGE},
										  {errorDescription, {regexp, "Too many clients already connected*"}}]),

	%% Destroy clients
	lists:foreach(
		fun(OseGw) ->
				ok = osegw:delete(OseGw)
		end,
		OseGwList),

	%% Check for unexpected signals
	nci_common_utils:check_outstanding_faults(),
	
	%% Restart client to make sure we are disconnected
	nci_common_utils:restart_osegw().


%%------------------------------------------------------------------------------
%% $Id IDPI_CSF3
%%
%% $Header
%%  IDPI Clock Status Fwd - Invalid clk status
%%
%% $Description
%%  Verifies that a client cannot send IDPI_CLK_STATUS_FWD with an invalid clk status.
%%
%% $Requirements
%%  TBD
%%
%% $HW config
%%  All
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  IDPI connection establish has been performed.
%%
%% $Action_1
%%  Send IDPI_CLK_STATUS_FWD with parameters:
%%  * clkStatus = IDPI_CLK_STATUS_FINE_TIME_SYNCED + 1
%%
%% $Result_1
%%  The string "INFO:ABN.*Invalid clkStatus" is found in the T&E log.
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%% -
%%
%% Revision history:
%%   2013-08-27 ebacemi
%%     First version
%%
%%------------------------------------------------------------------------------
idpi_csf3() ->
	[{userdata,[{wp, ""},
				{requirement, "TBD"},
				{slogan, "IDPI Clock Status Fwd - Invalid clkStatus"}]}].

idpi_csf3(_Config) ->
	ct:pal("idpi_csf3"),

	{ok, session_up} = coli:subscribe_state(?SHELL_COMMAND),
	{ok, session_up} = osegw:subscribe_state(?OSE_GW_DEAMON_1),

	ok = nci_idpi_actions:conn_establish([]),

	ct:pal("Action_1"),
	send_invalid_clk_status_fwd([{clkStatus, ?IDPI_CLK_STATUS_FINE_TIME_SYNCED + 1},
								 {expectedString, "INFO:ABN.*Invalid clkStatus"}]),

	%% Check for unexpected signals
	nci_common_utils:check_outstanding_faults(),
	
	%% Restart client to make sure we are disconnected
	nci_common_utils:restart_osegw().

%%------------------------------------------------------------------------------
%% $Id IDPI_GC1
%%
%% $Header
%%  IDPI Get Capability - Normal use case
%%
%% $Description
%%  Sends a IDPI  get cabability request and verifies that the following
%%  capabilities are supported:
%%   * Get Delay
%%
%% $Requirements
%%  TBD
%%
%% $HW config
%%  All
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  IDPI connection establish has been performed.
%%
%% $Action_1
%%  Send IDPI_GET_CAPABILITY_REQ
%%
%% $Result_1
%%  IDPI_GET_CAPABILITY_CFM is received with:
%%  * One capability supported.
%%  * Capabilities supported:
%%      * IDPI_CAPABILITY_DELAY_MEASUREMENT
%%
%% $Postcondition
%%  OSEGW disconnected
%%  No faults reported
%%
%% $End
%%
%% Review:
%% -
%%
%% Revision history:
%%   2013-04-22 ebacemi
%%     First version
%%   2013-10-31 emasnok
%%     Added check for delay measurement capability
%%
%%------------------------------------------------------------------------------
idpi_gc1() ->
	[{userdata,[{wp, ""},
				{requirement, "TBD"},
				{slogan, "IDPI Get Capability - Normal use case"}]}].

idpi_gc1(_Config) ->
	ct:pal("idpi_gc1"),

	{ok, session_up} = coli:subscribe_state(?SHELL_COMMAND),
	{ok, session_up} = osegw:subscribe_state(?OSE_GW_DEAMON_1),

	%% Connect to IDPI interface
	ok = nci_idpi_actions:conn_establish([]),

	NumberOfCapabilities = 1,
	IdpiCapabilityS = #'idpiCapabilityS'{capabilityIdentity = ?IDPI_CAPABILITY_DELAY_MEASUREMENT,
										 capabilityLength = '_',
										 capability = #capIdpiDelayMeasurementS{supported = ?IDPI_SUPPORTED}},
	Capabilities = [IdpiCapabilityS],

	ct:pal("Action_1"),
	ok = nci_idpi_actions:get_capability([{numberOfCapabilities, NumberOfCapabilities},
										  {capabilities, Capabilities}]),

	%% Check for unexpected signals
	nci_common_utils:check_outstanding_faults(),
	
	%% Restart client to make sure we are disconnected
	nci_common_utils:restart_osegw().


%%------------------------------------------------------------------------------
%% $Id IDPI_GD1
%%
%% $Header
%%  IDPI Get Delay - Normal use case
%%
%% $Description
%%  Verifies that delay measurement can be performed and that measurement values
%%  are within valid range. Measurement is performed three time:
%%    * Before IDL2 link is up (however won't fail if link is up)
%%    * After IDL2 link is up, linkStability should be unstable
%%    * Consecutive delay measurement should report linkStability as stable
%%  Also introduces CLK_STATUS state changes by sending IDPI_CLK_STATUS_FWD signals
%%  to RICM.
%%
%% $Requirements
%%  TBD
%%
%% $HW config
%%  At least one IDL2 link
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  IDPI connection establish has been performed.
%%  IDPI delay measurement capability supported.
%%  The DU BC is in state starting.
%%  DP LMC is loaded.
%%  DCI connection establish performed.
%%  Subscribe DCI faults
%%
%% $Action_1
%%  Start IDL2 link and send IDPI_CONN_ESTABLISH_REQ to RICM on the leaf DU
%%
%% $Result_1
%%  IDL2 link is operational in startup mode.
%%  Test client is connected to RICM via IDPI.
%%
%% $Action_2
%%  On both branch and leaf:
%%  Send two IDPI_GET_DELAY_REQ signals to RICM.
%%
%% $Result_2
%%  First IDPI_GET_DELAY_CFM is received with parameters
%%  * linkMode = IDPI_STARTUP_MODE
%%  * linkStability = <don't care>
%%  Second IDPI_GET_DELAY_CFM is received with parameters
%%  * linkMode = IDPI_STARTUP_MODE
%%  * linkStability = IDPI_DELAY_STABLE
%%
%% $Action_3
%%  Wait for IDL2 link to be in synchronous mode.
%%
%% $Result_3
%%  Receive RICM_START_IDL2_LINK_IND with availStatus = RICM_IDL2_LINK_AVAILABLE_SYNC.
%%
%% $Action_4
%%  On both branch and leaf:
%%  Send two IDPI_GET_DELAY_REQ signals to RICM with parameters:
%%  * nearEndPortNo = <from config file>
%%
%% $Result_4
%%  First IDPI_GET_DELAY_CFM is received with parameters
%%  * linkMode = IDPI_SYNCHRONOUS_MODE
%%  * linkStability = <don't care>
%%  * nearEndPortNo = <from config file>
%%  Second IDPI_GET_DELAY_CFM is received with parameters
%%  * linkMode = IDPI_SYNCHRONOUS_MODE
%%  * linkStability = IDPI_DELAY_STABLE
%%  * nearEndPortNo = <from config file>
%%
%% $Action_5
%%  Send IDPI_CLK_STATUS_FWD to RICM on the leaf DU with parameters:
%%  * nearEndPortNo = <from config file>
%%  * clkStatus = IDPI_CLK_STATUS_LOCKED
%%
%% $Result_6
%%  IDPI_CLK_STATUS_FWD is received by RICM.
%%
%% $Action_6
%%  Wait for IDL2 link to be in startup mode.
%%
%% $Result_6
%%  Receive RICM_START_IDL2_LINK_IND with availStatus = RICM_IDL2_LINK_AVAILABLE.
%%
%% $Action_7
%%  On both branch and leaf:
%%  Send two IDPI_GET_DELAY_REQ signals to RICM with parameters:
%%  * nearEndPortNo = <from config file>
%%
%% $Result_7
%%  First IDPI_GET_DELAY_CFM is received with parameters
%%  * linkMode = IDPI_STARTUP_MODE
%%  * linkStability = <don't care>
%%  * nearEndPortNo = <from config file>
%%  Second IDPI_GET_DELAY_CFM is received with parameters
%%  * linkMode = IDPI_STARTUP_MODE
%%  * linkStability = IDPI_DELAY_STABLE
%%  * nearEndPortNo = <from config file>
%%
%% $Action_8
%%  Send IDPI_CLK_STATUS_FWD to RICM on the leaf DU with parameters:
%%  * nearEndPortNo = <from config file>
%%  * clkStatus = IDPI_CLK_STATUS_COARSE_TIME_SYNCED
%%
%% $Result_8
%%  IDPI_CLK_STATUS_FWD is received by RICM.
%%
%% $Action_9
%%  On both branch and leaf:
%%  Send two IDPI_GET_DELAY_REQ signals to RICM with parameters:
%%  * nearEndPortNo = <from config file>
%%
%% $Result_9
%%  First IDPI_GET_DELAY_CFM is received with parameters
%%  * linkMode = IDPI_STARTUP_MODE on branch
%%  * linkMode = IDPI_SYNCHRONOUS_MODE on leaf
%%  * linkStability = <don't care>
%%  * nearEndPortNo = <from config file>
%%  Second IDPI_GET_DELAY_CFM is received with parameters
%%  * linkMode = IDPI_STARTUP_MODE on branch
%%  * linkMode = IDPI_SYNCHRONOUS_MODE on leaf
%%  * linkStability = IDPI_DELAY_STABLE
%%  * nearEndPortNo = <from config file>
%%
%% $Action_10
%%  Send IDPI_CLK_STATUS_FWD to RICM on the leaf DU with parameters:
%%  * nearEndPortNo = <from config file>
%%  * clkStatus = IDPI_CLK_STATUS_FINE_TIME_SYNCED
%%
%% $Result_10
%%  IDPI_CLK_STATUS_FWD is received by RICM.
%%
%% $Action_11
%%  Wait for IDL2 link to be in synchronous mode.
%%
%% $Result_11
%%  Receive RICM_START_IDL2_LINK_IND with availStatus = RICM_IDL2_LINK_AVAILABLE_SYNC.
%%
%% $Action_12
%%  On both branch and leaf:
%%  Send two IDPI_GET_DELAY_REQ signals to RICM with parameters:
%%  * nearEndPortNo = <from config file>
%%
%% $Result_12
%%  First IDPI_GET_DELAY_CFM is received with parameters
%%  * linkMode = IDPI_SYNCHRONOUS_MODE
%%  * linkStability = <don't care>
%%  * nearEndPortNo = <from config file>
%%  Second IDPI_GET_DELAY_CFM is received with parameters
%%  * linkMode = IDPI_SYNCHRONOUS_MODE
%%  * linkStability = IDPI_DELAY_STABLE
%%  * nearEndPortNo = <from config file>
%%
%% $Action_13
%%  Send IDPI_CLK_STATUS_FWD to RICM on the leaf DU with parameters:
%%  * nearEndPortNo = <from config file>
%%  * clkStatus = IDPI_CLK_STATUS_COARSE_TIME_SYNCED
%%
%% $Result_13
%%  IDPI_CLK_STATUS_FWD is received by RICM.
%%
%% $Action_14
%%  Wait for IDL2 link to be in startup mode.
%%
%% $Result_14
%%  Receive RICM_START_IDL2_LINK_IND with availStatus = RICM_IDL2_LINK_AVAILABLE.
%%
%% $Action_15
%%  On both branch and leaf:
%%  Send two IDPI_GET_DELAY_REQ signals to RICM with parameters:
%%  * nearEndPortNo = <from config file>
%%
%% $Result_15
%%  First IDPI_GET_DELAY_CFM is received with parameters
%%  * linkMode = IDPI_STARTUP_MODE on branch
%%  * linkMode = IDPI_SYNCHRONOUS_MODE on leaf
%%  * linkStability = <don't care>
%%  * nearEndPortNo = <from config file>
%%  Second IDPI_GET_DELAY_CFM is received with parameters
%%  * linkMode = IDPI_STARTUP_MODE on branch
%%  * linkMode = IDPI_SYNCHRONOUS_MODE on leaf
%%  * linkStability = IDPI_DELAY_STABLE
%%  * nearEndPortNo = <from config file>
%%
%% $Action_16
%%  Send IDPI_CLK_STATUS_FWD to RICM on the leaf DU with parameters:
%%  * nearEndPortNo = <from config file>
%%  * clkStatus = IDPI_CLK_STATUS_FINE_TIME_SYNCED
%%
%% $Result_16
%%  IDPI_CLK_STATUS_FWD is received by RICM.
%%
%% $Action_17
%%  Wait for IDL2 link to be in synchronous mode.
%%
%% $Result_17
%%  Receive RICM_START_IDL2_LINK_IND with availStatus = RICM_IDL2_LINK_AVAILABLE_SYNC.
%%
%% $Action_18
%%  On both branch and leaf:
%%  Send two IDPI_GET_DELAY_REQ signals to RICM with parameters:
%%  * nearEndPortNo = <from config file>
%%
%% $Result_18
%%  First IDPI_GET_DELAY_CFM is received with parameters
%%  * linkMode = IDPI_SYNCHRONOUS_MODE
%%  * linkStability = <don't care>
%%  * nearEndPortNo = <from config file>
%%  Second IDPI_GET_DELAY_CFM is received with parameters
%%  * linkMode = IDPI_SYNCHRONOUS_MODE
%%  * linkStability = IDPI_DELAY_STABLE
%%  * nearEndPortNo = <from config file>
%%
%% $Action_19
%%  Stop the IDL2 link.
%%
%% $Action_19
%%  IDL2 link is stopped.
%%
%% $Action_20
%%  Repeat Action_1 to Action_19 for all remaining IDL2 links
%%
%% $Result_20
%%  -
%%
%% $Postcondition
%%  OSEGW restarted
%%  No faults reported
%%
%% $End
%%
%% Review:
%% -
%%
%% Revision history:
%%   2013-10-31 emasnok
%%     First version
%%   2014-01-22 ebacemi
%%     Extended to test clk status state changes
%%
%%------------------------------------------------------------------------------
idpi_gd1() ->
	[{userdata,[{wp, ""},
				{requirement, "TBD"},
				{slogan, "IDPI Get Delay - Normal use case"},
				{hwConfig, hwConfigIDL2_A}]}].

idpi_gd1(_Config) ->
	ct:pal("idpi_gd1"),

	subscribe_states(),

	%% Set O&M state and then do DCI connect
	nci_bci_states:set_state([{state, starting_lmc_loaded}]),

	ok = nci_dci_actions:conn_establish([]),
	ok = nci_dci_actions:subscribe_faults([]),

	%% Connect to IDPI interface
	ok = nci_idpi_actions:conn_establish([]),

	%% Check that delay measurement capability exists
	Capabilities = [#'idpiCapabilityS'{capabilityIdentity = ?IDPI_CAPABILITY_DELAY_MEASUREMENT,
									   capabilityLength = '_',
									   capability = #capIdpiDelayMeasurementS{supported = 
																				  ?IDPI_SUPPORTED}}],
	ok = nci_idpi_actions:get_capability([{capabilities, Capabilities}]),

	IDL2Links = nci_ricm_utils:get_all_idl2_links(),

	lists:foreach(
		fun(IDL2Link) ->
				ct:pal("IDL2 link used: ~p", [IDL2Link]),

				FarEndDuLnhPath = proplists:get_value(farEndDuLnhPath, IDL2Link),
				FarEndIDPServer = FarEndDuLnhPath ++ "/" ++ ?IDP_SERVER,

				ct:pal("Action_1"),
				ok = nci_dci_actions:start_idl2_link(IDL2Link),

				%% Wait for IDL2 link indication (link available)
				{ok, _} = nci_dci_actions:idl2_link_ind(IDL2Link ++ [{availStatus, ?RICM_IDL2_LINK_AVAILABLE}]),

				ok = nci_idpi_actions:conn_establish([{idpServer, FarEndIDPServer}]),

				ct:pal("Action_2"),
				idpi_gd2_get_delay_action(IDL2Link, ?IDPI_STARTUP_MODE, ?IDPI_STARTUP_MODE),

				%% Wait for IDL2 link indication for link in sync mode
				ct:pal("Action_3"),
				{ok, _} = nci_dci_actions:idl2_link_ind(IDL2Link ++ [{availStatus, ?RICM_IDL2_LINK_AVAILABLE_SYNC}]),

				ct:pal("Action_4"),
				idpi_gd2_get_delay_action(IDL2Link, ?IDPI_SYNCHRONOUS_MODE, ?IDPI_SYNCHRONOUS_MODE),

				%% Fake FINE_TIME_SYNCED -> LOCKED state change
				ct:pal("Action_5"),
				nci_idpi_actions:clk_status_fwd_send([{idpServer, FarEndIDPServer},
													  {clkStatus, ?IDPI_CLK_STATUS_LOCKED}]),

				%% Delay for 1 second to make sure that the link is stable. Otherwise we may send IDPI_GET_DELAY_REQ signals
				%% while RICM is restarting the link which can cause the linkStability parameter verification to fail.
				timer:sleep(1000),

				ct:pal("Action_6"),
				{ok, _} = nci_dci_actions:idl2_link_ind(IDL2Link ++ [{availStatus, ?RICM_IDL2_LINK_AVAILABLE}]),

				ct:pal("Action_7"),
				idpi_gd2_get_delay_action(IDL2Link, ?IDPI_STARTUP_MODE, ?IDPI_STARTUP_MODE),

				%% Fake LOCKED -> COARSE_TIME_SYNCED state change
				ct:pal("Action_8"),
				nci_idpi_actions:clk_status_fwd_send([{idpServer, FarEndIDPServer},
													  {clkStatus, ?IDPI_CLK_STATUS_COARSE_TIME_SYNCED}]),

				%% Delay for 1 second to make sure that the link is stable. Otherwise we may send IDPI_GET_DELAY_REQ signals
				%% while RICM is restarting the link which can cause the linkStability parameter verification to fail.
				timer:sleep(1000),

				ct:pal("Action_9"),
				idpi_gd2_get_delay_action(IDL2Link, ?IDPI_STARTUP_MODE, ?IDPI_SYNCHRONOUS_MODE),

				%% Fake COARSE_TIME_SYNCED -> FINE_TIME_SYNCED state change
				ct:pal("Action_10"),
				nci_idpi_actions:clk_status_fwd_send([{idpServer, FarEndIDPServer},
													  {clkStatus, ?IDPI_CLK_STATUS_FINE_TIME_SYNCED}]),

				%% Delay for 1 second to make sure that the link is stable. Otherwise we may send IDPI_GET_DELAY_REQ signals
				%% while RICM is restarting the link which can cause the linkStability parameter verification to fail.
				timer:sleep(1000),

				ct:pal("Action_11"),
				{ok, _} = nci_dci_actions:idl2_link_ind(IDL2Link ++ [{availStatus, ?RICM_IDL2_LINK_AVAILABLE_SYNC}]),

				ct:pal("Action_12"),
				idpi_gd2_get_delay_action(IDL2Link, ?IDPI_SYNCHRONOUS_MODE, ?IDPI_SYNCHRONOUS_MODE),

				%% Fake FINE_TIME_SYNCED -> COARSE_TIME_SYNCED state change
				ct:pal("Action_13"),
				nci_idpi_actions:clk_status_fwd_send([{idpServer, FarEndIDPServer},
													  {clkStatus, ?IDPI_CLK_STATUS_COARSE_TIME_SYNCED}]),

				%% Delay for 1 second to make sure that the link is stable. Otherwise we may send IDPI_GET_DELAY_REQ signals
				%% while RICM is restarting the link which can cause the linkStability parameter verification to fail.
				timer:sleep(1000),

				ct:pal("Action_14"),
				{ok, _} = nci_dci_actions:idl2_link_ind(IDL2Link ++ [{availStatus, ?RICM_IDL2_LINK_AVAILABLE}]),

				ct:pal("Action_15"),
				idpi_gd2_get_delay_action(IDL2Link, ?IDPI_STARTUP_MODE, ?IDPI_SYNCHRONOUS_MODE),

				%% Fake COARSE_TIME_SYNCED -> FINE_TIME_SYNCED state change
				ct:pal("Action_16"),
				nci_idpi_actions:clk_status_fwd_send([{idpServer, FarEndIDPServer},
													  {clkStatus, ?IDPI_CLK_STATUS_FINE_TIME_SYNCED}]),

				%% Delay for 1 second to make sure that the link is stable. Otherwise we may send IDPI_GET_DELAY_REQ signals
				%% while RICM is restarting the link which can cause the linkStability parameter verification to fail.
				timer:sleep(1000),

				ct:pal("Action_17"),
				{ok, _} = nci_dci_actions:idl2_link_ind(IDL2Link ++ [{availStatus, ?RICM_IDL2_LINK_AVAILABLE_SYNC}]),

				ct:pal("Action_18"),
				idpi_gd2_get_delay_action(IDL2Link, ?IDPI_SYNCHRONOUS_MODE, ?IDPI_SYNCHRONOUS_MODE),

				ct:pal("Action_19"),
				ok = nci_dci_actions:stop_idl2_link(IDL2Link),

				wait_for_leaf(false),

				ct:pal("Action_20")
		end,
		IDL2Links),

	%% Check for unexpected signals
	nci_common_utils:check_outstanding_faults(),

	%% Restart client to make sure we are disconnected
	nci_common_utils:restart_osegw().

idpi_gd2_get_delay_action(IDL2Link, BranchLinkMode, LeafLinkMode) ->
	FarEndDuLnhPath = proplists:get_value(farEndDuLnhPath, IDL2Link),
	NearEndPortNo = proplists:get_value(nearEndPortNo, IDL2Link),
	FarEndPortNo = proplists:get_value(farEndPortNo, IDL2Link),
	FarEndIDPServer = FarEndDuLnhPath ++ "/" ++ ?IDP_SERVER,

	IDPServers = [{?IDP_SERVER, NearEndPortNo, BranchLinkMode},
				  {FarEndIDPServer, FarEndPortNo, LeafLinkMode}],

	lists:foreach(
		fun({IDPServer, PortNo, LinkMode}) ->
				%% Send delay measurement request, linkStability should be unstable, but since
				%% we can't control if other client has already done a delay measurment we can't 
				%% test it.
				nci_idpi_actions:get_delay([{idpServer, IDPServer},
											{nearEndPortNo, PortNo},
											{linkMode, LinkMode},
											{linkStability, '_'}]),

				%% Send delay measurement request, now linkStability should be reported stable 
				nci_idpi_actions:get_delay([{idpServer, IDPServer},
											{nearEndPortNo, PortNo},
											{linkMode, LinkMode},
											{linkStability, ?IDPI_DELAY_STABLE}])
		end,
		IDPServers).

%%------------------------------------------------------------------------------
%% $Id IDPI_GD3
%%
%% $Header
%%  IDPI Get Delay: Invalid nearEndPortNo
%%
%% $Description
%%  Verifies that a Get-Delay request is rejected if an invalid near end port
%%  number is used in the request.
%%
%% $Requirements
%%  TBD
%%
%% $HW config
%%  All
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  IDPI connection establish has been performed.
%%  IDPI delay measurement capability supported.
%%
%% $Action_1
%%  Send IDPI_GET_DELAY_REQ for nearEndPortNo=[0,7] (out-of-range)
%%
%% $Result_1
%%  Receive IDPI_GET_DELAY_REJ with:
%%    * errorCode = IDPI_ERROR_UNEXPECTED_PARAMETER_VALUE.
%%    * errorDescription = "Invalid nearEndPortNo".
%%
%% $Action_3
%%  Send IDPI_GET_DELAY_REQ with nearEndPortNo=[1,2] (radio reserved ports)
%%
%% $Result_3
%%  Receive IDPI_GET_DELAY_REJ for each port with:
%%    * errorCode = IDPI_ERROR_MISSING_CONFIGURATION_DATA.
%%    * errorDescription = "Invalid nearEndPortNo".
%%
%% $Postcondition
%%  OSEGW disconnected
%%  No faults reported
%%
%% $End
%%
%% Review:
%% -
%%
%% Revision history:
%%   2013-10-31 emasnok
%%     First version
%%
%%------------------------------------------------------------------------------
idpi_gd3() ->
	[{userdata,[{wp, ""},
				{requirement, "TBD"},
				{slogan, "IDPI Get Delay: Invalid nearEndPortNo"}]}].

idpi_gd3(_Config) ->
	ct:pal("idpi_gd3"),

	subscribe_states(),

	%% Connect to IDPI interface
	ok = nci_idpi_actions:conn_establish([]),

	%% Check that delay measurement capability exists
	Capabilities = [#'idpiCapabilityS'{capabilityIdentity = ?IDPI_CAPABILITY_DELAY_MEASUREMENT,
									   capabilityLength = '_',
									   capability = #capIdpiDelayMeasurementS{supported = 
																				  ?IDPI_SUPPORTED}}],
	ok = nci_idpi_actions:get_capability([{capabilities, Capabilities}]),

	ct:pal("Action_1"),

	%% Send get-delay requests for Out-of-range port numbers: 0,7
	lists:foreach(
		fun(NearEndPortNo) ->
				ct:pal("Send delay measurement for radio port:~p~n", [NearEndPortNo]),
				
				%% Send delay measurement request
				nci_idpi_actions:get_delay([{nearEndPortNo, NearEndPortNo},
											{expectedSigNo, ?IDPI_GET_DELAY_REJ},
											{errorCode, ?IDPI_ERROR_UNEXPECTED_PARAMETER_VALUE},
											{errorDescription, {regexp, "Invalid nearEndPortNo"}}])
		end,
		[0,7]),
	
	ct:pal("Action_2"),
	
	%% Send get-delay requests for radio reserved ports: 1,2
	lists:foreach(
		fun(NearEndPortNo) ->
				ct:pal("Send delay measurement for out-of-range port:~p~n", [NearEndPortNo]),
				
				%% Send delay measurement request
				nci_idpi_actions:get_delay([{nearEndPortNo, NearEndPortNo},
											{expectedSigNo, ?IDPI_GET_DELAY_REJ},
											{errorCode, ?IDPI_ERROR_MISSING_CONFIGURATION_DATA},
											{errorDescription, {regexp, "Invalid nearEndPortNo"}}])
		end,
		[1,2]),
	
	%% Check for unexpected signals
	nci_common_utils:check_outstanding_faults(),
	
	%% Restart client to make sure we are disconnected
	nci_common_utils:restart_osegw().


%%------------------------------------------------------------------------------
%% $Id IDPI_GD4
%%
%% $Header
%%  IDPI Get Delay: IDL2 link not started
%%
%% $Description
%%  Send a Get Delay Request for a Near End Port Number where the IDL2 link is
%%  not started.
%%
%% $Requirements
%%  TBD
%%
%% $HW config
%%  All
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  IDPI connection establish has been performed.
%%  IDPI delay measurement capability supported.
%%
%% $Action_1
%%  Send IDPI_GET_DELAY_REQ for nearEndPortNo=[3,4,5,6]
%%
%% $Result_1
%%  Receive IDPI_GET_DELAY_REJ for each port with:
%%    * errorCode = IDPI_ERROR_UNEXPECTED_MESSAGE_RECEIVED.
%%    * errorDescription = "IDL2 link not started".
%%
%% $Postcondition
%%  OSEGW disconnected
%%  No faults reported
%%
%% $End
%%
%% Review:
%% -
%%
%% Revision history:
%%   2013-10-31 emasnok
%%     First version
%%
%%------------------------------------------------------------------------------
idpi_gd4() ->
	[{userdata,[{wp, ""},
				{requirement, "TBD"},
				{slogan, "IDPI Get Delay: IDL2 link not started"}]}].

idpi_gd4(_Config) ->
	ct:pal("idpi_gd4"),

	subscribe_states(),
	
	%% Connect to IDPI interface
	ok = nci_idpi_actions:conn_establish([]),
	
	%% Check that delay measurement capability exists
	Capabilities = [#'idpiCapabilityS'{capabilityIdentity = ?IDPI_CAPABILITY_DELAY_MEASUREMENT,
									   capabilityLength = '_',
									   capability = #capIdpiDelayMeasurementS{supported = 
																				  ?IDPI_SUPPORTED}}],
	ok = nci_idpi_actions:get_capability([{capabilities, Capabilities}]),
	
	ct:pal("Action_1"),
	
	%% Send get-delay requests for port 3-6, valid port but no IDL2 link started
	lists:foreach(
		fun(NearEndPortNo) ->
				ct:pal("Send delay measurement for port:~p~n", [NearEndPortNo]),
				
				%% Send delay measurement request
				nci_idpi_actions:get_delay([{nearEndPortNo, NearEndPortNo},
											{expectedSigNo, ?IDPI_GET_DELAY_REJ},
											{errorCode, ?IDPI_ERROR_UNEXPECTED_MESSAGE_RECEIVED},
											{errorDescription, {regexp, "IDL2 link not started"}}])
		end,
		[3,4,5,6]),
	
	
	%% Check for unexpected signals
	nci_common_utils:check_outstanding_faults(),
	
	%% Restart client to make sure we are disconnected
	nci_common_utils:restart_osegw().


%%------------------------------------------------------------------------------
%% $Id IDPI_MCA3
%%
%% $Header
%%  IDPI Meta Channel Ack - Not subscribed
%%
%% $Description
%%  Verifies that a client must send IDPI subscribe meta channel before
%%  it can use the Meta Ack service.
%%
%% $Requirements
%%  TBD
%%
%% $HW config
%%  All
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  IDPI connection establish has been performed.
%%
%% $Action_1
%%  Send IDPI_META_CHANNEL_ACK with parameters:
%%  * nearEndPortNo = 3
%%  * sequenceNumber = 1
%%
%% $Result_1
%%  The string "INFO:ABN.*Client not subscribed" is found in the T&E log.
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%% -
%%
%% Revision history:
%%   2013-08-26 ebacemi
%%     First version
%%
%%------------------------------------------------------------------------------
idpi_mca3() ->
	[{userdata,[{wp, ""},
				{requirement, ""},
				{slogan, "IDPI Meta Channel Ack - Not subscribed"}]}].

idpi_mca3(_Config) ->
	ct:pal("idpi_mca3"),

	{ok, session_up} = coli:subscribe_state(?SHELL_COMMAND),
	{ok, session_up} = osegw:subscribe_state(?OSE_GW_DEAMON_1),

	ok = nci_idpi_actions:conn_establish([]),

	ct:pal("Action_1"),
	send_invalid_meta_channel_ack([{nearEndPortNo, 3},
								   {sequenceNumber, 1},
								   {expectedString, "INFO:ABN.*Client not subscribed"}]),

	%% Check for unexpected signals
	nci_common_utils:check_outstanding_faults(),
	
	%% Restart client to make sure we are disconnected
	nci_common_utils:restart_osegw().

%%------------------------------------------------------------------------------
%% $Id IDPI_MCD4
%%
%% $Header
%%  IDPI Meta Channel Ack - Invalid nearEndPortNo
%%
%% $Description
%%  Verifies that a client cannot send meta channel ack to invalid ports.
%%
%% $Requirements
%%  TBD
%%
%% $HW config
%%  All
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  IDPI connection establish has been performed.
%%  IDPI meta channel subscribtion has been performed.
%%
%% $Action_1
%%  Send IDPI_META_CHANNEL_ACK with parameters:
%%  * nearEndPortNo = [0, 1, 2, 7]
%%  * sequenceNumber = 1
%%
%% $Result_1
%%  The string "INFO:ABN.*Invalid nearEndPortNo" is found in the T&E log.
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%% -
%%
%% Revision history:
%%   2013-08-26 ebacemi
%%     First version
%%
%%------------------------------------------------------------------------------
idpi_mca4() ->
	[{userdata,[{wp, ""},
				{requirement, ""},
				{slogan, "IDPI Meta Channel Ack - Invalid nearEndPortNo"}]}].

idpi_mca4(_Config) ->
	ct:pal("idpi_mca4"),

	{ok, session_up} = coli:subscribe_state(?SHELL_COMMAND),
	{ok, session_up} = osegw:subscribe_state(?OSE_GW_DEAMON_1),

	ok = nci_idpi_actions:conn_establish([]),

	ok = nci_idpi_actions:subscribe_meta_channel([]),

	lists:foreach(
		fun(NearEndPortNo) ->
				ct:pal("Action_1"),
				send_invalid_meta_channel_ack([{nearEndPortNo, NearEndPortNo},
											   {sequenceNumber, 1},
											   {expectedString, "INFO:ABN.*Invalid nearEndPortNo"}])
		end,
		[0, 1, 2, 7]),

	%% Check for unexpected signals
	nci_common_utils:check_outstanding_faults(),
	
	%% Restart client to make sure we are disconnected
	nci_common_utils:restart_osegw().

%%------------------------------------------------------------------------------
%% $Id IDPI_MCA5
%%
%% $Header
%%  IDPI Meta Channel Ack - IDL2 link not started
%%
%% $Description
%%  Verifies that a client cannot send meta channel ack to an IDL2 link that is not started.
%%
%% $Requirements
%%  TBD
%%
%% $HW config
%%  All
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  IDPI connection establish has been performed.
%%  IDPI meta channel subscribtion has been performed.
%%
%% $Action_1
%%  Send IDPI_META_CHANNEL_ACK with parameters:
%%  * nearEndPortNo = 3
%%  * sequenceNumber = 1
%%
%% $Result_1
%%  The string "INFO:ABN.*IDL2 link not started" is found in the T&E log.
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%% -
%%
%% Revision history:
%%   2013-08-26 ebacemi
%%     First version
%%
%%------------------------------------------------------------------------------
idpi_mca5() ->
	[{userdata,[{wp, ""},
				{requirement, ""},
				{slogan, "IDPI Meta Channel Ack - IDL2 link not started"}]}].

idpi_mca5(_Config) ->
	ct:pal("idpi_mca5"),

	{ok, session_up} = coli:subscribe_state(?SHELL_COMMAND),
	{ok, session_up} = osegw:subscribe_state(?OSE_GW_DEAMON_1),

	ok = nci_idpi_actions:conn_establish([]),

	ok = nci_idpi_actions:subscribe_meta_channel([]),

	ct:pal("Action_1"),
	send_invalid_meta_channel_ack([{nearEndPortNo, 3},
								   {sequenceNumber, 1},
								   {expectedString, "INFO:ABN.*IDL2 link not started"}]),
	
	%% Check for unexpected signals
	nci_common_utils:check_outstanding_faults(),
	
	%% Restart client to make sure we are disconnected
	nci_common_utils:restart_osegw().


%%------------------------------------------------------------------------------
%% $Id IDPI_MCD3
%%
%% $Header
%%  IDPI Meta Channel Data - Not subscribed
%%
%% $Description
%%  Verifies that a client must send IDPI subscribe meta channel before
%%  it can use the Meta Data service.
%%
%% $Requirements
%%  TBD
%%
%% $HW config
%%  All
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  IDPI connection establish has been performed.
%%
%% $Action_1
%%  Send IDPI_META_CHANNEL_DATA with parameters:
%%  * nearEndPortNo = 3
%%  * sequenceNumber = 1
%%  * metaChannelMsg = []
%%
%% $Result_1
%%  The string "INFO:ABN.*Client not subscribed" is found in the T&E log.
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%% -
%%
%% Revision history:
%%   2013-08-26 ebacemi
%%     First version
%%
%%------------------------------------------------------------------------------
idpi_mcd3() ->
	[{userdata,[{wp, ""},
				{requirement, ""},
				{slogan, "IDPI Meta Channel Data - Not subscribed"}]}].

idpi_mcd3(_Config) ->
	ct:pal("idpi_mcd3"),

	{ok, session_up} = coli:subscribe_state(?SHELL_COMMAND),
	{ok, session_up} = osegw:subscribe_state(?OSE_GW_DEAMON_1),

	ok = nci_idpi_actions:conn_establish([]),

	ct:pal("Action_1"),
	send_invalid_meta_channel_data([{nearEndPortNo, 3},
									{sequenceNumber, 1},
									{metaChannelMsg, []},
									{expectedString, "INFO:ABN.*Client not subscribed"}]),

	%% Check for unexpected signals
	nci_common_utils:check_outstanding_faults(),
	
	%% Restart client to make sure we are disconnected
	nci_common_utils:restart_osegw().

%%------------------------------------------------------------------------------
%% $Id IDPI_MCD4
%%
%% $Header
%%  IDPI Meta Channel Data - Invalid nearEndPortNo
%%
%% $Description
%%  Verifies that a client cannot send meta channel data to invalid ports.
%%
%% $Requirements
%%  TBD
%%
%% $HW config
%%  All
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  IDPI connection establish has been performed.
%%  IDPI meta channel subscribtion has been performed.
%%
%% $Action_1
%%  Send IDPI_META_CHANNEL_DATA with parameters:
%%  * nearEndPortNo = [0, 1, 2, 7]
%%  * sequenceNumber = 1
%%  * metaChannelMsg = []
%%
%% $Result_1
%%  The string "INFO:ABN.*Invalid nearEndPortNo" is found in the T&E log.
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%% -
%%
%% Revision history:
%%   2013-08-26 ebacemi
%%     First version
%%
%%------------------------------------------------------------------------------
idpi_mcd4() ->
	[{userdata,[{wp, ""},
				{requirement, ""},
				{slogan, "IDPI Meta Channel Data - Invalid nearEndPortNo"}]}].

idpi_mcd4(_Config) ->
	ct:pal("idpi_mcd4"),

	{ok, session_up} = coli:subscribe_state(?SHELL_COMMAND),
	{ok, session_up} = osegw:subscribe_state(?OSE_GW_DEAMON_1),

	ok = nci_idpi_actions:conn_establish([]),

	ok = nci_idpi_actions:subscribe_meta_channel([]),

	lists:foreach(
		fun(NearEndPortNo) ->
				ct:pal("Action_1"),
				send_invalid_meta_channel_data([{nearEndPortNo, NearEndPortNo},
												{sequenceNumber, 1},
												{metaChannelMsg, []},
												{expectedString, "INFO:ABN.*Invalid nearEndPortNo"}])
		end,
		[0, 1, 2, 7]),

	%% Check for unexpected signals
	nci_common_utils:check_outstanding_faults(),
	
	%% Restart client to make sure we are disconnected
	nci_common_utils:restart_osegw().

%%------------------------------------------------------------------------------
%% $Id IDPI_MCD5
%%
%% $Header
%%  IDPI Meta Channel Data - IDL2 link not started
%%
%% $Description
%%  Verifies that a client cannot send meta channel data to an IDL2 link that is not started.
%%
%% $Requirements
%%  TBD
%%
%% $HW config
%%  All
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  IDPI connection establish has been performed.
%%  IDPI meta channel subscribtion has been performed.
%%
%% $Action_1
%%  Send IDPI_META_CHANNEL_DATA with parameters:
%%  * nearEndPortNo = 3
%%  * sequenceNumber = 1
%%  * metaChannelMsg = []
%%
%% $Result_1
%%  The string "INFO:ABN.*IDL2 link not started" is found in the T&E log.
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%% -
%%
%% Revision history:
%%   2013-08-26 ebacemi
%%     First version
%%
%%------------------------------------------------------------------------------
idpi_mcd5() ->
	[{userdata,[{wp, ""},
				{requirement, ""},
				{slogan, "IDPI Meta Channel Data - IDL2 link not started"}]}].

idpi_mcd5(_Config) ->
	ct:pal("idpi_mcd5"),

	{ok, session_up} = coli:subscribe_state(?SHELL_COMMAND),
	{ok, session_up} = osegw:subscribe_state(?OSE_GW_DEAMON_1),

	ok = nci_idpi_actions:conn_establish([]),

	ok = nci_idpi_actions:subscribe_meta_channel([]),

	ct:pal("Action_1"),
	send_invalid_meta_channel_data([{nearEndPortNo, 3},
									{sequenceNumber, 1},
									{metaChannelMsg, []},
									{expectedString, "INFO:ABN.*IDL2 link not started"}]),
	
	%% Check for unexpected signals
	nci_common_utils:check_outstanding_faults(),
	
	%% Restart client to make sure we are disconnected
	nci_common_utils:restart_osegw().


%%------------------------------------------------------------------------------
%% $Id IDPI_PDI1
%%
%% $Header
%%  IDPI Prop Dun Info - Normal use case
%%
%% $Description
%%  Verifies that a client can send IDPI_PROP_DUN_INFO_REQ with correct parameters when there
%%  is an operational IDL2 link present.
%%
%% $Requirements
%%  TBD
%%
%% $HW config
%%  At least one IDL2 link
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  The DU BC is in state starting on branch
%%  DP LMC is loaded on branch
%%  DCI connection establish performed on branch.
%%  Subscribe DCI faults on branch.
%%  One IDL2 link is operational in synchronous mode.
%%  IDPI connection establish has been performed on branch and leaf.
%%  IDPI link status subscribtion has been performed on branch and leaf.
%%  Retrieve the link status ind signal that corresponds to the IDL2 link on branch and leaf.
%%
%% $Action_1
%%  Send IDPI_PROP_DUN_INFO_REQ on branch with parameters:
%%  * sequenceNumber = <sequenceNumber from link status ind retrieved in the preconditions>
%%  * dunInfoStatus = IDPI_DUN_INFO_APPROVED
%%
%% $Result_1
%%  IDPI_PROP_DUN_INFO_CFM is received on branch.
%%
%% $Action_2
%%  Send IDPI_PROP_DUN_INFO_REQ on leaf with parameters:
%%  * sequenceNumber = <sequenceNumber from link status ind retrieved in the preconditions>
%%  * dunInfoStatus = IDPI_DUN_INFO_APPROVED
%%
%% $Result_2
%%  IDPI_PROP_DUN_INFO_CFM is received on leaf.
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%% -
%%
%% Revision history:
%%   2013-08-27 ebacemi
%%     First version
%%   2013-09-24 ebacemi
%%     Updated to work for type3-type3
%%   2014-01-20 ebacemi
%%     Updated for WP6.1
%%
%%------------------------------------------------------------------------------
idpi_pdi1() ->
	[{userdata,[{wp, ""},
				{requirement, ""},
				{slogan, "IDPI Prop Dun Info - Normal use case"},
				{hwConfig, hwConfigIDL2_A}]}].

idpi_pdi1(_Config) ->
	ct:pal("idpi_pdi1"),

	subscribe_states(),

	Node2Exists = nci_ricm_utils:node_exists(node2),

	IDL2Link = nci_ricm_utils:get_first_idl2_link(),
	ct:pal("IDL2 link used: ~p", [IDL2Link]),

	NearEndPortNo = proplists:get_value(nearEndPortNo, IDL2Link),
	FarEndPortNo = proplists:get_value(farEndPortNo, IDL2Link),
	FarEndDuLnhPath = proplists:get_value(farEndDuLnhPath, IDL2Link),
	PacketRatio = 1,
	LineRate = ?IDL2_LINE_RATE_2_5G,

	{LeafIDPServer, _LeafDuLnhPath, LeafOSEGW, _LeafColi} = get_leaf_du_parameters(Node2Exists, FarEndDuLnhPath),

	nci_bci_states:set_state([{state, starting_lmc_loaded}]),

	ok = nci_dci_actions:conn_establish([]),
	ok = nci_dci_actions:subscribe_faults([]),

	ok = nci_dci_actions:start_idl2_link(IDL2Link ++ [{packetRatio, PacketRatio},
													  {lineRate, LineRate}]),
	
	{ok, _} = nci_dci_actions:idl2_link_ind(IDL2Link ++ [{packetRatio, PacketRatio},
														 {lineRate, LineRate},
														 {availStatus, ?RICM_IDL2_LINK_AVAILABLE}]),
	
	receive_time_sync_ind(IDL2Link, PacketRatio, LineRate),

	ok = nci_idpi_actions:conn_establish([]),
	ok = nci_idpi_actions:subscribe_link_status([]),

	case Node2Exists of
		true ->
			ok;
		_ ->
			ct:pal("Waiting for ~s", [FarEndDuLnhPath]),
			ok = cpp_lib:poll_load_start(?SHELL_COMMAND, FarEndDuLnhPath, 120*1000)
	end,

	ok = nci_idpi_actions:conn_establish([{oseGwDeamon, LeafOSEGW},
										  {idpServer, LeafIDPServer}]),
	ok = nci_idpi_actions:subscribe_link_status([{oseGwDeamon, LeafOSEGW},
												 {idpServer, LeafIDPServer}]),

	%% Retrieve the link indication on branch that corresponds to portNo = nearEndPortNo
	StatusInd1 = get_idpi_link_status2_ind_from_port(NearEndPortNo, ?OSE_GW_DEAMON_1),

	%% Retrieve the link indication on leaf that corresponds to portNo = farEndPortNo
	StatusInd2 = get_idpi_link_status2_ind_from_port(FarEndPortNo, LeafOSEGW),

	ct:pal("Using this IDPI_LINK_STATUS_IND on branch:~n~p", [StatusInd1]),
	ct:pal("Using this IDPI_LINK_STATUS_IND on leaf:~n~p", [StatusInd2]),

	ct:pal("Action_1"),
	ok = nci_idpi_actions:prop_dun_info([{sequenceNumber, StatusInd1#'IdpiLinkStatus2IndS'.sequenceNumber},
										 {dunInfoStatus, ?IDPI_DUN_INFO_APPROVED}]),

	ct:pal("Action_2"),
	ok = nci_idpi_actions:prop_dun_info([{sequenceNumber, StatusInd2#'IdpiLinkStatus2IndS'.sequenceNumber},
										 {dunInfoStatus, ?IDPI_DUN_INFO_APPROVED},
										 {oseGwDeamon, LeafOSEGW},
										 {idpServer, LeafIDPServer}]),

	ok = nci_dci_actions:stop_idl2_link(IDL2Link),

	wait_for_leaf(Node2Exists),

	%% Receive the link down indications
	{ok, _} = nci_idpi_actions:link_status2_ind_recv_sig([{idl2LinkStatus, ?IDPI_LINK_UNAVAILABLE},
														  {nearEndPortNo, NearEndPortNo}]),
	case Node2Exists of
		true ->
			{ok, _} = nci_idpi_actions:link_status2_ind_recv_sig([{idl2LinkStatus, ?IDPI_LINK_UNAVAILABLE},
																  {nearEndPortNo, FarEndPortNo},
																  {oseGwDeamon, LeafOSEGW}]);
		_ ->
			ok
	end,
	
	%% Check for unexpected signals
	nci_common_utils:check_outstanding_faults(),
	
	%% Restart client to make sure we are disconnected
	nci_common_utils:restart_osegw(),

	case Node2Exists of
		true ->
			%% Check for unexpected signals
			nci_common_utils:check_outstanding_faults(?OSE_GW_DEAMON_NODE2_1, 2000),

			%% Restart client to make sure we are disconnected
			nci_common_utils:restart_osegw(?OSE_GW_DEAMON_NODE2_1, osegw_node2);
		_ ->
			ok
	end.


%%------------------------------------------------------------------------------
%% $Id IDPI_PDI3
%%
%% $Header
%%  IDPI Prop Dun Info - Invalid sequence number
%%
%% $Description
%%  Verifies that a client cannot send IDPI_PROP_DUN_INFO_REQ with an invalid sequence number.
%%
%% $Requirements
%%  TBD
%%
%% $HW config
%%  All
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  IDPI connection establish has been performed.
%%  IDPI subscribe link status has been performed.
%%  Retrieve the sequence number from the last received IDPI_LINK_STATUS_IND signal
%%
%% $Action_1
%%  Send IDPI_PROP_DUN_INFO_REQ with parameters:
%%  * sequenceNumber = <sequence number from preconditions + 1>
%%  * dunInfoStatus = IDPI_DUN_INFO_APPROVED
%%
%% $Result_1
%%  IDPI_PROP_DUN_INFO2_REJ is received with parameter:
%%  * errorCode = IDPI_ERROR_MISSING_CONFIGURATION_DATA
%%  * errorDescription = "Invalid sequenceNumber"
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%% -
%%
%% Revision history:
%%   2013-08-27 ebacemi
%%     First version
%%   2014-01-07 emasnok
%%     Updated with REJ signal, instead of T&E read
%%
%%------------------------------------------------------------------------------
idpi_pdi3() ->
	[{userdata,[{wp, ""},
				{requirement, "TBD"},
				{slogan, "IDPI Prop Dun Info - Invalid sequence number"}]}].

idpi_pdi3(_Config) ->
	ct:pal("idpi_pdi3"),

	{ok, session_up} = coli:subscribe_state(?SHELL_COMMAND),
	{ok, session_up} = osegw:subscribe_state(?OSE_GW_DEAMON_1),

	nci_idpi_actions:conn_establish([]),

	nci_idpi_actions:subscribe_link_status([]),

	{ok, _} = nci_idpi_actions:link_status2_ind_recv_sig([]),
	{ok, _} = nci_idpi_actions:link_status2_ind_recv_sig([]),
	{ok, _} = nci_idpi_actions:link_status2_ind_recv_sig([]),
	{ok, Sig} = nci_idpi_actions:link_status2_ind_recv_sig([]),

	ct:pal("Action_1"),

	ok = nci_idpi_actions:prop_dun_info([{sequenceNumber, Sig#'IdpiLinkStatus2IndS'.sequenceNumber + 1},
										 {dunInfoStatus, ?IDPI_DUN_INFO_APPROVED},
										 {expectedSigNo, ?IDPI_PROP_DUN_INFO2_REJ},
										 {errorCode, ?IDPI_ERROR_MISSING_CONFIGURATION_DATA},
										 {errorDescription, {regexp, "Invalid sequenceNumber"}}]),

	%% Check for unexpected signals
	nci_common_utils:check_outstanding_faults(),
	
	%% Restart client to make sure we are disconnected
	nci_common_utils:restart_osegw().

%%------------------------------------------------------------------------------
%% $Id IDPI_PDI4
%%
%% $Header
%%  IDPI Prop Dun Info - Invalid dun info status
%%
%% $Description
%%  Verifies that a client cannot send IDPI_PROP_DUN_INFO_REQ with an invalid dun info status.
%%
%% $Requirements
%%  TBD
%%
%% $HW config
%%  All
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  IDPI connection establish has been performed.
%%  IDPI subscribe link status has been performed.
%%  Retrieve the sequence number from the last received IDPI_LINK_STATUS_IND signal
%%
%% $Action_1
%%  Send IDPI_PROP_DUN_INFO_REQ with parameters:
%%  * sequenceNumber = <sequence number from preconditions>
%%  * dunInfoStatus = IDPI_DUN_INFO_APPROVED + 1
%%
%% $Result_1
%%  IDPI_PROP_DUN_INFO2_REJ is received with parameter:
%%  * errorCode = IDPI_ERROR_UNEXPECTED_PARAMETER_VALUE
%%  * errorDescription  = "Invalid dunInfoStatus"
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%% -
%%
%% Revision history:
%%   2013-08-27 ebacemi
%%     First version
%%   2014-01-07 emasnok
%%     Updated with REJ signal, instead of T&E read
%%
%%------------------------------------------------------------------------------
idpi_pdi4() ->
	[{userdata,[{wp, ""},
				{requirement, "TBD"},
				{slogan, "IDPI Prop Dun Info - Invalid dun info status"}]}].

idpi_pdi4(_Config) ->
	ct:pal("idpi_pdi4"),

	{ok, session_up} = coli:subscribe_state(?SHELL_COMMAND),
	{ok, session_up} = osegw:subscribe_state(?OSE_GW_DEAMON_1),

	nci_idpi_actions:conn_establish([]),

	nci_idpi_actions:subscribe_link_status([]),

	{ok, _} = nci_idpi_actions:link_status2_ind_recv_sig([]),
	{ok, _} = nci_idpi_actions:link_status2_ind_recv_sig([]),
	{ok, _} = nci_idpi_actions:link_status2_ind_recv_sig([]),
	{ok, Sig} = nci_idpi_actions:link_status2_ind_recv_sig([]),

	ct:pal("Action_1"),

	ok = nci_idpi_actions:prop_dun_info([{sequenceNumber, Sig#'IdpiLinkStatus2IndS'.sequenceNumber},
										 {dunInfoStatus, ?IDPI_DUN_INFO_APPROVED + 1},
										 {expectedSigNo, ?IDPI_PROP_DUN_INFO2_REJ},
										 {errorCode, ?IDPI_ERROR_UNEXPECTED_PARAMETER_VALUE},
										 {errorDescription, {regexp, "Invalid dunInfoStatus"}}]),

	%% Check for unexpected signals
	nci_common_utils:check_outstanding_faults(),
	
	%% Restart client to make sure we are disconnected
	nci_common_utils:restart_osegw().

%%------------------------------------------------------------------------------
%% $Id IDPI_PDI5
%%
%% $Header
%%  IDPI Prop Dun Info - No valid dun data
%%
%% $Description
%%  Verifies that a client cannot send IDPI_PROP_DUN_INFO_REQ with a sequence number that
%%  corresponds to an IDPI_LINK_STATUS_IND signal with no valid dun data.
%%
%% $Requirements
%%  TBD
%%
%% $HW config
%%  All
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  IDPI connection establish has been performed.
%%  IDPI subscribe link status has been performed.
%%  Retrieve the sequence number from the last received IDPI_LINK_STATUS_IND signal
%%
%% $Action_1
%%  Send IDPI_PROP_DUN_INFO_REQ with parameters:
%%  * sequenceNumber = <sequence number from preconditions>
%%  * dunInfoStatus = IDPI_DUN_INFO_APPROVED
%%
%% $Result_1
%%  IDPI_PROP_DUN_INFO2_REJ is received with parameter:
%%  * errorCode = IDPI_ERROR_MISSING_CONFIGURATION_DATA
%%  * errorDescription = "No valid dun data"
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%% -
%%
%% Revision history:
%%   2013-08-27 ebacemi
%%     First version
%%   2014-01-07 emasnok
%%     Updated with REJ signal, instead of T&E read
%%
%%------------------------------------------------------------------------------
idpi_pdi5() ->
	[{userdata,[{wp, ""},
				{requirement, "TBD"},
				{slogan, "IDPI Prop Dun Info - No valid DUN data"}]}].

idpi_pdi5(_Config) ->
	ct:pal("idpi_pdi5"),

	{ok, session_up} = coli:subscribe_state(?SHELL_COMMAND),
	{ok, session_up} = osegw:subscribe_state(?OSE_GW_DEAMON_1),

	nci_idpi_actions:conn_establish([]),

	nci_idpi_actions:subscribe_link_status([]),

	{ok, _} = nci_idpi_actions:link_status2_ind_recv_sig([]),
	{ok, _} = nci_idpi_actions:link_status2_ind_recv_sig([]),
	{ok, _} = nci_idpi_actions:link_status2_ind_recv_sig([]),
	{ok, Sig} = nci_idpi_actions:link_status2_ind_recv_sig([]),

	ct:pal("Action_1"),

	ok = nci_idpi_actions:prop_dun_info([{sequenceNumber, Sig#'IdpiLinkStatus2IndS'.sequenceNumber},
										 {dunInfoStatus, ?IDPI_DUN_INFO_APPROVED},
										 {expectedSigNo, ?IDPI_PROP_DUN_INFO2_REJ},
										 {errorCode, ?IDPI_ERROR_MISSING_CONFIGURATION_DATA},
										 {errorDescription, {regexp, "No valid dun data"}}]),

	%% Check for unexpected signals
	nci_common_utils:check_outstanding_faults(),
	
	%% Restart client to make sure we are disconnected
	nci_common_utils:restart_osegw().

%%------------------------------------------------------------------------------
%% $Id IDPI_PPI1
%%
%% $Header
%%  IDPI Prop Port Info - Normal use case
%%
%% $Description
%%  Verifies that a client can send IDPI_PROP_PORT_INFO_REQ with correct parameters when there
%%  is an operational IDL2 link present.
%%
%% $Requirements
%%  TBD
%%
%% $HW config
%%  At least one IDL2 link
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  The DU BC is in state starting on branch
%%  DP LMC is loaded on branch
%%  DCI connection establish performed on branch.
%%  Subscribe DCI faults on branch.
%%  One IDL2 link is operational in synchronous mode.
%%  IDPI connection establish has been performed on branch and leaf.
%%  IDPI link status subscribtion has been performed on branch and leaf.
%%  Retrieve the link status ind signal that corresponds to the IDL2 link on branch and leaf.
%%
%% $Action_1
%%  Send IDPI_PROP_PORT_INFO_REQ on branch with parameters:
%%  * sequenceNumber = <sequenceNumber from link status ind retrieved in the preconditions>
%%  * packetRatio = <packetRatio from link status ind retrieved in the preconditions>
%%  * portInfoStatus = IDPI_PORT_INFO_APPROVED
%%
%% $Result_1
%%  IDPI_PROP_PORT_INFO_CFM is received on branch.
%%
%% $Action_2
%%  Send IDPI_PROP_PORT_INFO_REQ on leaf with parameters:
%%  * sequenceNumber = <sequenceNumber from link status ind retrieved in the preconditions>
%%  * packetRatio = <packetRatio from link status ind retrieved in the preconditions>
%%  * dunInfoStatus = IDPI_PORT_INFO_APPROVED
%%
%% $Result_2
%%  IDPI_PROP_PORT_INFO_CFM is received on leaf.
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%% -
%%
%% Revision history:
%%   2013-08-27 ebacemi
%%     First version
%%   2013-09-24 ebacemi
%%     Updated to work for type3-type3
%%   2014-01-20 ebacemi
%%     Updated for WP6.1
%%
%%------------------------------------------------------------------------------
idpi_ppi1() ->
	[{userdata,[{wp, ""},
				{requirement, ""},
				{slogan, "IDPI Prop Port Info - Normal use case"},
				{hwConfig, hwConfigIDL2_A}]}].

idpi_ppi1(_Config) ->
	ct:pal("idpi_ppi1"),

	subscribe_states(),

	Node2Exists = nci_ricm_utils:node_exists(node2),

	IDL2Link = nci_ricm_utils:get_first_idl2_link(),
	ct:pal("IDL2 link used: ~p", [IDL2Link]),

	NearEndPortNo = proplists:get_value(nearEndPortNo, IDL2Link),
	FarEndPortNo = proplists:get_value(farEndPortNo, IDL2Link),
	FarEndDuLnhPath = proplists:get_value(farEndDuLnhPath, IDL2Link),
	PacketRatio = 1,
	LineRate = ?IDL2_LINE_RATE_2_5G,

	{LeafIDPServer, _LeafDuLnhPath, LeafOSEGW, _LeafColi} = get_leaf_du_parameters(Node2Exists, FarEndDuLnhPath),

	nci_bci_states:set_state([{state, starting_lmc_loaded}]),

	ok = nci_dci_actions:conn_establish([]),
	ok = nci_dci_actions:subscribe_faults([]),

	ok = nci_dci_actions:start_idl2_link(IDL2Link ++ [{packetRatio, PacketRatio},
													  {lineRate, LineRate}]),
	
	{ok, _} = nci_dci_actions:idl2_link_ind(IDL2Link ++ [{packetRatio, PacketRatio},
														 {lineRate, LineRate},
														 {availStatus, ?RICM_IDL2_LINK_AVAILABLE}]),
	
	receive_time_sync_ind(IDL2Link, PacketRatio, LineRate),

	ok = nci_idpi_actions:conn_establish([]),
	ok = nci_idpi_actions:subscribe_link_status([]),

	case Node2Exists of
		true ->
			wait_for_meta_channel_data_from_intra();
		_ ->
			ct:pal("Waiting for ~s", [FarEndDuLnhPath]),
			ok = cpp_lib:poll_load_start(?SHELL_COMMAND, FarEndDuLnhPath, 120*1000)
	end,

	ok = nci_idpi_actions:conn_establish([{oseGwDeamon, LeafOSEGW},
										  {idpServer, LeafIDPServer}]),
	ok = nci_idpi_actions:subscribe_link_status([{oseGwDeamon, LeafOSEGW},
												 {idpServer, LeafIDPServer}]),

	%% Retrieve the link indication on branch that corresponds to portNo = nearEndPortNo
	StatusInd1 = get_idpi_link_status2_ind_from_port(NearEndPortNo, ?OSE_GW_DEAMON_1),

	%% Retrieve the link indication on leaf that corresponds to portNo = farEndPortNo
	StatusInd2 = get_idpi_link_status2_ind_from_port(FarEndPortNo, LeafOSEGW),

	ct:pal("Using this IDPI_LINK_STATUS2_IND on branch:~n~p", [StatusInd1]),
	ct:pal("Using this IDPI_LINK_STATUS2_IND on leaf:~n~p", [StatusInd2]),

	ct:pal("Action_1"),
	ok = nci_idpi_actions:prop_port_info([{sequenceNumber, StatusInd1#'IdpiLinkStatus2IndS'.sequenceNumber},
										  {packetRatio, StatusInd1#'IdpiLinkStatus2IndS'.packetRatio},
										  {portInfoStatus, ?IDPI_PORT_INFO_APPROVED}]),

	ct:pal("Action_2"),
	ok = nci_idpi_actions:prop_port_info([{sequenceNumber, StatusInd2#'IdpiLinkStatus2IndS'.sequenceNumber},
										  {packetRatio, StatusInd2#'IdpiLinkStatus2IndS'.packetRatio},
										  {portInfoStatus, ?IDPI_PORT_INFO_APPROVED},
										  {oseGwDeamon, LeafOSEGW},
										  {idpServer, LeafIDPServer}]),

	ok = nci_dci_actions:stop_idl2_link(IDL2Link),

	wait_for_leaf(Node2Exists),

	%% Receive the link down indications
	{ok, _} = nci_idpi_actions:link_status2_ind_recv_sig([{idl2LinkStatus, ?IDPI_LINK_UNAVAILABLE},
														  {nearEndPortNo, NearEndPortNo}]),

	case Node2Exists of
		true ->
			{ok, _} = nci_idpi_actions:link_status2_ind_recv_sig([{idl2LinkStatus, ?IDPI_LINK_UNAVAILABLE},
																  {nearEndPortNo, FarEndPortNo},
																  {oseGwDeamon, LeafOSEGW}]);
		_ ->
			ok
	end,
	
	%% Check for unexpected signals
	nci_common_utils:check_outstanding_faults(),
	
	%% Restart client to make sure we are disconnected
	nci_common_utils:restart_osegw(),

	case Node2Exists of
		true ->
			%% Check for unexpected signals
			nci_common_utils:check_outstanding_faults(?OSE_GW_DEAMON_NODE2_1, 2000),

			%% Restart client to make sure we are disconnected
			nci_common_utils:restart_osegw(?OSE_GW_DEAMON_NODE2_1, osegw_node2);
		_ ->
			ok
	end.


%%------------------------------------------------------------------------------
%% $Id IDPI_PPI3
%%
%% $Header
%%  IDPI Prop Port Info - Invalid sequence number
%%
%% $Description
%%  Verifies that a client cannot send IDPI_PROP_PORT_INFO_REQ with an invalid sequence number.
%%
%% $Requirements
%%  TBD
%%
%% $HW config
%%  All
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  IDPI connection establish has been performed.
%%  IDPI subscribe link status has been performed.
%%  Retrieve the sequence number from the last received IDPI_LINK_STATUS_IND signal
%%
%% $Action_1
%%  Send IDPI_PROP_PORT_INFO_REQ with parameters:
%%  * sequenceNumber = <sequence number from preconditions + 1>
%%  * packetRatio = 1
%%  * portInfoStatus = IDPI_PORT_INFO_APPROVED
%%
%% $Result_1
%%  IDPI_PROP_PORT_INFO2_REJ is received with parameters:
%%  * errorCode = IDPI_ERROR_MISSING_CONFIGURATION_DATA
%%  * errorDescription = "Invalid sequenceNumber"
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%% -
%%
%% Revision history:
%%   2013-08-27 ebacemi
%%     First version
%%   2014-01-07 emasnok
%%     Updated with REJ signal, instead of T&E read
%%
%%------------------------------------------------------------------------------
idpi_ppi3() ->
	[{userdata,[{wp, ""},
				{requirement, "TBD"},
				{slogan, "IDPI Prop Port Info - Invalid sequence number"}]}].

idpi_ppi3(_Config) ->
	ct:pal("idpi_ppi3"),

	{ok, session_up} = coli:subscribe_state(?SHELL_COMMAND),
	{ok, session_up} = osegw:subscribe_state(?OSE_GW_DEAMON_1),

	nci_idpi_actions:conn_establish([]),

	nci_idpi_actions:subscribe_link_status([]),

	{ok, _} = nci_idpi_actions:link_status2_ind_recv_sig([]),
	{ok, _} = nci_idpi_actions:link_status2_ind_recv_sig([]),
	{ok, _} = nci_idpi_actions:link_status2_ind_recv_sig([]),
	{ok, Sig} = nci_idpi_actions:link_status2_ind_recv_sig([]),

	ct:pal("Action_1"),

	ok = nci_idpi_actions:prop_port_info([{sequenceNumber, Sig#'IdpiLinkStatus2IndS'.sequenceNumber + 1},
										  {packetRatio, 1},
										  {portInfoStatus, ?IDPI_PORT_INFO_APPROVED},
										  {expectedSigNo, ?IDPI_PROP_PORT_INFO2_REJ},
										  {errorCode, ?IDPI_ERROR_MISSING_CONFIGURATION_DATA},
										  {errorDescription, {regexp, "Invalid sequenceNumber"}}]),

	%% Check for unexpected signals
	nci_common_utils:check_outstanding_faults(),
	
	%% Restart client to make sure we are disconnected
	nci_common_utils:restart_osegw().

%%------------------------------------------------------------------------------
%% $Id IDPI_PPI4
%%
%% $Header
%%  IDPI Prop Port Info - Invalid port info status
%%
%% $Description
%%  Verifies that a client cannot send IDPI_PROP_PORT_INFO_REQ with an invalid port info status.
%%
%% $Requirements
%%  TBD
%%
%% $HW config
%%  All
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  IDPI connection establish has been performed.
%%  IDPI subscribe link status has been performed.
%%  Retrieve the sequence number from the last received IDPI_LINK_STATUS_IND signal
%%
%% $Action_1
%%  Send IDPI_PROP_PORT_INFO_REQ with parameters:
%%  * sequenceNumber = <sequence number from preconditions>
%%  * packetRatio = 1
%%  * portInfoStatus = IDPI_PORT_INFO_APPROVED + 1
%%
%% $Result_1
%%  IDPI_PROP_PORT_INFO2_REJ is received with parameters:
%%  * errorCode = IDPI_ERROR_UNEXPECTED_PARAMETER_VALUE
%%  * errorDescription = "Invalid portInfoStatus"
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%% -
%%
%% Revision history:
%%   2013-08-27 ebacemi
%%     First version
%%   2014-01-07 emasnok
%%     Updated with REJ signal, instead of T&E read
%%
%%------------------------------------------------------------------------------
idpi_ppi4() ->
	[{userdata,[{wp, ""},
				{requirement, "TBD"},
				{slogan, "IDPI Prop Port Info - Invalid port info status"}]}].

idpi_ppi4(_Config) ->
	ct:pal("idpi_ppi4"),

	{ok, session_up} = coli:subscribe_state(?SHELL_COMMAND),
	{ok, session_up} = osegw:subscribe_state(?OSE_GW_DEAMON_1),

	nci_idpi_actions:conn_establish([]),

	nci_idpi_actions:subscribe_link_status([]),

	{ok, _} = nci_idpi_actions:link_status2_ind_recv_sig([]),
	{ok, _} = nci_idpi_actions:link_status2_ind_recv_sig([]),
	{ok, _} = nci_idpi_actions:link_status2_ind_recv_sig([]),
	{ok, Sig} = nci_idpi_actions:link_status2_ind_recv_sig([]),

	ct:pal("Action_1"),

	ok = nci_idpi_actions:prop_port_info([{sequenceNumber, Sig#'IdpiLinkStatus2IndS'.sequenceNumber},
										  {packetRatio, 1},
										  {portInfoStatus, ?IDPI_PORT_INFO_APPROVED + 1},
										  {expectedSigNo, ?IDPI_PROP_PORT_INFO2_REJ},
										  {errorCode, ?IDPI_ERROR_UNEXPECTED_PARAMETER_VALUE},
										  {errorDescription, {regexp, "Invalid portInfoStatus"}}]),

	%% Check for unexpected signals
	nci_common_utils:check_outstanding_faults(),
	
	%% Restart client to make sure we are disconnected
	nci_common_utils:restart_osegw().

%%------------------------------------------------------------------------------
%% $Id IDPI_PPI5
%%
%% $Header
%%  IDPI Prop Port Info - Invalid packet ratio
%%
%% $Description
%%  Verifies that a client cannot send IDPI_PROP_PORT_INFO_REQ with an invalid packet ratio.
%%
%% $Requirements
%%  TBD
%%
%% $HW config
%%  All
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  IDPI connection establish has been performed.
%%  IDPI subscribe link status has been performed.
%%  Retrieve the sequence number from the last received IDPI_LINK_STATUS_IND signal
%%
%% $Action_1
%%  Send IDPI_PROP_PORT_INFO_REQ with parameters:
%%  * sequenceNumber = <sequence number from preconditions>
%%  * packetRatio = [0, 16]
%%  * portInfoStatus = IDPI_PORT_INFO_APPROVED
%%
%% $Result_1
%%  IDPI_PROP_PORT_INFO2_REJ is received with parameters:
%%  * errorCode = IDPI_ERROR_UNEXPECTED_PARAMETER_VALUE
%%  * errorDescription = "Invalid packetRatio"
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%% -
%%
%% Revision history:
%%   2013-08-27 ebacemi
%%     First version
%%   2014-01-07 emasnok
%%     Updated with REJ signal, instead of T&E read
%%
%%------------------------------------------------------------------------------
idpi_ppi5() ->
	[{userdata,[{wp, ""},
				{requirement, "TBD"},
				{slogan, "IDPI Prop Port Info - Invalid packet ratio"}]}].

idpi_ppi5(_Config) ->
	ct:pal("idpi_ppi5"),

	{ok, session_up} = coli:subscribe_state(?SHELL_COMMAND),
	{ok, session_up} = osegw:subscribe_state(?OSE_GW_DEAMON_1),

	nci_idpi_actions:conn_establish([]),

	nci_idpi_actions:subscribe_link_status([]),

	{ok, _} = nci_idpi_actions:link_status2_ind_recv_sig([]),
	{ok, _} = nci_idpi_actions:link_status2_ind_recv_sig([]),
	{ok, _} = nci_idpi_actions:link_status2_ind_recv_sig([]),
	{ok, Sig} = nci_idpi_actions:link_status2_ind_recv_sig([]),

	lists:foreach(
		fun(PacketRatio) ->
				ct:pal("Action_1"),

				ok = nci_idpi_actions:prop_port_info([{sequenceNumber, Sig#'IdpiLinkStatus2IndS'.sequenceNumber},
													  {packetRatio, PacketRatio},
													  {portInfoStatus, ?IDPI_PORT_INFO_APPROVED},
													  {expectedSigNo, ?IDPI_PROP_PORT_INFO2_REJ},
													  {errorCode, ?IDPI_ERROR_UNEXPECTED_PARAMETER_VALUE},
													  {errorDescription, {regexp, "Invalid packetRatio"}}])
		end,
		[0, 16]),		

	%% Check for unexpected signals
	nci_common_utils:check_outstanding_faults(),
	
	%% Restart client to make sure we are disconnected
	nci_common_utils:restart_osegw().

%%------------------------------------------------------------------------------
%% $Id IDPI_PPI6
%%
%% $Header
%%  IDPI Prop Port Info - No valid port data
%%
%% $Description
%%  Verifies that a client cannot send IDPI_PROP_PORT_INFO_REQ with a sequence number that
%%  corresponds to an IDPI_LINK_STATUS_IND signal with no valid port data.
%%
%% $Requirements
%%  TBD
%%
%% $HW config
%%  All
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  IDPI connection establish has been performed.
%%  IDPI subscribe link status has been performed.
%%  Retrieve the sequence number from the last received IDPI_LINK_STATUS_IND signal
%%
%% $Action_1
%%  Send IDPI_PROP_PORT_INFO_REQ with parameters:
%%  * sequenceNumber = <sequence number from preconditions>
%%  * packetRatio = 1
%%  * portInfoStatus = IDPI_PORT_INFO_APPROVED
%%
%% $Result_1
%%  IDPI_PROP_PORT_INFO2_REJ is received with parameters:
%%  * errorCode = IDPI_ERROR_MISSING_CONFIGURATION_DATA
%%  * errorDescription = "No valid port data"
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%% -
%%
%% Revision history:
%%   2013-08-27 ebacemi
%%     First version
%%   2014-01-07 emasnok
%%     Updated with REJ signal, instead of T&E read
%%
%%------------------------------------------------------------------------------
idpi_ppi6() ->
	[{userdata,[{wp, ""},
				{requirement, "TBD"},
				{slogan, "IDPI Prop Port Info - No valid port data"}]}].

idpi_ppi6(_Config) ->
	ct:pal("idpi_ppi6"),

	{ok, session_up} = coli:subscribe_state(?SHELL_COMMAND),
	{ok, session_up} = osegw:subscribe_state(?OSE_GW_DEAMON_1),

	nci_idpi_actions:conn_establish([]),

	nci_idpi_actions:subscribe_link_status([]),

	{ok, _} = nci_idpi_actions:link_status2_ind_recv_sig([]),
	{ok, _} = nci_idpi_actions:link_status2_ind_recv_sig([]),
	{ok, _} = nci_idpi_actions:link_status2_ind_recv_sig([]),
	{ok, Sig} = nci_idpi_actions:link_status2_ind_recv_sig([]),

	ct:pal("Action_1"),

	ok = nci_idpi_actions:prop_port_info([{sequenceNumber, Sig#'IdpiLinkStatus2IndS'.sequenceNumber},
										  {packetRatio, 1},
										  {portInfoStatus, ?IDPI_PORT_INFO_APPROVED},
										  {expectedSigNo, ?IDPI_PROP_PORT_INFO2_REJ},
										  {errorCode, ?IDPI_ERROR_MISSING_CONFIGURATION_DATA},
										  {errorDescription, {regexp, "No valid port data"}}]),

	%% Check for unexpected signals
	nci_common_utils:check_outstanding_faults(),
	
	%% Restart client to make sure we are disconnected
	nci_common_utils:restart_osegw().

%%------------------------------------------------------------------------------
%% $Id IDPI_PPI7
%%
%% $Header
%%  IDPI Prop Port Info - Packet ratio higher than IDPI_LINK_STATUS_IND
%%
%% $Description
%%  Verifies that a client cannot send IDPI_PROP_PORT_INFO_REQ with a packet ratio 
%%  that is higher than the packet radio in the IDPI_LINK_STATUS_IND signal refered 
%%  to by the given sequenceNumber.
%%
%% $Requirements
%%  TBD
%%
%% $HW config
%%  At least one IDL2 link
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  The DU BC is in state starting on branch
%%  DP LMC is loaded on branch
%%  DCI connection establish performed on branch.
%%  Subscribe DCI faults on branch.
%%  One IDL2 link is operational in synchronous mode.
%%  IDPI connection establish has been performed on branch and leaf.
%%  IDPI link status subscribtion has been performed on branch and leaf.
%%  Retrieve the link status ind signal that corresponds to the IDL2 link on branch and leaf.
%%
%% $Action_1
%%  Send IDPI_PROP_PORT_INFO_REQ on branch with parameters:
%%  * sequenceNumber = <sequenceNumber from link status ind retrieved in the preconditions>
%%  * packetRatio = <packetRatio from link status ind retrieved in the preconditions + 1>
%%  * portInfoStatus = IDPI_PORT_INFO_APPROVED
%%
%% $Result_1
%%  IDPI_PROP_PORT_INFO2_REJ is received with parameters:
%%  * errorCode = IDPI_ERROR_MISSING_CONFIGURATION_DATA
%%  * errorDescription = "Invalid packetRatio"
%%
%% $Action_2
%%  Send IDPI_PROP_PORT_INFO_REQ on leaf with parameters:
%%  * sequenceNumber = <sequenceNumber from link status ind retrieved in the preconditions>
%%  * packetRatio = <packetRatio from link status ind retrieved in the preconditions + 1>
%%  * dunInfoStatus = IDPI_PORT_INFO_APPROVED
%%
%% $Result_2
%%  IDPI_PROP_PORT_INFO2_REJ is received on leaf with parameters:
%%  * errorCode = IDPI_ERROR_MISSING_CONFIGURATION_DATA
%%  * errorDescription = "Invalid packetRatio"
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%% -
%%
%% Revision history:
%%   2013-08-28 ebacemi
%%     First version
%%   2013-09-12 ebacemi
%%     Updated expected string in Result_2
%%   2013-09-24 ebacemi
%%     Updated to work for type3-type3
%%   2014-01-07 emasnok
%%     Updated with REJ signal, instead of T&E read
%%   2014-01-20 ebacemi
%%     Updated for WP6.1
%%
%%------------------------------------------------------------------------------
idpi_ppi7() ->
	[{userdata,[{wp, ""},
				{requirement, ""},
				{slogan, "IDPI Prop Port Info - Packet ratio higher than IDPI_LINK_STATUS_IND"},
				{hwConfig, hwConfigIDL2_A}]}].

idpi_ppi7(_Config) ->
	ct:pal("idpi_ppi7"),

	subscribe_states(),

	Node2Exists = nci_ricm_utils:node_exists(node2),

	IDL2Link = nci_ricm_utils:get_first_idl2_link(),
	ct:pal("IDL2 link used: ~p", [IDL2Link]),

	NearEndPortNo = proplists:get_value(nearEndPortNo, IDL2Link),
	FarEndPortNo = proplists:get_value(farEndPortNo, IDL2Link),
	FarEndDuLnhPath = proplists:get_value(farEndDuLnhPath, IDL2Link),
	PacketRatio = 1,
	LineRate = ?IDL2_LINE_RATE_2_5G,

	{LeafIDPServer, _LeafDuLnhPath, LeafOSEGW, _LeafColi} = get_leaf_du_parameters(Node2Exists, FarEndDuLnhPath),

	nci_bci_states:set_state([{state, starting_lmc_loaded}]),

	ok = nci_dci_actions:conn_establish([]),
	ok = nci_dci_actions:subscribe_faults([]),

	ok = nci_dci_actions:start_idl2_link(IDL2Link ++ [{packetRatio, PacketRatio},
													  {lineRate, LineRate}]),
	
	{ok, _} = nci_dci_actions:idl2_link_ind(IDL2Link ++ [{packetRatio, PacketRatio},
														 {lineRate, LineRate},
														 {availStatus, ?RICM_IDL2_LINK_AVAILABLE}]),
	
	receive_time_sync_ind(IDL2Link, PacketRatio, LineRate),

	ok = nci_idpi_actions:conn_establish([]),
	ok = nci_idpi_actions:subscribe_link_status([]),

	case Node2Exists of
		true ->
			wait_for_meta_channel_data_from_intra();
		_ ->
			ct:pal("Waiting for ~s", [FarEndDuLnhPath]),
			ok = cpp_lib:poll_load_start(?SHELL_COMMAND, FarEndDuLnhPath, 120*1000)
	end,

	ok = nci_idpi_actions:conn_establish([{oseGwDeamon, LeafOSEGW},
										  {idpServer, LeafIDPServer}]),
	ok = nci_idpi_actions:subscribe_link_status([{oseGwDeamon, LeafOSEGW},
												 {idpServer, LeafIDPServer}]),

	%% Retrieve the link indication on branch that corresponds to portNo = nearEndPortNo
	StatusInd1 = get_idpi_link_status2_ind_from_port(NearEndPortNo, ?OSE_GW_DEAMON_1),

	%% Retrieve the link indication on leaf that corresponds to portNo = farEndPortNo
	StatusInd2 = get_idpi_link_status2_ind_from_port(FarEndPortNo, LeafOSEGW),

	ct:pal("Using this IDPI_LINK_STATUS2_IND on branch:~n~p", [StatusInd1]),
	ct:pal("Using this IDPI_LINK_STATUS2_IND on leaf:~n~p", [StatusInd2]),

	ct:pal("Action_1"),

	ok = nci_idpi_actions:prop_port_info([{sequenceNumber, StatusInd1#'IdpiLinkStatus2IndS'.sequenceNumber},
										  {packetRatio, StatusInd1#'IdpiLinkStatus2IndS'.packetRatio + 1},
										  {portInfoStatus, ?IDPI_PORT_INFO_APPROVED},
										  {expectedSigNo, ?IDPI_PROP_PORT_INFO2_REJ},
										  {errorCode, ?IDPI_ERROR_MISSING_CONFIGURATION_DATA},
										  {errorDescription, {regexp, "Invalid packetRatio"}}]),

	ct:pal("Action_2"),

	ok = nci_idpi_actions:prop_port_info([{sequenceNumber, StatusInd2#'IdpiLinkStatus2IndS'.sequenceNumber},
										  {packetRatio, StatusInd2#'IdpiLinkStatus2IndS'.packetRatio + 1},
										  {portInfoStatus, ?IDPI_PORT_INFO_APPROVED},
										  {oseGwDeamon, LeafOSEGW},
										  {idpServer, LeafIDPServer},
										  {expectedSigNo, ?IDPI_PROP_PORT_INFO2_REJ},
										  {errorCode, ?IDPI_ERROR_MISSING_CONFIGURATION_DATA},
										  {errorDescription, {regexp, "Invalid packetRatio"}}]),


	ok = nci_dci_actions:stop_idl2_link(IDL2Link),

	wait_for_leaf(Node2Exists),

	%% Receive the link down indications
	{ok, _} = nci_idpi_actions:link_status2_ind_recv_sig([{idl2LinkStatus, ?IDPI_LINK_UNAVAILABLE},
														  {nearEndPortNo, NearEndPortNo}]),

	case Node2Exists of
		true ->
			{ok, _} = nci_idpi_actions:link_status2_ind_recv_sig([{idl2LinkStatus, ?IDPI_LINK_UNAVAILABLE},
																  {nearEndPortNo, FarEndPortNo},
																  {oseGwDeamon, LeafOSEGW}]);
		_ ->
			ok
	end,

	%% Check for unexpected signals
	nci_common_utils:check_outstanding_faults(),

	%% Restart client to make sure we are disconnected
	nci_common_utils:restart_osegw(),

	case Node2Exists of
		true ->
			%% Check for unexpected signals
			nci_common_utils:check_outstanding_faults(?OSE_GW_DEAMON_NODE2_1, 2000),

			%% Restart client to make sure we are disconnected
			nci_common_utils:restart_osegw(?OSE_GW_DEAMON_NODE2_1, osegw_node2);
		_ ->
			ok
	end.

%%------------------------------------------------------------------------------
%% $Id IDPI_SMC1
%%
%% $Header
%%  IDPI Subscribe Meta Channel - Normal use case
%%
%% $Description
%%  Verifies that a client can subscribe meta channel to IDPI server.
%%  After subscribtion, meta channel confirm signal should be received.
%%
%% $Requirements
%%  TBD
%%
%% $HW config
%%  All
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  IDPI connection establish has been performed.
%%
%% $Action_1
%%  Send IDPI_SUBSCRIBE_META_CHANNEL_REQ
%%
%% $Result_1
%%  IDPI_SUBSCRIBE_META_CHANNEL_CFM is received
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%% -
%%
%% Revision history:
%%   2013-07-15 eismele
%%     First version
%%   2013-08-27 ebacemi
%%     Fixed syntax errors
%%
%%------------------------------------------------------------------------------
idpi_smc1() ->
	[{userdata,[{wp, ""},
				{requirement, ""},
				{slogan, "IDPI Subscribe Meta Channel - Normal use case"}]}].

idpi_smc1(_Config) ->
	ct:pal("idpi_smc1"),

	{ok, session_up} = coli:subscribe_state(?SHELL_COMMAND),
	{ok, session_up} = osegw:subscribe_state(?OSE_GW_DEAMON_1),

	%% Make connection to the IDPI interface
	ok = nci_idpi_actions:conn_establish([]),

	ct:pal("Action_1"),
	ok = nci_idpi_actions:subscribe_meta_channel([]),

	%% Check for unexpected signals
	nci_common_utils:check_outstanding_faults(),

	%% Restart to disconnect the meta channel subscriber
	nci_common_utils:restart_osegw().


%%------------------------------------------------------------------------------
%% $Id IDPI_SMC3
%%
%% $Header
%%  IDPI Subscribe Meta Channel - Already subscribed
%%
%% $Description
%%  Verifies that a client can not subscribe meta channel twice.
%%
%% $Requirements
%%  TBD
%%
%% $HW config
%%  All
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  IDPI connection establish has been performed.
%%  IDPI meta channel subscription has been performed.
%%
%% $Action_1
%%  Send IDPI_SUBSCRIBE_META_CHANNEL_REQ
%%
%% $Result_1
%%  IDPI_SUBSCRIBE_META_CHANNEL_CFM is received
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%% -
%%
%% Revision history:
%%   2013-06-07 ebacemi
%%     First version
%%   2013-09-12 ebacemi
%%     Updated to expect CFM
%%
%%------------------------------------------------------------------------------
idpi_smc3() ->
	[{userdata,[{wp, ""},
				{requirement, "TBD"},
				{slogan, "IDPI Subscribe Meta Channel - Already subscribed"}]}].

idpi_smc3(_Config) ->
	ct:pal("idpi_smc3"),

	{ok, session_up} = coli:subscribe_state(?SHELL_COMMAND),
	{ok, session_up} = osegw:subscribe_state(?OSE_GW_DEAMON_1),

	%% Connect to IDPI interface
	ok = nci_idpi_actions:conn_establish([]),

	ok = nci_idpi_actions:subscribe_meta_channel([]),

	ct:pal("Action_1"),
	ok = nci_idpi_actions:subscribe_meta_channel([]),

	%% Check for unexpected signals
	nci_common_utils:check_outstanding_faults(),
	
	%% Restart client to make sure we are disconnected
	nci_common_utils:restart_osegw().


%%------------------------------------------------------------------------------
%% $Id IDPI_SLS1
%%
%% $Header
%%  IDPI Subscribe Link Status - Normal use case
%%
%% $Description
%%  Verifies that a client can subscribe link status to IDPI server.
%%  After subscribtion, one indication for each port should be received.
%%
%% $Requirements
%%  TBD
%%
%% $HW config
%%  All
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  IDPI connection establish has been performed.
%%
%% $Action_1
%%  Send IDPI_SUBSCRIBE_LINK_STATUS_REQ
%%
%% $Result_1
%%  IDPI_SUBSCRIBE_LINK_STATUS_CFM is received
%%
%% $Action_2
%%  Attempt to receive an IDPI_LINK_STATUS_IND signal
%%
%% $Result_2
%%  IDPI_LINK_STATUS_IND is received with parameters
%%  * dunDataValid = 0
%%  * portDataValid = 0
%%  * nearEndPortNo = 3
%%  * nearEndDuId = <don't care>
%%  * farEndPortNo = <don't care>
%%  * farEndDuId = <don't care>
%%  * lineRate = <don't care>
%%  * packetRatio = <don't care>
%%  * idl2LinkStatus = 0
%%  * sequenceNumber = <Can be any number>
%%
%% $Action_3
%%  Attempt to receive three additional IDPI_LINK_STATUS_IND signals
%%
%% $Result_3
%%  Three IDPI_LINK_STATUS_IND are received with parameters
%%  * dunDataValid = 0
%%  * portDataValid = 0
%%  * nearEndPortNo = [4, 5, 6]
%%  * nearEndDuId = <don't care>
%%  * farEndPortNo = <don't care>
%%  * farEndDuId = <don't care>
%%  * lineRate = <don't care>
%%  * packetRatio = <don't care>
%%  * idl2LinkStatus = 0
%%  * sequenceNumber = <sequenceNumber from Action_2 + [1, 2, 3]>
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%% -
%%
%% Revision history:
%%   2013-05-08 ebacemi
%%     First version
%%
%%------------------------------------------------------------------------------
idpi_sls1() ->
	[{userdata,[{wp, ""},
				{requirement, "TBD"},
				{slogan, "IDPI Subscribe Link Status - Normal use case"}]}].

idpi_sls1(_Config) ->
	ct:pal("idpi_sls1"),

	{ok, session_up} = coli:subscribe_state(?SHELL_COMMAND),
	{ok, session_up} = osegw:subscribe_state(?OSE_GW_DEAMON_1),

	CommonParameters = [{dunDataValid, 0},
						{portDataValid, 0},
						{nearEndDuId, '_'},
						{farEndPortNo, '_'},
						{farEndDuId, '_'},
						{farEndType, ?IDPI_FAR_END_UNKNOWN},
						{lineRate, '_'},
						{packetRatio, '_'},
						{idl2LinkStatus, 0}
					   ],

	%% Connect to IDPI interface
	ok = nci_idpi_actions:conn_establish([]),

	ct:pal("Action_1"),
	ok = nci_idpi_actions:subscribe_link_status([]),

	ct:pal("Action_2"),
	{ok, Ind} = nci_idpi_actions:link_status2_ind([{nearEndPortNo, 3}] ++ CommonParameters),
	SeqNo = Ind#'IdpiLinkStatus2IndS'.sequenceNumber,

	ct:pal("Action_3"),
	nci_idpi_actions:link_status2_ind([{sequenceNumber, SeqNo + 1},
									   {nearEndPortNo, 4}] ++ CommonParameters),
	nci_idpi_actions:link_status2_ind([{sequenceNumber, SeqNo + 2},
									   {nearEndPortNo, 5}] ++ CommonParameters),
	nci_idpi_actions:link_status2_ind([{sequenceNumber, SeqNo + 3},
									   {nearEndPortNo, 6}] ++ CommonParameters),

	%% Check for unexpected signals
	nci_common_utils:check_outstanding_faults(),
	
	%% Restart client to make sure we are disconnected
	nci_common_utils:restart_osegw().


%%------------------------------------------------------------------------------
%% $Id IDPI_SLS3
%%
%% $Header
%%  IDPI Subscribe Link Status - Already subscribed
%%
%% $Description
%%  Verifies that a client can not subscribe link status twice.
%%
%% $Requirements
%%  TBD
%%
%% $HW config
%%  All
%%
%% $Type
%%  daily, regression
%%
%% $Precondition
%%  IDPI connection establish has been performed.
%%  IDPI link status subscription has been performed.
%%  Four IDPI_LINK_STATUS_IND signals have been received.
%%
%% $Action_1
%%  Send IDPI_SUBSCRIBE_LINK_STATUS_REQ
%%
%% $Result_1
%%  IDPI_SUBSCRIBE_LINK_STATUS_CFM is received
%%
%% $Action_2
%%  Attempt to receive an IDPI_LINK_STATUS_IND signal
%%
%% $Result_2
%%  IDPI_LINK_STATUS_IND is received with parameters
%%  * dunDataValid = 0
%%  * portDataValid = 0
%%  * nearEndPortNo = 3
%%  * nearEndDuId = <don't care>
%%  * farEndPortNo = <don't care>
%%  * farEndDuId = <don't care>
%%  * lineRate = <don't care>
%%  * packetRatio = <don't care>
%%  * idl2LinkStatus = 0
%%  * sequenceNumber = <Can be any number>
%%
%% $Action_3
%%  Attempt to receive three additional IDPI_LINK_STATUS_IND signals
%%
%% $Result_3
%%  Three IDPI_LINK_STATUS_IND are received with parameters
%%  * dunDataValid = 0
%%  * portDataValid = 0
%%  * nearEndPortNo = [4, 5, 6]
%%  * nearEndDuId = <don't care>
%%  * farEndPortNo = <don't care>
%%  * farEndDuId = <don't care>
%%  * lineRate = <don't care>
%%  * packetRatio = <don't care>
%%  * idl2LinkStatus = 0
%%  * sequenceNumber = <sequenceNumber from Action_2 + [1, 2, 3]>
%%
%% $Postcondition
%%  -
%%
%% $End
%%
%% Review:
%% -
%%
%% Revision history:
%%   2013-06-07 ebacemi
%%     First version
%%   2013-09-12 ebacemi
%%     Updated to expect CFM and four INDs.
%%
%%------------------------------------------------------------------------------
idpi_sls3() ->
	[{userdata,[{wp, ""},
				{requirement, "TBD"},
				{slogan, "IDPI Subscribe Link Status - Already subscribed"}]}].

idpi_sls3(_Config) ->
	ct:pal("idpi_sls3"),

	{ok, session_up} = coli:subscribe_state(?SHELL_COMMAND),
	{ok, session_up} = osegw:subscribe_state(?OSE_GW_DEAMON_1),

	CommonParameters = [{dunDataValid, 0},
						{portDataValid, 0},
						{nearEndDuId, '_'},
						{farEndPortNo, '_'},
						{farEndDuId, '_'},
						{farEndType, ?IDPI_FAR_END_UNKNOWN},
						{lineRate, '_'},
						{packetRatio, '_'},
						{idl2LinkStatus, 0}
					   ],

	%% Connect to IDPI interface
	ok = nci_idpi_actions:conn_establish([]),

	ok = nci_idpi_actions:subscribe_link_status_and_receive_inds2([]),

	ct:pal("Action_1"),
	ok = nci_idpi_actions:subscribe_link_status([]),

	ct:pal("Action_2"),
	{ok, Ind} = nci_idpi_actions:link_status2_ind([{nearEndPortNo, 3}] ++ CommonParameters),
	SeqNo = Ind#'IdpiLinkStatus2IndS'.sequenceNumber,

	ct:pal("Action_3"),
	nci_idpi_actions:link_status2_ind([{sequenceNumber, SeqNo + 1},
									   {nearEndPortNo, 4}] ++ CommonParameters),
	nci_idpi_actions:link_status2_ind([{sequenceNumber, SeqNo + 2},
									   {nearEndPortNo, 5}] ++ CommonParameters),
	nci_idpi_actions:link_status2_ind([{sequenceNumber, SeqNo + 3},
									   {nearEndPortNo, 6}] ++ CommonParameters),

	%% Check for unexpected signals
	nci_common_utils:check_outstanding_faults(),
	
	%% Restart client to make sure we are disconnected
	nci_common_utils:restart_osegw().


init_radios() ->
	[{timetrap, {minutes, 15}},
	 {userdata,[{wp, ""}, 
				{requirement,""},
				{slogan, ""},
				{hwConfig, hwConfigA}]}].

init_radios(_Config) ->
	ct:pal("init_radios"),

	% Set state, make audit, establish BCI and DCI connections, subscribe faults
	set_state_and_connect( operational ),
	ok = nci_dci_actions:subscribe_faults([]),

	Radios = nci_ricm_utils:get_all_radios(),

	lists:foreach(
		fun(Radio) ->

				%% Start CPRI
				ok = nci_dci_actions:start_cpri_link(Radio),
				ok = nci_dci_actions:cpri_link_ind(Radio ++ [{availStatus, 1}]),

				%% Add Radio Control
				nci_dci_actions:add_radio_control(Radio),
				nci_dci_actions:radio_control_ind(Radio ++ [{connStatus, 1}]),

				%% Set restart mode for ecp link lost
				nci_ricm_utils:set_ecp_link_lost_restart_mode(Radio),

				%% Update RICR application
				nci_ricm_utils:update_ricr_app(Radio),

				%%Make sure we are running on applic in case the update did leave radio running on 
				%%auboot and next radio is cascaded 
				nci_dci_actions:add_radio_control(Radio),
				nci_dci_actions:radio_control_ind(Radio ++ [{connStatus, 1}, {radioSoftware, application}])

		end,
		Radios),



	reset_all_cpri_links(Radios),

	%% Check that NO BC/DC_FAULT_IND is generated
	nci_common_utils:check_outstanding_faults(2000).


%%oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
%% $ChapterH1 Test Cases for Daily Test and Regression Test
%%
%% $End
%%
%% $ChapterH2 Test Cases for Daily Test
%%
%% $Typelist(daily)
%%
%% $End
%%
%% $ChapterH2 Test Cases for Regression Test
%%
%% $Typelist(regression)
%% 
%% $End
%%oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo

%%oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
%% $ChapterH1 Requirements
%% 
%% $Soclist()
%%
%% $End
%%oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo

%%oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
%% $ChapterH1 Terminology
%% 
%% $Table(
%% Abbrevation | Definition 
%%
%% BBCLK         Base Band Clock
%%
%% BCP           Board Control Part
%%
%% BCP-loadable  The board has DPs that are loaded via BCP
%%
%% BFN           node B Frame Number
%%
%% BP            Board Processor. Responsible for Operation and Maintenance on
%%               Device Boards in an RBS.
%%
%% BCI           Board Control Interface
%%
%% CBU DP        Device Processor; a DSP or an FPGA.
%%
%% DSP           Digital Signal Processor
%%
%% FA            Functional Area
%%
%% FPGA          Field Programmable Gate Array
%%
%% LMC           Load Module Container.
%%
%% OSE           Real-time operating system used on RBS processors.
%%
%% RBS           Radio Base Station. The kind of entity your cellular phone can
%%               communicate with.
%%
%% SUT           System Under Test.
%%
%% T&E           Trace and Error
%%
%% TBD           To Be Defined.
%%
%% VII           Visual Indication Interface.
%% )
%%
%% $End
%%oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo

%%oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
%% $ChapterH1 References
%% 
%% 1. Device Handling Interfaces Design Rules, 2/102 60 - HRB 105 102/1
%%
%%%2. The Visual Indication Interface,1553-CXA 104 217
%%
%%%3. FD DU BC SW, 3/155 16-CAH 109 1284/1
%%
%%%4. FD RICM SW, 1/155 16-CAH 109 1284/1
%%
%%%5. RICM signal files reside in:
%%
%% /vobs/rbs/hw/nci_comm/deliv/ifu/ricm-cdci/inc, /vobs/erbs/elib and /vobs/crbs/clib
%%
%% $End
%%oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo


%%------------------------------------------------------------------------------
%% COMMON TEST CALLBACK FUNCTIONS
%%------------------------------------------------------------------------------

%%------------------------------------------------------------------------------
%% @doc
%%  Returns list of tuples to set default properties
%%  for the suite.
%%
%% Function: suite() -> Info
%%
%% Info = [tuple()]
%%   List of key/value pairs.
%%
%% Note: The suite/0 function is only meant to be used to return
%% default data values, not perform any other operations.
%%
%% @spec suite() -> Info
%% @end
%%------------------------------------------------------------------------------
suite() ->
	%% Check if the NO_RESTART flag was passed to the run_test command
	NodeRestart = 
		case init:get_argument(?FLAG_NO_RESTART) of
			{ok, _Val1} ->
				%% NO_RESTART flag is present. Do not perform node restarts.
				false;
			_Other1 ->
				%% NO_RESTART flag is not present. Perform node restarts.
				true
		end,

	Default_Hooks = [{jctftp, #jctftp{name=?FTP_NAME, iap=?CPP_FTP_IAP}},
					 {coli, [{name, ?SHELL_COMMAND}, {iap, ?CPP_TELNET_IAP}]},
					 {osegw,#osegw{name = ?OSE_GW_DEAMON_1, 
								   iap = osegw, 
								   opt = [{ping_timeout, 10*1000}, 
										  {codec_config, 
										   {?SIG_MODS, 
											sizeof, 
											osegw_ose,big}}]}}
					],
	Extra_Node_Hooks = get_additional_node_hooks(),

	CPP_Hook = [{cpp, #cpp{name = ?CPP_NAME,
						   telnet_iap = ?CPP_TELNET_IAP,
						   ftp_iap = ?CPP_FTP_IAP,
						   node_restart = NodeRestart,
						   node_timeout = 120*1000,
						   level = no_check,
						   error_check = true, %% No ERROR shall exit in TE log.
						   error_filter = ?CPP_ERROR_FILTER,
						   pmd_check = true,   %% If true, TC fails if there is a new pmd dump.
						   tc_config = [ {bci_svi4, [{error_check, false}]},
										 {bci_rb1, [{pmd_check, false}]},
										 {bci_fake_temp1, [{pmd_check, false}]},
										 {bci_rb2, [{pmd_check, false}]},
										 {dci_idl2_init, [{pmd_check, false}]}
									   ]
						  } 
				}],

	Cpri_Converter_Hooks = nci_ricm_utils:create_cpri_converter_hooks(),

	CT_Hooks = Default_Hooks ++ Extra_Node_Hooks ++ Cpri_Converter_Hooks ++
		case init:get_argument(?FLAG_NO_CPP) of
			{ok, _Val2} ->
				[];
			_Other2 ->
				CPP_Hook
		end,
	
	[{timetrap, {minutes, 5}},
	 {silent_connections, [telnet]}, {trace, []},
	 {ct_hooks, CT_Hooks}
	].

get_additional_node_hooks() ->
	get_additional_node_hooks(2).

get_additional_node_hooks(Node) ->
	NodeSuffix = "_node" ++ integer_to_list(Node),
	TestNode = "test_node" ++ NodeSuffix,
	case ct:get_config(list_to_atom(TestNode)) of
		undefined ->
			[];
		_NodeName ->
			FtpName = list_to_atom(atom_to_list(?FTP_NAME) ++ NodeSuffix),
			FtpIap = list_to_atom(atom_to_list(?CPP_FTP_IAP) ++ NodeSuffix),
			ColiName = list_to_atom(atom_to_list(?SHELL_COMMAND) ++ NodeSuffix),
			TelnetIap = list_to_atom(atom_to_list(?CPP_TELNET_IAP) ++ NodeSuffix),
			OseGwIap = list_to_atom("osegw" ++ NodeSuffix),
			OseGwName = list_to_atom("jct_osegw" ++ NodeSuffix ++ "_1"),

			Hooks = [{jctftp, #jctftp{name = FtpName,
									  iap = FtpIap}},	
					 {coli, [{name, ColiName}, {iap, TelnetIap}]},
					 {osegw,#osegw{name = OseGwName, 
								   iap = OseGwIap, 
								   opt = [{ping_timeout, 10*1000}, 
										  {codec_config, 
										   {?SIG_MODS, 
											sizeof, 
											osegw_ose,big}}]}}
					],

			Hooks ++ get_additional_node_hooks(Node + 1)
	end.


%%--------------------------------------------------------------------
%% @doc
%% Initialization before the whole suite
%%
%% Config0 = Config1 = [tuple()]
%%   A list of key/value pairs, holding the test case configuration.
%% Reason = term()
%%   The reason for skipping the suite.
%%
%% Note: This function is free to add any key/value pairs to the Config
%% variable, but should NOT alter/remove any existing entries.
%%
%% @spec init_per_suite(Config0) ->
%%               Config1 | {skip,Reason} | {skip_and_save,Reason,Config1}
%% @end
%%--------------------------------------------------------------------
init_per_suite(Config) ->
	Logdir=?config(priv_dir,Config),
	os:cmd("touch "++Logdir++"/test-suite.log"),

	nci_ricm_utils:configure_cpri_converters(),

	nci_common_utils:log_env_info(),

	nci_ricm_utils:dump_node_config(),

	nci_ricm_utils:restart_type2_nodes(),

	Config.

%%--------------------------------------------------------------------
%% @doc
%% Cleanup after the whole suite
%%
%% Config - [tuple()]
%%   A list of key/value pairs, holding the test case configuration.
%%
%% @spec end_per_suite(Config) -> _
%% @end
%%--------------------------------------------------------------------
end_per_suite(_Config) ->
	nci_ricm_utils:disable_cpri_converters(),
	ok.

%%--------------------------------------------------------------------
%% @doc
%% Initialization before each test case group.
%%
%% GroupName = atom()
%%   Name of the test case group that is about to run.
%% Config0 = Config1 = [tuple()]
%%   A list of key/value pairs, holding configuration data for the group.
%% Reason = term()
%%   The reason for skipping all test cases and subgroups in the group.
%%
%% @spec init_per_group(GroupName, Config0) ->
%%               Config1 | {skip,Reason} | {skip_and_save,Reason,Config1}
%% @end
%%--------------------------------------------------------------------
init_per_group(GroupName, Config) ->
	case GroupName of
		dus ->
			%% dus group can only be run on DUS41 and DUS31
			ensure_du(GroupName, dus);
		dul ->
			%% dul group can only be run on DUL20
			ensure_du(GroupName, dul);
		mrbs ->
			%% mrbs group can only be run on MRBS
			ensure_du(GroupName, mRBS_lte);
		_ ->
			%% All other groups can be run on any node
			ok
	end,

	Config.

ensure_du(GroupName, ExpectedDuName) ->
	DuName = nci_common_utils:get_du(),

	if DuName /= ExpectedDuName ->
			ct:fail("Group ~p cannot be run on ~p", [GroupName, DuName]);
	   true ->
			ok
	end.

%%--------------------------------------------------------------------
%% @doc
%% Cleanup after each test case group.
%%
%% GroupName = atom()
%%   Name of the test case group that is finished.
%% Config0 = Config1 = [tuple()]
%%   A list of key/value pairs, holding configuration data for the group.
%%
%% @spec end_per_group(GroupName, Config0) ->
%%               void() | {save_config,Config1}
%% @end
%%--------------------------------------------------------------------
end_per_group(_GroupName, _Config) ->
	ok.

%%--------------------------------------------------------------------
%% @doc
%% Initialization before each test case
%%
%% TestCase - atom()
%%   Name of the test case that is about to be run.
%% Config0 = Config1 = [tuple()]
%%   A list of key/value pairs, holding the test case configuration.
%% Reason = term()
%%   The reason for skipping the test case.
%%
%% Note: This function is free to add any key/value pairs to the Config
%% variable, but should NOT alter/remove any existing entries.
%%
%% @spec init_per_testcase(TestCase, Config0) ->
%%               Config1 | {skip,Reason} | {skip_and_save,Reason,Config1}
%% @end
%%--------------------------------------------------------------------
init_per_testcase(TestCase, Config) ->
	nci_ricm_utils:init_per_testcase(TestCase, Config, ?MODULE).

%%--------------------------------------------------------------------
%% @doc
%% Cleanup after each test case
%%
%% TestCase - atom()
%%   Name of the test case that is finished.
%% Config0 = Config1 = [tuple()]
%%   A list of key/value pairs, holding the test case configuration.
%%
%% @spec end_per_testcase(TestCase, Config0) ->
%%               void() | {save_config,Config1} | {fail,Reason}
%% @end
%%--------------------------------------------------------------------
end_per_testcase(TestCase, Config) ->
	nci_ricm_utils:dump_debug_info(TestCase, Config),

	Config.

%%--------------------------------------------------------------------
%% @doc
%% Returns a list of test case group definitions.
%%
%% 2nd parameter can contain:
%% []                    Test cases are executed once in the given order.
%% [shuffle]             Test cases are executed in random order.
%% [{repeat,5}]          The group is tested 5 times.
%% [shuffle,{repeat,5}]  Combination of the two above.
%%
%%--------------------------------------------------------------------
groups() ->
	CommonGroup = [
				   bci_activate_srio_testport1, bci_activate_srio_testport2, bci_activate_srio_testport3, bci_activate_srio_testport5,
				   bci_at1, bci_at2, bci_at3, bci_at4,
				   bci_ce1, bci_ce2, bci_ce3, bci_ce4, bci_ce5, bci_ce6, 
				   bci_cl1, bci_cl2,
				   bci_dbc_1, bci_dbc_15,
				   bci_do1, bci_do2, bci_do3, bci_do4, bci_do5, bci_do6,
				   bci_eo1, bci_eo2, bci_eo3, bci_eo4,
				   bci_es1, bci_es2, bci_es3, bci_es4, bci_es5, bci_es6, bci_es7, bci_es8, bci_es9,
				   bci_fake_bpp_hwfault, bci_fake_bpp_swfault,
				   bci_fake_temp1, bci_fake_temp2, bci_fake_temp3, bci_fake_temp4, bci_fake_temp5, bci_fake_temp6, bci_fake_temp7,
				   bci_gc1, bci_gc2, 
				   bci_ld1, bci_ld2, bci_ld3, bci_ld4, bci_ld5, bci_ld8,
				   bci_rb1, bci_rb2, bci_rb3,
				   bci_sf1, bci_sf2, bci_sf3, bci_sf4,
				   bci_sii1, bci_sii2, bci_sii3, bci_sii4, bci_sii5, bci_sii6,
				   bci_sm1, bci_sm2, bci_sm3, bci_sm4, bci_sm5,
				   bci_svi1, bci_svi2, bci_svi3, bci_svi4, 
				   bci_tms1, bci_tms2, bci_tms3, bci_tms4, bci_tms5,


				   casc_carrier_1, casc_carrier_2, casc_carrier_3, casc_carrier_4,
				   casc_get_port_1, casc_get_port_2, casc_get_port_3, casc_get_port_4, casc_get_port_5,
				   casc_get_remote_port_1, casc_get_remote_port_2, casc_get_remote_port_3, casc_get_remote_port_4, casc_get_remote_port_5,
				   casc_release_setup_rcl_2,
				   casc_reset_cpri_1, 
				   casc_reset_radio_1,
				   casc_reset_second_ru,
				   casc_set_timing_1, casc_set_timing_2, casc_set_timing_3, casc_set_timing_4, casc_set_timing_5,

				   dci_arc1, dci_arc2, dci_arc3, dci_arc4, dci_arc5, dci_arc8, dci_arc9, dci_arc12, 
				   dci_ce1, dci_ce2, dci_ce3, dci_ce4, dci_ce5, dci_ce6, dci_ce7,
				   dci_cr1, dci_cr2, dci_cr3, dci_cr4, 
				   dci_cs1, dci_cs2, dci_cs3, dci_cs4, dci_cs5, dci_cs8, dci_cs9, dci_cs10, dci_cs13, dci_cs14, dci_cs15, dci_cs17, dci_cs18,
				   dci_cs8_fullband, dci_cs8_20mhz,
				   dci_cs_test_bw_and_issubband, dci_cs_faultcase_with_issubband_param,
				   dci_csmax_rcl_csmax, dci_csmax_rcl_csmax_fullband, dci_csmax_rcl_csmax_20mhz,
				   dci_delay_1, dci_delay_2, dci_delay_3, dci_delay_4, dci_delay_5, dci_delay_6, dci_delay_7, dci_delay_8, dci_delay_9, dci_delay_10, dci_delay_11,
				   dci_fct,
				   dci_fi1, dci_fi2, dci_fi3, dci_fi4, dci_fi5, dci_fi_l1_reset,
				   dci_gc1, dci_gc2, dci_gc3, dci_gc4, 
				   dci_rcl1, dci_rcl2, dci_rcl3, dci_rcl4, dci_rcl6, dci_rcl7,
				   dci_reset_rc1, dci_reset_rc2, dci_reset_rc3, dci_reset_rc4, dci_reset_rc6, dci_reset_rc7, dci_reset_rc8,
				   dci_rrc1, dci_rrc2, dci_rrc3, dci_rrc4, dci_rrc7, dci_rrc6, dci_rrc8, dci_rrc9,
				   dci_scl1, dci_scl2, dci_scl3, dci_scl4, dci_scl5, dci_scl7, dci_scl9, dci_scl12, dci_scl13, dci_scl14, dci_scl17, dci_scl18,
				   dci_sf1, dci_sf2, dci_sf3, dci_sf4,
				   dci_ssi1, dci_ssi2, dci_ssi3, dci_ssi4, dci_ssi5, dci_ssi6, dci_ssi7, dci_ssi8, dci_ssi9, dci_ssi11, 
				   dci_std1, dci_std2, dci_std3, dci_std4, dci_std5, 

				   ricm_las_101, ricm_las_102, ricm_las_103, ricm_las_104,
				   ricm_sfp_hwlog
				  ],

	DULGroup = CommonGroup ++ [
							   bci_activate_vcxo1, bci_activate_vcxo2, bci_activate_vcxo3, bci_activate_vcxo5,

							   bci_fi1

							   %% The below two test cases are incorrectly written and require a configuration that shouldn't be needed to test the L+L mixed mode carrier setup feature.
							   %% They will also be replaced once configure_switch test cases are in place. Therefore they are commented out.
							   %% dci_cs8_slave_du, dci_cs9_slave_du
							  ],

	DUSGroup = CommonGroup ++ [
							   %% dci_cs8_slave_du, dci_cs9_slave_du,

							   ricm_zuc
							  ],

	MRBSGroup = CommonGroup,	


	%% List of test cases that are implemented but not included in any group
	%% dci_idl2_start20 - Add to IDL2Type3Group when/if error handling for starting link on leaf node is implemented in ricm.
	%% dci_idl2_stop8   - Add to IDL2Type3Group when/if error handling for stopping link on leaf node is implemented in ricm.
	%% dci_rcl9         - Not fully tested/reviewed
	%% bci_gc3          - boardtype has to be taken into account
	%% dci_ssi10        - Manual test case
	%% casc_release_setup_rcl_1 - Never been in a group???


	IDL2Type2Group = [
					  dci_idl2_cpri1, 
					  dci_idl2_link1, dci_idl2_link2, dci_idl2_link3, dci_idl2_link6,
					  dci_idl2_lsp1,
					  dci_idl2_start1, dci_idl2_start5, dci_idl2_start6, dci_idl2_start16, dci_idl2_start17, dci_idl2_start18, dci_idl2_start19
					 ],

	IDL2Type3Group = [
					  dci_idl2_cpri1, dci_idl2_cpri2, dci_idl2_cpri3, dci_idl2_cpri4,
					  dci_idl2_link1, dci_idl2_link2, dci_idl2_link3, dci_idl2_link4, dci_idl2_link5, dci_idl2_link6, dci_idl2_link7,

					  dci_idl2_start1, dci_idl2_start2, dci_idl2_start3, dci_idl2_start4, dci_idl2_start5, dci_idl2_start6, dci_idl2_start7, 
					  dci_idl2_start8, dci_idl2_start9, dci_idl2_start10, dci_idl2_start11, dci_idl2_start12, dci_idl2_start13, dci_idl2_start15, 
					  dci_idl2_start16, dci_idl2_start17, dci_idl2_start19, dci_idl2_start21, dci_idl2_start22, dci_idl2_start23,

					  dci_idl2_stop3, dci_idl2_stop4, dci_idl2_stop5, dci_idl2_stop6, dci_idl2_stop7,

					  idpi_ce1, idpi_ce2, idpi_ce3,
					  idpi_csf3,
					  idpi_gc1,
					  idpi_gd1, idpi_gd3, idpi_gd4,
					  idpi_mca3, idpi_mca4, idpi_mca5,
					  idpi_mcd3, idpi_mcd4, idpi_mcd5,
					  idpi_pdi1, idpi_pdi3, idpi_pdi4, idpi_pdi5,
					  idpi_ppi1, idpi_ppi3, idpi_ppi4, idpi_ppi5, idpi_ppi6, idpi_ppi7,
					  idpi_smc1, idpi_smc3,
					  idpi_sls1, idpi_sls3
					 ],

	TimeAlignmentUnitGroup = [
							  dci_sud1, dci_sud2, dci_sud3, dci_sud4, dci_sud5, dci_sud6, dci_sud7, dci_sud8, dci_sud9
							 ],
	%%All this test cases are here in order to have a foundation to start the time alignment cable delay testing on target.
	%%Current cable delay interface will change in order to fully support this feature. start cpri link req with linkid 
	%%support is also needed in order to support this feature.
	TimeAlignmentCableGroup = [
							   dci_scld1, dci_scd2, dci_scd3, dci_scd4, dci_scld5, dci_scld6, dci_scld7
							  ],
	MultiLinkGroup = [
					  dci_start_oam1, dci_start_oam2, dci_start_oam3, dci_start_oam4, dci_start_oam5, 
					  dci_sasr1, dci_sasr2, dci_sasr3, dci_sasr4, dci_sasr5,
					  dci_stop_cl1, dci_stop_cl2, dci_stop_cl3, dci_stop_cl4, dci_stop_cl5,
					  dci_sduid1, dci_sduid2, dci_sduid3, dci_sduid4, dci_sduid5
					 ],

	[
	 {time_alignment_unit, [], TimeAlignmentUnitGroup},
	 {time_alignment_cable, [shuffle], TimeAlignmentCableGroup},
	 {idl2_type2, [shuffle], IDL2Type2Group},
	 {idl2_type2_stability, [], lists:duplicate(100, {group, idl2_type2})},
	 {idl2_type3, [], [dci_idl2_init, {idl2_type3_main, [shuffle], IDL2Type3Group}]},
	 {multilink, [shuffle], MultiLinkGroup},

	 {idl2_type3_push_test, [], [dci_idl2_init, dci_idl2_start1, dci_idl2_start5, dci_idl2_start6, dci_idl2_link7]},
	 {dus_push_test, [], [{dus_main_push, [shuffle], push_test_group(DUSGroup)}, {group, idl2_type3_push_test}]},

	 {dul, [], [init_radios, {dul_main, [shuffle], DULGroup}]},
	 {dus, [], [init_radios, {dus_main, [shuffle], DUSGroup}, {group, idl2_type3}]},
	 {mrbs, [], [init_radios, {mrbs_main, [shuffle], MRBSGroup}]}
	].

%%--------------------------------------------------------------------
%% @doc
%%  Returns the list of groups and test cases that
%%  are to be executed.
%%
%% GroupsAndTestCases = [{group,GroupName} | TestCase]
%% GroupName = atom()
%%   Name of a test case group.
%% TestCase = atom()
%%   Name of a test case.
%% Reason = term()
%%   The reason for skipping all groups and test cases.
%%
%% @spec all() -> GroupsAndTestCases | {skip,Reason}
%% @end
%%--------------------------------------------------------------------
all() ->
	[].

%% ===========================================================================
%% @spec push_test_group(TestCases)
%%
%%    -> list()
%%
%% where
%%
%%   TestCases    = list()
%%
%% @doc
%% Returns the list of test cases that are to be executed in a push test.
%% @end
%% ===========================================================================
push_test_group(TestCases) ->

	%%List of test cases that are a minor subset of current test cases that are testing various parts of RICM to get as much functionality tested and still be fast
	%%in order to get the push test to deliver resonably fast results
	BasicFuncionalityTestCases = 
		[bci_es2,
		 bci_temp7,
		 bci_gc1,bci_ssi1,
		 bci_svi1,
		 bci_tms1,
		 casc_release_setup_rcl_2,
		 casc_reset_cpri_1, 
		 casc_reset_radio_1,
		 casc_reset_second_ru,
		 
		 dci_cs8,
		 dci_delay_1,
		 dci_fct,
		 dci_gc1,
		 dci_reset_rc1,
		 dci_ssi1,
		 ricm_las_101],
	 
	TestCasesSubSet = lists:subtract(TestCases, BasicFuncionalityTestCases),
	
	%% Pick 30 random testcases from the remaining test cases
	{Random30TestCases, _} = 
		lists:foldl(
			fun(_, {RandomTestcasesList, TestCasesSubSetCurrent}) ->
					   Index = random:uniform(length(TestCasesSubSetCurrent)),
					   TestCase = lists:nth(Index, TestCasesSubSetCurrent),
					   
					   {RandomTestcasesList ++ [TestCase], lists:delete(TestCase, TestCasesSubSetCurrent)}
			end,
			{[],TestCasesSubSet},
			lists:seq(1, 30)),

	Random30TestCases ++ BasicFuncionalityTestCases.

%%------------------------------------------------------------------------------
%% INTERNAL FUNCTIONS
%%------------------------------------------------------------------------------
board_cap([PreReceived | T]) ->
	case PreReceived#'ElibBcBoardCapabilityS'.boardCapabilityIdentity of
		?ELIB_BC_CAP_LOADING_SUPPORT ->
			Received = PreReceived,
			Expected = board_cap_1();
		?ELIB_BC_CAP_SYST_CONST ->
			Received = PreReceived,
			Expected = board_cap_2();
		?ELIB_BC_CAP_HW_PID ->
			Received = PreReceived,
			Expected = board_cap_3();
		?ELIB_BC_CAP_ETH_TERM_SUPPORT ->
			Received = PreReceived,
			Expected = board_cap_4();
		?ELIB_BC_CAP_ETH_HW_IF_SUPPORT ->
			Received = PreReceived,
			Expected = board_cap_5();
		?ELIB_BC_CAP_CLIMATE_CONTROL_SUPPORT -> 
			Received = PreReceived,
			Expected = board_cap_6();
		?ELIB_BC_CAP_COMMON_MMI_SUPPORT -> 
			Received = PreReceived,
			Expected = board_cap_7();
		?ELIB_BC_CAP_PRE_INSTALLED_SUPPORT ->
			Received = PreReceived,
			Expected = board_cap_8();
		?ELIB_BC_CAP_SW_COMP_LIST_SUPPORT ->
			Received = PreReceived,
			Expected = board_cap_9();
		?ELIB_BC_CAP_XIO_INTERFACES ->
			Received = PreReceived,
			Expected = board_cap_10();
		?ELIB_BC_CAP_LOCKABLE_RESOURCE_SUPPORT ->
			Received = PreReceived,
			Expected = board_cap_11();
		?ELIB_BC_CAP_LOCKABLE_RESOURCE_S_W_STORE_SUPPORT ->
			Received = PreReceived,
			Expected = board_cap_12();
		?ELIB_BC_CAP_CONTAINER_PID ->
			Received = PreReceived,
			Expected = board_cap_13();
		?ELIB_BC_CAP_IQ_HW_IF_SUPPORT ->
% TODO:check			UnSortedRec = PreReceived,
%			Sorted = lists:sort(UnSortedRec#'ElibBcBoardCapabilityS'.capability#'ElibBcEthHwIfSupportS'.ethLinkParam),
%			LocalSwitchPortNr = UnSortedRec#'ElibBcBoardCapabilityS'.capability#'ElibBcEthHwIfSupportS'.localSwitchPortNr,
%			NumOfEthLinks = UnSortedRec#'ElibBcBoardCapabilityS'.capability#'ElibBcEthHwIfSupportS'.numOfEthLinks,
%			Received = UnSortedRec#'ElibBcBoardCapabilityS'{capability=#'ElibBcEthHwIfSupportS'{localSwitchPortNr=LocalSwitchPortNr,numOfEthLinks=NumOfEthLinks,ethLinkParam=Sorted}},
						Received = PreReceived,
			Expected = board_cap_14();
		?ELIB_BC_CAP_IQ_TERM_SUPPORT ->
			Received = PreReceived,
			Expected = board_cap_15();
		?ELIB_BC_CAP_ETH_HW_IF_SUPPORT2 ->
			Received = PreReceived,
			Expected = board_cap_16();
		?ELIB_BC_CAP_INTERNAL_SYNC_LINK_SV_SUPPORT ->
			Received = PreReceived,
			Expected = board_cap_17();
 		Unexpected ->
			Received = [],
			Expected = [],
			ct:pal("Unexpected boardCapabilityIdentity: ~p~n", [Unexpected]),
			ct:pal("Received: ~p~n", [PreReceived]),
			ct:fail("Unexpected boardCapabilityIdentity")
	end,

	case Received of
		[] -> ok;
		_ ->
			ct:pal("Received:~n~s", [osegw_lib:pretty_format(Received, nci_bci_dci)]),
			ct:pal("Expected:~n~s", [osegw_lib:pretty_format(Expected, nci_bci_dci)]),
			ok = osegw_lib:signal_compare(Received, Expected, nci_bci_dci)
	end,

	board_cap(T);

board_cap([]) ->
	ok.


board_cap_1() ->
	#'ElibBcBoardCapabilityS'{
		boardCapabilityIdentity = ?ELIB_BC_CAP_LOADING_SUPPORT,
		boardCapabilityLength = '_',
		capability = #'ElibBcLoadingSupportS'{
				loadable = ?ELIB_CONST_HWU_YES,
				flash = ?ELIB_CONST_HWU_YES,
				fileSystemAccess = ?ELIB_CONST_HWU_YES,
				padding0 = '_',
				blockSize = 1000}}.

board_cap_2() ->
		 #'ElibBcBoardCapabilityS'{
				boardCapabilityIdentity = ?ELIB_BC_CAP_SYST_CONST,
				boardCapabilityLength = '_',
				capability = #'ElibBcLoadingSupportS'{
							loadable = '_',
							flash = '_',
							fileSystemAccess = '_',
							padding0 = '_',
							blockSize = '_'}}.

board_cap_3() ->
		 #'ElibBcBoardCapabilityS'{
				boardCapabilityIdentity = ?ELIB_BC_CAP_HW_PID,
				boardCapabilityLength = '_',
				capability = #'ElibBcLoadingSupportS'{
							loadable = '_',
							flash = '_',
							fileSystemAccess = '_',
							padding0 = '_',
							blockSize = '_'}}.

board_cap_4() ->
		 #'ElibBcBoardCapabilityS'{
				boardCapabilityIdentity = ?ELIB_BC_CAP_ETH_TERM_SUPPORT,
				boardCapabilityLength = '_',
				capability = #'ElibBcLoadingSupportS'{
							loadable = '_',
							flash = '_',
							fileSystemAccess = '_',
							padding0 = '_',
							blockSize = '_'}}.

board_cap_5() ->
		 #'ElibBcBoardCapabilityS'{
				boardCapabilityIdentity = ?ELIB_BC_CAP_ETH_HW_IF_SUPPORT,
				boardCapabilityLength = '_',
				capability = #'ElibBcLoadingSupportS'{
							loadable = '_',
							flash = '_',
							fileSystemAccess = '_',
							padding0 = '_',
							blockSize = '_'}}.

board_cap_6() ->

	%% Get temperature parameters for this board (type and revision dependant)
	SetPoint     = nci_common_cfg:get_temp_param(setPoint) * 100,
	TimeConstant = nci_common_cfg:get_temp_param(tau) * 10,
	CoolingGain  = nci_common_cfg:get_temp_param(coolGain),	

	ct:pal("Retrieved temperature configuration parameters - "
		   "SetPoint:~w, Tau:~w, CoolGain:~w", 
		   [SetPoint, TimeConstant, CoolingGain]),

	#'ElibBcBoardCapabilityS'{
		boardCapabilityIdentity = ?ELIB_BC_CAP_CLIMATE_CONTROL_SUPPORT,
				boardCapabilityLength = '_',
				capability = #'ElibBcClimateControlSupportS'{
							numOfHotspotTempSensors = 1,
							padding0 = '_',
				hotspotParamList = [#'ElibBcHotspotParamListS'{
											setPoint = SetPoint,
											coolingGain = CoolingGain,
											timeConstant = TimeConstant,
											padding0 = '_'},
										#'ElibBcHotspotParamListS'{
											setPoint = '_',
											coolingGain = '_',
											timeConstant = '_',
											padding0 = '_'},
										#'ElibBcHotspotParamListS'{
											setPoint = '_',
											coolingGain = '_',
											timeConstant = '_',
											padding0 = '_'},
										#'ElibBcHotspotParamListS'{
											setPoint = '_',
											coolingGain = '_',
											timeConstant = '_',
											padding0 = '_'},
										#'ElibBcHotspotParamListS'{
											setPoint = '_',
											coolingGain = '_',
											timeConstant = '_',
											padding0 = '_'},
										#'ElibBcHotspotParamListS'{
											setPoint = '_',
											coolingGain = '_',
											timeConstant = '_',
											padding0 = '_'},
										#'ElibBcHotspotParamListS'{
											setPoint = '_',
											coolingGain = '_',
											timeConstant = '_',
											padding0 = '_'},
										#'ElibBcHotspotParamListS'{
											setPoint = '_',
											coolingGain = '_',
											timeConstant = '_',
											padding0 = '_'},
										#'ElibBcHotspotParamListS'{
											setPoint = '_',
											coolingGain = '_',
											timeConstant = '_',
											padding0 = '_'},
										#'ElibBcHotspotParamListS'{
											setPoint = '_',
											coolingGain = '_',
											timeConstant = '_',
											padding0 = '_'}]}}.

board_cap_7() ->
		 #'ElibBcBoardCapabilityS'{
				boardCapabilityIdentity = ?ELIB_BC_CAP_COMMON_MMI_SUPPORT,
				boardCapabilityLength = '_',
				capability = #'ElibBcLoadingSupportS'{
							loadable = '_',
							flash = '_',
							fileSystemAccess = '_',
							padding0 = '_',
							blockSize = '_'}}.

board_cap_8() ->
		 #'ElibBcBoardCapabilityS'{
				boardCapabilityIdentity = ?ELIB_BC_CAP_PRE_INSTALLED_SUPPORT,
				boardCapabilityLength = '_',
				capability = #'ElibBcLoadingSupportS'{
							loadable = '_',
							flash = '_',
							fileSystemAccess = '_',
							padding0 = '_',
							blockSize = '_'}}.

board_cap_9() ->
		 #'ElibBcBoardCapabilityS'{
				boardCapabilityIdentity = ?ELIB_BC_CAP_SW_COMP_LIST_SUPPORT,
				boardCapabilityLength = '_',
				capability = #'ElibBcLoadingSupportS'{
							loadable = '_',
							flash = '_',
							fileSystemAccess = '_',
							padding0 = '_',
							blockSize = '_'}}.

board_cap_10() ->
		 #'ElibBcBoardCapabilityS'{
				boardCapabilityIdentity = ?ELIB_BC_CAP_XIO_INTERFACES,
				boardCapabilityLength = '_',
				capability = #'ElibBcLoadingSupportS'{
							loadable = '_',
							flash = '_',
							fileSystemAccess = '_',
							padding0 = '_',
							blockSize = '_'}}.

board_cap_11() ->
		 #'ElibBcBoardCapabilityS'{
				boardCapabilityIdentity = ?ELIB_BC_CAP_LOCKABLE_RESOURCE_SUPPORT,
				boardCapabilityLength = '_',
				capability = #'ElibBcLoadingSupportS'{
							loadable = '_',
							flash = '_',
							fileSystemAccess = '_',
							padding0 = '_',
							blockSize = '_'}}.

board_cap_12() ->
		 #'ElibBcBoardCapabilityS'{
				boardCapabilityIdentity = ?ELIB_BC_CAP_LOCKABLE_RESOURCE_S_W_STORE_SUPPORT,
				boardCapabilityLength = '_',
				capability = #'ElibBcLoadingSupportS'{
							loadable = '_',
							flash = '_',
							fileSystemAccess = '_',
							padding0 = '_',
							blockSize = '_'}}.

board_cap_13() ->
		 #'ElibBcBoardCapabilityS'{
				boardCapabilityIdentity = ?ELIB_BC_CAP_CONTAINER_PID,
				boardCapabilityLength = '_',
				capability = #'ElibBcLoadingSupportS'{
							loadable = '_',
							flash = '_',
							fileSystemAccess = '_',
							padding0 = '_',
							blockSize = '_'}}.

board_cap_14() ->
	 NofIqbLinks = case nci_common_utils:get_du() of
		 dul -> 9;
		 dus -> 8;
		 mRBS_lte -> 8;
		 _ -> 9
	 end,
	 #'ElibBcBoardCapabilityS'{
		boardCapabilityIdentity = ?ELIB_BC_CAP_IQ_HW_IF_SUPPORT,
		boardCapabilityLength = '_',
		capability = #'ElibBcIqHwIfSupportS' {
			nofIqbLinks = NofIqbLinks,
			padding0 = '_',
			iqbLinkParam = [
				#'ElibBcIqIqbLinkParamsS' {
					logicalId = '_',
					nofAxC = '_',
					isStriped = '_',
					portId = '_',
					dir = '_',
					snid = '_',
					padding0 = '_'
				},
				#'ElibBcIqIqbLinkParamsS' {
					logicalId = '_',
					nofAxC = '_',
					isStriped = '_',
					portId = '_',
					dir = '_',
					snid = '_',
					padding0 = '_'
				},
				#'ElibBcIqIqbLinkParamsS' {
					logicalId = '_',
					nofAxC = '_',
					isStriped = '_',
					portId = '_',
					dir = '_',
					snid = '_',
					padding0 = '_'
				},
				#'ElibBcIqIqbLinkParamsS' {
					logicalId = '_',
					nofAxC = '_',
					isStriped = '_',
					portId = '_',
					dir = '_',
					snid = '_',
					padding0 = '_'
				},
				#'ElibBcIqIqbLinkParamsS' {
					logicalId = '_',
					nofAxC = '_',
					isStriped = '_',
					portId = '_',
					dir = '_',
					snid = '_',
					padding0 = '_'
				},
				#'ElibBcIqIqbLinkParamsS' {
					logicalId = '_',
					nofAxC = '_',
					isStriped = '_',
					portId = '_',
					dir = '_',
					snid = '_',
					padding0 = '_'
				},
				#'ElibBcIqIqbLinkParamsS' {
					logicalId = '_',
					nofAxC = '_',
					isStriped = '_',
					portId = '_',
					dir = '_',
					snid = '_',
					padding0 = '_'
				},
				#'ElibBcIqIqbLinkParamsS' {
					logicalId = '_',
					nofAxC = '_',
					isStriped = '_',
					portId = '_',
					dir = '_',
					snid = '_',
					padding0 = '_'
				},
				#'ElibBcIqIqbLinkParamsS' {
					logicalId = '_',
					nofAxC = '_',
					isStriped = '_',
					portId = '_',
					dir = '_',
					snid = '_',
					padding0 = '_'
				},
				#'ElibBcIqIqbLinkParamsS' {
					logicalId = '_',
					nofAxC = '_',
					isStriped = '_',
					portId = '_',
					dir = '_',
					snid = '_',
					padding0 = '_'
				}
			],
			nofIqcLinks = '_',
			padding1 = '_',
			iqcLinkParam = [
				#'ElibBcIqIqcLinkParamsS' {
					portId = '_',
					dir = '_',
					snid = '_',
					padding0 = '_'
				},
				#'ElibBcIqIqcLinkParamsS' {
					portId = '_',
					dir = '_',
					snid = '_',
					padding0 = '_'
				},
				#'ElibBcIqIqcLinkParamsS' {
					portId = '_',
					dir = '_',
					snid = '_',
					padding0 = '_'
				},
				#'ElibBcIqIqcLinkParamsS' {
					portId = '_',
					dir = '_',
					snid = '_',
					padding0 = '_'
				},
				#'ElibBcIqIqcLinkParamsS' {
					portId = '_',
					dir = '_',
					snid = '_',
					padding0 = '_'
				},
				#'ElibBcIqIqcLinkParamsS' {
					portId = '_',
					dir = '_',
					snid = '_',
					padding0 = '_'}]}}.

board_cap_15() ->
		 #'ElibBcBoardCapabilityS'{
				boardCapabilityIdentity = ?ELIB_BC_CAP_IQ_TERM_SUPPORT,
				boardCapabilityLength = '_',
				capability = #'ElibBcLoadingSupportS'{
							loadable = '_',
							flash = '_',
							fileSystemAccess = '_',
							padding0 = '_',
							blockSize = '_'}}.

board_cap_16() ->
		NumOfEthLinks = case nci_common_utils:get_du() of
			dul -> 9;
			dus -> 8;
			mRBS_lte -> 4;
			_ -> 9
		end,
		 #'ElibBcBoardCapabilityS'{
				boardCapabilityIdentity = ?ELIB_BC_CAP_ETH_HW_IF_SUPPORT2,
				boardCapabilityLength = '_',
				capability = #'ElibBcEthHwIfSupport2S' {
			numOfEthLinks = NumOfEthLinks,
			padding0 = '_',
			ethLinkParam = [
				#'ElibBcEthLinkParam2S' {
					localSwitchPortNr = '_',
					portNr = '_',
					snid = '_',
					bandWidth = '_',
					direction = '_'
				},
				#'ElibBcEthLinkParam2S' {
					localSwitchPortNr = '_',
					portNr = '_',
					snid = '_',
					bandWidth = '_',
					direction = '_'
				},
				#'ElibBcEthLinkParam2S' {
					localSwitchPortNr = '_',
					portNr = '_',
					snid = '_',
					bandWidth = '_',
					direction = '_'
				},
				#'ElibBcEthLinkParam2S' {
					localSwitchPortNr = '_',
					portNr = '_',
					snid = '_',
					bandWidth = '_',
					direction = '_'
				},
				#'ElibBcEthLinkParam2S' {
					localSwitchPortNr = '_',
					portNr = '_',
					snid = '_',
					bandWidth = '_',
					direction = '_'
				},
				#'ElibBcEthLinkParam2S' {
					localSwitchPortNr = '_',
					portNr = '_',
					snid = '_',
					bandWidth = '_',
					direction = '_'
				},
				#'ElibBcEthLinkParam2S' {
					localSwitchPortNr = '_',
					portNr = '_',
					snid = '_',
					bandWidth = '_',
					direction = '_'
				},
				#'ElibBcEthLinkParam2S' {
					localSwitchPortNr = '_',
					portNr = '_',
					snid = '_',
					bandWidth = '_',
					direction = '_'
				},
				#'ElibBcEthLinkParam2S' {
					localSwitchPortNr = '_',
					portNr = '_',
					snid = '_',
					bandWidth = '_',
					direction = '_'
				},
				#'ElibBcEthLinkParam2S' {
					localSwitchPortNr = '_',
					portNr = '_',
					snid = '_',
					bandWidth = '_',
					direction = '_'
				}]}}.

board_cap_17() ->
		 #'ElibBcBoardCapabilityS'{
				boardCapabilityIdentity = ?ELIB_BC_CAP_INTERNAL_SYNC_LINK_SV_SUPPORT,
				boardCapabilityLength = '_',
				capability = #'ElibBcLoadingSupportS'{
							loadable = '_',
							flash = '_',
							fileSystemAccess = '_',
							padding0 = '_',
							blockSize = '_'}}.

%%------------------------------------------------------------------------------
%% @doc
%%  Sets state, performs connection setup, baseband clock activation,
%%  BCI fault subscription, which are common preparations for several test cases.
%%
%% Function: set_state_and_connect() -> ok
%%
%% @spec set_state_and_connect( State ) -> ok
%% @end
%%------------------------------------------------------------------------------
set_state_and_connect( State ) ->
	set_state_and_connect( State, ?BC_SERVER, ?DC_SERVER ).

set_state_and_connect( State, BcServer, DcServer ) ->
	{ok, session_up} = coli:subscribe_state(?SHELL_COMMAND),
	{ok, session_up} = osegw:subscribe_state(?OSE_GW_DEAMON_1),

	nci_bci_states:set_state([{state, State},{bcServer,BcServer}]),

	%% Connect to BCI interface
	ok = nci_bci_actions:conn_establish([{bcServer,BcServer}]),

	%% Subscribe Faults BCI
	ok = nci_bci_actions:subscribe_faults([{bcServer,BcServer}]),
 
	%% Audit
	case State of
		starting ->
			ok = nci_bci_actions:audit([{expectedSigNo, ?ELIB_BC_AUDIT_CFM},
										{expectedMainState, ?ELIB_BC_MAIN_STATE_STARTING},
										{bcServer,BcServer}]);
		starting_lmc_loaded ->
			ok = nci_bci_actions:audit([{expectedSigNo, ?ELIB_BC_AUDIT_CFM},
										{expectedMainState, ?ELIB_BC_MAIN_STATE_STARTING},
										{bcServer,BcServer}]);
		starting_lmc_not_loaded ->
			ok = nci_bci_actions:audit([{expectedSigNo, ?ELIB_BC_AUDIT_CFM},
										{expectedMainState, ?ELIB_BC_MAIN_STATE_STARTING},
										{bcServer,BcServer}]);
		operational ->
			ok = nci_bci_actions:audit([{expectedSigNo, ?ELIB_BC_AUDIT_CFM},
										{expectedMainState, ?ELIB_BC_MAIN_STATE_OPERATIONAL},
										{bcServer,BcServer}]);
		disabled ->
			ok = nci_bci_actions:audit([{expectedSigNo, ?ELIB_BC_AUDIT_CFM},
										{expectedMainState, ?ELIB_BC_MAIN_STATE_DISABLED},
										{bcServer,BcServer}])
	end,

	%% Enable BB CLK
	nci_common_utils:coli_cmd("tu c e", ""),

	%% Connect to DCI interface
	ok = nci_dci_actions:conn_establish([{dcServer,DcServer}]).
 
get_lmc_name() ->
	get_lmc_name("").

get_lmc_name(DuLnhPath) ->
	[FPGA_LMC_Latest_Rev | _FPGA_LMC_Renamed] = nci_common_utils:get_board_fpga_name(?SHELL_COMMAND, DuLnhPath),
	FPGA_LMC_Latest_Rev.

verify_idl2_link_up(Parameters) ->
	Coli = proplists:get_value(coli, Parameters, ?SHELL_COMMAND),
	PortNo = proplists:get_value(nearEndPortNo, Parameters),
	LineRate = proplists:get_value(lineRate, Parameters),
	PacketRatio = proplists:get_value(packetRatio, Parameters),
	DuLnhPath = proplists:get_value(nearEndDuLnhPath, Parameters, ""),

	Node2Exists = nci_ricm_utils:node_exists(node2),

	ct:pal("verify_idl2_link_up()~nColi = ~p~nPortNo = ~p~nLineRate = ~p~nPacketRatio = ~p~nDuLnhPath = ~p", [Coli, PortNo, LineRate, PacketRatio, DuLnhPath]),
	
	%% Clear CI_TRACE
	ct:pal("Clearing CI_TRACE"),
	CiCmdAddr = 16#4034 + (16#100 * (PortNo - 1)),
	nci_common_utils:wrfpga(Coli, CiCmdAddr, 16#00000003, DuLnhPath),
	
	%% Check CI_LINK_STATUS register
	%% Only check LED status, HFN sync and link status
	ExpectedLinkStatValue = 16#4047,
	ct:pal("Verifying CI_LINK_STATUS~nExpected value = 0x" ++ integer_to_list(ExpectedLinkStatValue, 16)),
	LinkStatAddr = 16#400c + (16#100 * (PortNo - 1)),
	%% Mask away unwanted bits
	LinkStatValue = nci_common_utils:rdfpga(Coli, LinkStatAddr, DuLnhPath) band 16#FFFF,
	ExpectedLinkStatValue = LinkStatValue,

	%% Check CI_CONFIG1 register
	%% A Type3-Type2 configuration does not support time sync (synchronous mode).
	%% Therefore the register contents will be different compared to Type3-Type3.
	ExpectedConfig1Value = 
		case Node2Exists of
			true ->
				%% Type3 - Type2 configuration
				case LineRate of
					?IDL2_LINE_RATE_2_5G  -> 16#084E4AEB;
					?IDL2_LINE_RATE_5G    -> 16#084E4B6B;
					?IDL2_LINE_RATE_10G   -> 16#084E4BEB;
					_ -> ct:fail("Invalid linerate: ~p", [LineRate])
				end;
			false ->
				%% Type3 - Type3 configuration
				case LineRate of
					?IDL2_LINE_RATE_2_5G  -> 16#084E5AEF;
					?IDL2_LINE_RATE_5G    -> 16#084E5B6F;
					?IDL2_LINE_RATE_10G   -> 16#084E5BEF;
					_ -> ct:fail("Invalid linerate: ~p", [LineRate])
				end;
			_ ->
				ct:fail("Unknown coli: ~p", [Coli])
		end,
			
	ct:pal("Verifying CI_CONFIG1~nExpected value = 0x" ++ integer_to_list(ExpectedConfig1Value, 16)),
	Config1Addr = 16#403c + (16#100 * (PortNo - 1)),
	Config1Value = nci_common_utils:rdfpga(Coli, Config1Addr, DuLnhPath),
	ExpectedConfig1Value = Config1Value,

	%% Check CI_CONFIG_PKT register
	ECPProtocol = case LineRate of
					  ?IDL2_LINE_RATE_2_5G -> 0;
					  _ -> 1
				  end,
	ECPEnable = 1,
	%% Assume IQC Protocol to always be since IQC is not enabled on IDL2
	IQCProtocol = 0,
	IQCEnable = 0,
	ExpectedConfigPktValue = (ECPEnable bsl 6) bor (ECPProtocol bsl 4) bor (IQCEnable bsl 2) bor IQCProtocol,
	ct:pal("Verifying CI_CONFIG_PKT~nExpected value = 0x" ++ integer_to_list(ExpectedConfigPktValue, 16)),
	ConfigPktAddr = 16#4038 + (16#100 * (PortNo - 1)),
	ConfigPktValue = nci_common_utils:rdfpga(Coli, ConfigPktAddr, DuLnhPath),
	ExpectedConfigPktValue = ConfigPktValue,

	%% Check CI_CONFIG_PKT_2 register
	GPAPFCProtocol = case LineRate of
						 ?IDL2_LINE_RATE_2_5G -> 0;
						 _ -> 1
					 end,
	ExpectedConfigPkt2Value = (PacketRatio bsl 20) bor (PacketRatio bsl 16) bor (GPAPFCProtocol bsl 8),
	ct:pal("Verifying CI_CONFIG_PKT_2~nExpected value = 0x" ++ integer_to_list(ExpectedConfigPkt2Value, 16)),
	ConfigPkt2Addr = 16#4044 + (16#100 * (PortNo - 1)),
	ConfigPkt2Value = nci_common_utils:rdfpga(Coli, ConfigPkt2Addr, DuLnhPath),
	ExpectedConfigPkt2Value = ConfigPkt2Value,
	
	%% Check CI_RX_STAT register
	%% A Type3-Type2 configuration does not support time sync (synchronous mode).
	%% Therefore the register contents will be different compared to Type3-Type3.
	ExpectedRXStatValue = 
		case Node2Exists of
			true ->
				%% Type3 - Type2 configuration
				16#00000159;
			false ->
				%% Type3 - Type3 configuration
				16#0000015B;
			_ ->
				ct:fail("Unknown coli: ~p", [Coli])
		end,
	ct:pal("Verifying CI_RX_STAT~nExpected value = 0x" ++ integer_to_list(ExpectedRXStatValue, 16)),
	RXStatAddr = 16#4010 + (16#100 * (PortNo - 1)),
	RXStatValue = nci_common_utils:rdfpga(Coli, RXStatAddr, DuLnhPath),
	ExpectedRXStatValue = RXStatValue,
	
	%% Wait 1 second to allow possible link failures reflected in CI_TRACE
	timer:sleep(1000),

	%% Check CI_TRACE register
	ExpectedTraceValue = 16#00080810,
	ct:pal("Verifying CI_TRACE~nExpected value = 0x" ++ integer_to_list(ExpectedTraceValue, 16)),
	TraceAddr = 16#402c + (16#100 * (PortNo - 1)),
	TraceValue = nci_common_utils:rdfpga(Coli, TraceAddr, DuLnhPath),
	ExpectedTraceValue = TraceValue.

verify_idl2_link_up_leaf(Parameters) ->
	Node2Exists = proplists:get_value(node2Exists, Parameters, false),
	LoadLMC = proplists:get_value(loadLMC, Parameters, true),
	DuLnhPath = proplists:get_value(farEndDuLnhPath, Parameters, ""),
	PortNo = proplists:get_value(farEndPortNo, Parameters),

	%% For the leaf node we must assign nearEndPortNo its farEndPortNo and nearEndDuLnhPath its farEndDuLnhPath in order for verify_idl2_link_up() to work
	NewParameters = proplists:delete(nearEndDuLnhPath, proplists:delete(nearEndPortNo, Parameters)) ++ [{nearEndPortNo, PortNo},
																										{nearEndDuLnhPath, DuLnhPath}],

	case Node2Exists of
		true ->
			verify_idl2_link_up(NewParameters ++ [{coli, ?SHELL_COMMAND_NODE2}]);
		_ ->
			case LoadLMC of
				true ->
					load_lmc_on_leaf(DuLnhPath);
				false ->
					ok
			end,
			
			verify_idl2_link_up(NewParameters)
	end.

verify_idl2_link_down(Parameters) ->
	Coli = proplists:get_value(coli, Parameters, ?SHELL_COMMAND),
	PortNo = proplists:get_value(nearEndPortNo, Parameters),
	DuLnhPath = proplists:get_value(nearEndDuLnhPath, Parameters, ""),

	ct:pal("verify_idl2_link_down()~nColi = ~p~nPortNo = ~p~nDuLnhPath = ~p", [Coli, PortNo, DuLnhPath]),

	%% Check CI_LINK_STATUS
	ct:pal("Verifying CI_LINK_STATUS~nLink state machine should not proceed further than state B (2)~nFA state machine should be in state XACQ1 (0)"),
	LinkStatAddr = 16#400c + (16#100 * (PortNo - 1)),
	LinkStatValue = nci_common_utils:rdfpga(Coli, LinkStatAddr, DuLnhPath),
	LinkState = LinkStatValue band 16#F,
	FAState = (LinkStatValue bsr 4) band 16#7,
	%% Link state machine should not proceed further than state B (2)
	if LinkState =< 2 ->
			ok;
	   true ->
			ct:fail("Link state machine is in invalid state ~p", [LinkState])
	end,
	%% FA state machine should be 0
	if FAState == 0 ->
			ok;
	   true ->
			ct:fail("FA state machine is in invalid state ~p", [FAState])
	end,

	%% Check CI_CONFIG1
	ExpectedConfig1Value = 16#084A402B,
	ct:pal("Verifying CI_CONFIG1~nSkipping line rate verifications~nExpected value = 0x" ++ integer_to_list(ExpectedConfig1Value, 16)),
	Config1Addr = 16#403c + (16#100 * (PortNo - 1)),
	Config1Value = nci_common_utils:rdfpga(Coli, Config1Addr, DuLnhPath),
	%% Mask away LINE_RATE and MAX_LINE_RATE
	ExpectedConfig1Value = Config1Value band 16#FFFFF07F.

verify_idl2_link_down_leaf(Parameters) ->
	Node2Exists = proplists:get_value(node2Exists, Parameters, false),
	DuLnhPath = proplists:get_value(farEndDuLnhPath, Parameters, ""),
	PortNo = proplists:get_value(farEndPortNo, Parameters),

	%% For the leaf node we must assign nearEndPortNo its farEndPortNo and nearEndDuLnhPath its farEndDuLnhPath in order for verify_idl2_link_down() to work
	NewParameters = proplists:delete(nearEndDuLnhPath, proplists:delete(nearEndPortNo, Parameters)) ++ [{nearEndPortNo, PortNo},
																										{nearEndDuLnhPath, DuLnhPath}],

	case Node2Exists of
		true ->
			verify_idl2_link_down(NewParameters ++ [{coli, ?SHELL_COMMAND_NODE2}]);
		_ ->
			%% Unable to verify link down on leaf if branch is DU1
			case proplists:get_value(nearEndDuId, NewParameters) of
				1 -> 
					ok;
				_ ->
					verify_idl2_link_down(NewParameters)
			end
	end.

wait_for_leaf(Node2Exists) ->
	case Node2Exists of
		true ->
			ct:pal("Give NSS some time to go back to freerunning on the leaf node");
		_ ->
			ct:pal("Wait for leaf node to perform a warm restart")
	end,
	timer:sleep(5*1000).

get_idpi_link_status2_ind_from_port(PortNo, OseGwDeamon) ->
	lists:foldl(
		fun(_, ReturnSignal) ->
				{ok, Ind} = nci_idpi_actions:link_status2_ind_recv_sig([{oseGwDeamon, OseGwDeamon}]),
				case Ind#'IdpiLinkStatus2IndS'.nearEndPortNo of
					PortNo ->
						Ind;
					_ ->
						ReturnSignal
				end
		end,
		[],
		lists:seq(1, 4)).

wait_for_meta_channel_data_from_intra() ->
	ct:pal("wait_for_meta_channel_data_from_intra()"),

	{ok, MetaData} = nci_idpi_actions:meta_channel_data_recv_sig([]),

	NearEndPortNo = MetaData#'IdpiMetaChannelDataS'.nearEndPortNo,
	SequenceNumber = MetaData#'IdpiMetaChannelDataS'.sequenceNumber,

	ok = nci_idpi_actions:meta_channel_ack_send([{nearEndPortNo, NearEndPortNo},
												 {sequenceNumber, SequenceNumber}]).

send_invalid_meta_channel_ack(Parameters) ->
	send_invalid_idpi_signal(Parameters, meta_channel_ack).

send_invalid_meta_channel_data(Parameters) ->
	send_invalid_idpi_signal(Parameters, meta_channel_data).

send_invalid_clk_status_fwd(Parameters) ->
	send_invalid_idpi_signal(Parameters, clk_status_fwd).

send_invalid_idpi_signal(Parameters, Type) ->
	ExpectedString = proplists:get_value(expectedString, Parameters),
	Coli = proplists:get_value(coli, Parameters, ?SHELL_COMMAND),
	DuLnhPath = proplists:get_value(duLnhPath, Parameters, ""),
	
	case DuLnhPath of
		"" ->
			{ok, TeLogBefore} = cpp_lib:get_te_log(Coli);
		_ ->
			{ok, TeLogBefore} = cpp_lib:get_te_log(Coli, DuLnhPath)
	end,
			
	case Type of
		meta_channel_ack ->
			ok = nci_idpi_actions:meta_channel_ack_send(Parameters);
		meta_channel_data ->
			ok = nci_idpi_actions:meta_channel_data_send(Parameters);
		clk_status_fwd ->
			ok = nci_idpi_actions:clk_status_fwd_send(Parameters);
		_ ->
			ct:fail("Invalid type ~p", Type)
	end,

	%% Sometimes the trace isn't printed out immediately due to various delays.
	%% A 1s delay should give RICM enough time to process the signal.
	timer:sleep(1000),

	case DuLnhPath of
		"" ->
			{ok, TeLogAfter} = cpp_lib:get_te_log(Coli);
		_ ->
			{ok, TeLogAfter} = cpp_lib:get_te_log(Coli, DuLnhPath)
	end,

	TeLog = TeLogAfter -- TeLogBefore,

	ct:pal("T&E log:~n~s", [string:join(TeLog, "\n")]),
	ct:pal("Expected string in T&E log:~n~s", [ExpectedString]),
	scan_te_log(TeLog, ExpectedString).

scan_te_log([], _) ->
	ct:fail("String not found in T&E log");
scan_te_log([FirstLine | Rest], ExpectedString) ->	
	case re:run(FirstLine, ExpectedString) of
		nomatch ->
			scan_te_log(Rest, ExpectedString);
		_ ->
			ok
	end.

reset_all_cpri_links(Radios) ->
	lists:foreach(fun(Radio) ->
		CascadeNo = proplists:get_value(cascadeNo,Radio),

		case CascadeNo of
			1 ->
				%% Reset CPRI Link
				ok = nci_dci_actions:reset_cpri_link(Radio),
				ok = nci_dci_actions:reset_cpri_link_ind(Radio);
			_ -> ok
		end
	end,
	Radios).

subscribe_states() ->
	Node2Exists = nci_ricm_utils:node_exists(node2),

	{ok, session_up} = coli:subscribe_state(?SHELL_COMMAND),
	{ok, session_up} = osegw:subscribe_state(?OSE_GW_DEAMON_1),

	case Node2Exists of
		true ->
			{ok, session_up} = coli:subscribe_state(?SHELL_COMMAND_NODE2),
			{ok, session_up} = osegw:subscribe_state(?OSE_GW_DEAMON_NODE2_1);
		_ ->
			ok
	end,

	ok.

load_lmc_on_leaf(DuLnhPath) ->
	BcServer = DuLnhPath ++ "/" ++ ?BC_SERVER,

	ct:pal("Waiting for ~s", [DuLnhPath]),
	ok = cpp_lib:poll_load_start(?SHELL_COMMAND, DuLnhPath, 120*1000),
	
	%% We need to load the DP LMC on the leaf node before we can use rdfpga to check registers	
	ok = nci_bci_actions:conn_establish([{bcServer, BcServer}]),
	
	LoadModule = get_lmc_name(DuLnhPath),
	SearchPath = nci_common_cfg:get_c_loadmodules_path(),
	
	ok = nci_bci_actions:load_lmc([{searchPath, SearchPath},
								   {loadModule, LoadModule},
								   {bcServer, BcServer}]).

get_leaf_du_parameters(Node2Exists, DuLnhPath) ->
	case Node2Exists of
		true ->
			LeafIDPServer = ?IDP_SERVER,
			LeafDuLnhPath = "",
			LeafOSEGW = ?OSE_GW_DEAMON_NODE2_1,
			LeafColi = ?SHELL_COMMAND_NODE2;
		_ ->
			LeafIDPServer = DuLnhPath ++ "/" ++ ?IDP_SERVER,
			LeafDuLnhPath = DuLnhPath,
			LeafOSEGW = ?OSE_GW_DEAMON_1,
			LeafColi = ?SHELL_COMMAND
	end,
	ct:pal("LeafIDPServer = ~p~n"
		   "LeafDuLnhPath = ~p~n"
		   "LeafOEGW = ~p~n"
		   "LeafColi = ~p", [LeafIDPServer, LeafDuLnhPath, LeafOSEGW, LeafColi]),
	
	{LeafIDPServer, LeafDuLnhPath, LeafOSEGW, LeafColi}.

start_idl2_links(Parameters) ->
	IDL2Links = proplists:get_value(idl2Links, Parameters),
	LineRate = proplists:get_value(lineRate, Parameters, ?IDL2_LINE_RATE_2_5G),
    PacketRatio = proplists:get_value(packetRatio, Parameters, 1),
	Node2Exists = proplists:get_value(node2exists, Parameters, false),

	lists:foreach(
		fun(IDL2Link) ->
				FarEndDuLnhPath = proplists:get_value(farEndDuLnhPath, IDL2Link),
				DcServer = get_dc_server(FarEndDuLnhPath),

				ok = nci_dci_actions:start_idl2_link(IDL2Link ++ [{packetRatio, PacketRatio},
																  {lineRate, LineRate}]),
				{ok, _} = nci_dci_actions:idl2_link_ind(IDL2Link ++ [{packetRatio, PacketRatio},
																	 {lineRate, '_'},
																	 {availStatus, ?RICM_IDL2_LINK_AVAILABLE}]),
				receive_time_sync_ind(IDL2Link, PacketRatio, '_'),

				case Node2Exists of
					false ->
						load_lmc_on_leaf(FarEndDuLnhPath),

						ok = nci_dci_actions:conn_establish([{dcServer, DcServer}]),

						ok = nci_dci_actions:subscribe_faults([{dcServer, DcServer}]);
					_ ->
						ok
				end
		end,
		IDL2Links).

stop_idl2_links(Parameters) ->
	IDL2Links = proplists:get_value(idl2Links, Parameters),
	Node2Exists = proplists:get_value(node2exists, Parameters, false),

	lists:foreach(
		fun(IDL2Link) ->
				ok = nci_dci_actions:stop_idl2_link(IDL2Link),

				wait_for_leaf(Node2Exists)
		end,
		IDL2Links).

receive_time_sync_ind(IDL2Link, PacketRatio, LineRate) ->
	Node2Exists = nci_ricm_utils:node_exists(node2),

	if Node2Exists == false ->
			nci_dci_actions:idl2_link_ind(IDL2Link ++ [{packetRatio, PacketRatio},
													   {lineRate, LineRate},
													   {availStatus, ?RICM_IDL2_LINK_AVAILABLE_SYNC}]);
	   true ->
			%% When we have a second node(type2) time sync is not available. 
			%% Therefore we should not wait for a START_IDL2_LINK_IND signal with availStatus = RICM_IDL2_LINK_AVAILABLE_SYNC
			ok
	end.

restart_ru(Radio) ->
	ct:pal("Restarting radio ~p", [Radio]),

	nci_ricm_utils:workaround_HS24704(),

	RuLnhPath = proplists:get_value(ruLnhPath,Radio),
	{Slot, _, _} = nci_common_utils:get_lmid(Radio ++[{radioSoftware, application}]),
	nci_common_utils:coli_cmd_with_output("lhsh " ++ RuLnhPath ++ " restart " ++ integer_to_list(Slot)).

cascade_restart_ru_post_signals(CurrentRadio, Radios) ->
	cascade_restart_ru_post_signals(CurrentRadio, Radios, false).

cascade_restart_ru_post_signals(CurrentRadio, Radios, CheckCeaseTime) ->
	cascade_restart_ru_post_signals(CurrentRadio, Radios, CheckCeaseTime, 0).

cascade_restart_ru_post_signals(CurrentRadio, Radios, CheckCeaseTime, UseLinkId) ->
	CurrentRadioPortNo = proplists:get_value(portNo,CurrentRadio),
	CurrentRadioCascadeNo = proplists:get_value(cascadeNo,CurrentRadio),

	lists:foreach(
		fun(RadioItem) ->
				PortNo = proplists:get_value(portNo,RadioItem),
				CascadeNo = proplists:get_value(cascadeNo,RadioItem),
				if (CurrentRadioPortNo == PortNo)
				   and
				   (CascadeNo >= CurrentRadioCascadeNo) ->

						if UseLinkId == 1 ->
								ok = nci_dci_actions:start_cpri_link3_ind(RadioItem ++[{availStatus, 0}]),
								%% No check of linkId is because RICM sends out indications depending on timeouts inside BCP
								%% which contradicts with the order in Radios list
								nci_dci_actions:add_cpri_link_ctl_ind([{connStatus, 0}]);
						   true ->
								ok = nci_dci_actions:cpri_link_ind(RadioItem ++[{availStatus, 0}]),
								%% No check of ruId is because RICM sends out indications depending on timeouts inside BCP
								%% which contradicts with the order in Radios list
								nci_dci_actions:radio_control_ind([{connStatus, 0}])
						end;
				   true ->
						ok
				end
		end,
		Radios),


	FaultId1 = nci_dci_actions:fault_ind([{faultId, ?ELIB_CONST_FH_FAULT_ID_LF_STABILITY},
										 {faultDescription, {regexp, "Temporary not in operation*"}}]),

	ok = nci_dci_actions:fault_cease_ind([{faultId, FaultId1}]),

	FaultId2 = nci_dci_actions:fault_ind([{faultId, ?ELIB_CONST_FH_FAULT_ID_LINK_FAILURE},
										  {faultDescription, {regexp, "Not in operation*"}}]),

	{RadioUpTime, FaultCeaseInTime} = 
		lists:foldl(
			fun(RadioItem,{CurrentRadioUpTime,CurrentFaultCeaseInTime}) ->
					PortNo = proplists:get_value(portNo,RadioItem),
					CascadeNo = proplists:get_value(cascadeNo,RadioItem),
					if (CurrentRadioPortNo == PortNo)
					   and
					   (CascadeNo >= CurrentRadioCascadeNo) ->
							if UseLinkId == 1 ->
									ok = nci_dci_actions:start_cpri_link3_ind(RadioItem ++ [{availStatus, 1}]),
									RadioUpTimePresentRadio = now(),

									ok = nci_dci_actions:add_cpri_link_ctl_ind(RadioItem ++ [{connStatus, 1}]);
							   true ->
									ok = nci_dci_actions:cpri_link_ind(RadioItem ++ [{availStatus, 1}]),
									RadioUpTimePresentRadio = now(),

									ok = nci_dci_actions:radio_control_ind(RadioItem ++ [{connStatus, 1}])
							end,

							if CurrentRadioUpTime == 0 ->
									ok = nci_dci_actions:fault_cease_ind([{faultId, FaultId2}]),

									FaultCeaseInTimePresentRadio = now(),
									{RadioUpTimePresentRadio, FaultCeaseInTimePresentRadio};
							   true ->
									{CurrentRadioUpTime,CurrentFaultCeaseInTime}
							end;
					   true ->
							{CurrentRadioUpTime,CurrentFaultCeaseInTime}
					end
			end,
			{0, 0},
			Radios),

	if CheckCeaseTime == true ->
			RadioUpTimeCeaseTimeDiff = timer:now_diff(FaultCeaseInTime, RadioUpTime),
			ct:pal("Time between Radio up and fault ceased: ~p seconds",[RadioUpTimeCeaseTimeDiff/1000000]),  %%1000000: To get microseconds to seconds

			%%There isn't a real requirement on RICM for this but since NC uses a 2.7 seconds timout after the link is up and create a alarm in case the link fault isn't ceased we test using 2.5 seconds to have a little bit of margin.
			case RadioUpTimeCeaseTimeDiff > 2500000 of  %%2.5 seconds 
				true ->
					ct:fail("Time between radio is started and fault ceased is too large");
				_ ->
					ok
			end;
	   true ->
			ok
	end.
	
verify_unit_delays(Radio, DelayInd) ->
	%% Get cascadeDl and cascadeUl delays from RICI interface
	nci_rici_actions:conn_establish(Radio),
	{_, RuPortNo} = proplists:get_value(ruPortNo, Radio),
	MasterRuPort = (RuPortNo + 1) rem 2,
	RTDInd = nci_rici_actions:get_round_trip_delay3(Radio ++ [{masterport, MasterRuPort}]),

	CascadePortDelayList = DelayInd#'RicmUnitDelayChangedIndS'.unitDelayValues#'RicmDelayParametersS'.cascadePortDelayList,
	CascadePortDelayDL = lists:nth(1, CascadePortDelayList),
	CascadePortDelayUL = lists:nth(2, CascadePortDelayList),

	%% RICM should report the delays in ns
	CascadeDL = CascadePortDelayDL#'Ricm_CascadePortDelay'.delay,
	CascadeUL = CascadePortDelayUL#'Ricm_CascadePortDelay'.delay,

	ct:pal("Received delays from RICM~ncascadeDL = ~p ns~ncascadeUL = ~p ns", [CascadeDL, CascadeUL]),

	%% Convert units of the RICR delays from 0.01ns to ns
	ExpectedCascadeDL = trunc((RTDInd#'RiciGetRtdMeas3CfmS'.cascadeDelayDL + 50) / 100),
	ExpectedCascadeUL = trunc((RTDInd#'RiciGetRtdMeas3CfmS'.cascadeDelayUL + 50) / 100),

	ct:pal("Received delays from RICR~ncascadeDL = ~p ns~ncascadeUL = ~p ns", [ExpectedCascadeDL, ExpectedCascadeUL]),

	MaxExpectedCascadeDL = ExpectedCascadeDL + 10,
	MinExpectedCascadeDL = ExpectedCascadeDL - 10,

	MaxExpectedCascadeUL = ExpectedCascadeUL + 10,
	MinExpectedCascadeUL = ExpectedCascadeUL - 10,

	if (CascadeDL =< MaxExpectedCascadeDL)
	   and
	   (CascadeDL >= MinExpectedCascadeDL) ->
			ok;
	   true ->
			ct:fail("CascadeDL ~p should be within range [~p, ~p]", [CascadeDL, MinExpectedCascadeDL, MaxExpectedCascadeDL])
	end,

	if (CascadeUL =< MaxExpectedCascadeUL)
	   and
	   (CascadeUL >= MinExpectedCascadeUL) ->
			ok;
	   true ->
			ct:fail("CascadeUL ~p should be within range [~p, ~p]", [CascadeUL, MinExpectedCascadeUL, MaxExpectedCascadeUL])
	end.

get_expected_unit_delay_values(Radio) ->
	{_, RuPortNoSlave} = proplists:get_value(ruPortNo, Radio),
	RuPortNoMaster = (RuPortNoSlave + 1) rem 2,

	%% DL delay ports
	DLDelayFrom = 
		#'Ricm_PortInfo'{portId = RuPortNoSlave,
						 portMode = ?Ricm_PortMode_Ricm_PortMode_SLAVE,
						 has_portMode = 1},
	DLDelayTo = 
		#'Ricm_PortInfo'{portId = RuPortNoMaster,
						 portMode = ?Ricm_PortMode_Ricm_PortMode_MASTER,
						 has_portMode = 1},

	%% UL delay ports
	ULDelayFrom = 
		#'Ricm_PortInfo'{portId = RuPortNoMaster,
						 portMode = ?Ricm_PortMode_Ricm_PortMode_MASTER,
						 has_portMode = 1},
	ULDelayTo = 
		#'Ricm_PortInfo'{portId = RuPortNoSlave,
						 portMode = ?Ricm_PortMode_Ricm_PortMode_SLAVE,
						 has_portMode = 1},

	CascadePortDelayEmpty = 
		#'Ricm_CascadePortDelay'{from = '_',
								 to = '_',
								 delay = '_',
								 has_delay = 0},
	CascadePortDelayDL = 
		#'Ricm_CascadePortDelay'{from = DLDelayFrom,
								 to = DLDelayTo,
								 %% Delay is don't care since it can't be verified in this structure
								 delay = '_',
								 has_delay = 1},
	CascadePortDelayUL = 
		#'Ricm_CascadePortDelay'{from = ULDelayFrom,
								 to = ULDelayTo,
								 %% Delay is don't care since it can't be verified in this structure
								 delay = '_',
								 has_delay = 1},

	CascadePortDelayList = 
		[CascadePortDelayDL,
		 CascadePortDelayUL,
		 CascadePortDelayEmpty,
		 CascadePortDelayEmpty,
		 CascadePortDelayEmpty,
		 CascadePortDelayEmpty,
		 CascadePortDelayEmpty,
		 CascadePortDelayEmpty],

	%% A radio has 2 cascade delays: DL and UL. Therefore count should be 2
	CascadePortDelayListCount = 2,

	RicmDelayParameters = 
		#'RicmDelayParametersS'{cpriLinkDelay = '_',
								lratIcmDelay = '_',
								wratIcmDelay = '_',
								gratIcmDelay = '_',
								cpriPartnerDelayList_count = 0,
								cpriPartnerDelayList = '_',
								cascadePortDelayList_count = CascadePortDelayListCount,
								cascadePortDelayList = CascadePortDelayList,
								bfnCompensationList_count = 0,
								bfnCompensationList = '_',
								has_cpriLinkDelay = 0,
								has_lratIcmDelay = 0,
								has_wratIcmDelay = 0,
								has_gratIcmDelay = 0
							   },

	RicmDelayParameters.

get_dc_server(LnhPath) ->
	case LnhPath of
		"000100" ->
			?DC_SERVER;
		_ ->
			LnhPath ++ "/" ++ ?DC_SERVER
	end.

set_du_unit_id(Radio) ->

	MasterUnitId = proplists:get_value(masterUnitId, Radio),

	if MasterUnitId == ?UNIT_ID_DU1 ->
			nci_dci_actions:set_du_unit_id([{unitId, ?UNIT_ID_DU1}]);
	   true ->
			ok
	end.

start_cpri_link(Radio) ->
	set_du_unit_id(Radio),
	nci_dci_actions:start_cpri_link3(Radio),
	nci_dci_actions:start_cpri_link3_ind(Radio ++ [{availStatus, 1}]).

start_oam_link(Radio) ->
	nci_dci_actions:add_cpri_link_ctl(Radio),
	nci_dci_actions:add_cpri_link_ctl_ind(Radio ++ [{connStatus, 1},
													{radioSoftware, application}]).

start_cpri_and_oam_link(Radio) ->
	start_cpri_and_oam_links([Radio]).

start_cpri_and_oam_links(Radios) ->
	ct:pal("start_cpri_and_oam_links()"),

	RadioStrings = 
		lists:map(
			fun(Radio) ->
					MasterUnitId = proplists:get_value(masterUnitId, Radio),
					MasterUnitPort = proplists:get_value(masterUnitPort, Radio),
					AssignSlaveUnitId = proplists:get_value(assignSlaveUnitId, Radio),
					AssignLinkId = proplists:get_value(assignLinkId, Radio),

					ReturnString = 
						"masterUnitId = " ++ integer_to_list(MasterUnitId) ++ ", "
						"masterUnitPort = " ++ integer_to_list(MasterUnitPort) ++ ", "
						"assignLinkId = " ++ integer_to_list(AssignLinkId) ++ ", "
						"assignSlaveUnitId = " ++ integer_to_list(AssignSlaveUnitId),

					ReturnString
			end,
			Radios),

	ct:pal("Starting CPRI and O&M links to the following radios:~n~s", [string:join(RadioStrings, "\n")]),

	lists:foreach(
		fun(Radio) ->
				start_cpri_link(Radio),
				start_oam_link(Radio)
		end,
		Radios).

stop_cpri_link(Radio) ->
	stop_cpri_links([Radio]).

stop_cpri_links(Radios) ->
	ct:pal("stop_cpri_links()"),

	lists:foreach(
		fun(Radio) ->
				%% Only stop links where the DU is master
				case proplists:get_value(masterUnitId, Radio) of
					?UNIT_ID_DU1 ->
						nci_dci_actions:stop_cpri_link(Radio),
						nci_dci_actions:stop_cpri_link_ind(Radio);
					_ ->
						ok
				end
		end,
		Radios).
